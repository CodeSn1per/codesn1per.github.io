# 反射


## 1. 反射机制

### 1. 介绍

* 反射机制允许程序在执行期借助ReflectionAPI取得任何类的内部信息(比如成员变量,构造方法,成员方法等等),并能操作对象的属性及方法.反射在设计模式和框架底层都会用到;
* 加载完类后,在堆中就产生了一个Class类型的对象(一个类只有一个Class对象),这个对象包含了类的完整结构信息.通过这个对象得到类的结构.这个对象就像一面镜子,透过这个镜子看到类的结构,所以,形象的称为反射;

### 2. 原理示意图

![image-20210722175047402](/image-20210722175047402.png)

### 3. 反射机制作用

* 在运行时判断任意一个对象所属的类
* 在运行时构造任意一个类的对象
* 在运行时得到任意一个类所具有的成员变量和方法
* 在运行时调用任意一个对象的成员变量和方法
* 生成动态代理

### 4. 反射相关的主要类

![image-20210722175839719](/image-20210722175839719.png)

### 5. 反射的有点和缺点

1. 优点: 可以动态的创建和使用对象(也是框架底层核心),使用灵活,没有反射机制,框架技术就失去底层支撑;
2. 缺点: 使用反射基本是解释执行,对执行速度有影响;

### 6. 反射调用优化-关闭访问检查

1. Method和Field,Constructor对象都有setAccessible()方法;
2. setAccessible作用是启动和禁用访问安全检查的开关;
3. 参数值为true表示反射的对象在使用时取消访问检查,提高反射的效率,参数值为false则表示反射的对象执行访问检查;

![image-20210723000032740](/image-20210723000032740.png)

## 2. Class类

### 1. 基本介绍

1. Class也是类,因此也继承Object类;

2. Class类对象不是new出来的,而是系统创建的;

3. 对于某个类的Class类对象,在内存中只有一份,因为类只加载一次;

4. 每个类的实例都会记得自己是由哪个Class实例所生成;

5. 通过Class可以完整的得到一个类的完整结构,通过一系列API

   ![image-20210723001418115](/image-20210723001418115.png)

6. Class对象时存放在堆的

7. 类的字节码二进制数据,是放在方法区的,有点地方称为类的元数据;

### 2. 获取Class类对象

#### 1. Class.forName()

1. 前提:已知一个类的全类名,且该类路径下,可通过Class类的静态方法forName()获取,可能抛出ClassNotFoundException
2. 应用场景:多用于配置文件,读取类全路径,加载类;

#### 2. 类名.class

1. 前提:若已知具体的类,通过类的class获取,该方式最为安全可靠,程序性能最高;
2. 应用场景:多用于参数传递,比如通过反射得到对应构造器对象;

#### 3. 对象.getClass()

1. 前提:已知某个类的实例,调用该实例的getClass()方法获取Class对象
2. 应用场景:通过创建好的对象,获取Class对象;

#### 4. 其他方式

ClassLoader cl=对象.getClass().getClassLoader();

Class clazz=cl.loadClass("类的全类名");

#### 5. 基本数据类型

Class clazz=基本数据类型.class

#### 6. 基本数据类型对应的包装类,可以通过.TYPE得到Class类对象

Class clazz=包装类.TYPE

### 3. 哪些类型有Class对象

1. 外部类,成员内部类,静态内部类,局部内部类,匿名内部类
2. interface
3. 数组
4. enum
5. annotation
6. 基本数据类型
7. void

## 3. 类加载

### 1. 基本说明

**反射机制是java实现动态语言的关键,也就是通过反射实现类动态加载**

1. 静态加载:编译时加载相关的类,如果没有则报错,依赖性太强;
2. 动态加载:运行时加载需要的类,如果运行时不用该类,则不报错,降低了依赖性;

### 2. 类加载时机

1. 当创建对象时(new)
2. 当子类被加载时
3. 调用类中的静态成员时
4. 通过反射

### 3. 类加载过程

![image-20210723024506187](/image-20210723024506187.png)

![image-20210723024601749](/image-20210723024601749.png)

![image-20210723024846841](/image-20210723024846841.png)

#### 1. 加载阶段

1. JVM在该阶段的主要目的是将字节码从不同的数据源转化为二进制字节流加载到内存中,并生成一个代表该类的Class对象;

#### 2. 连接阶段-验证

1. 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全
2. 包括:文件格式验证,元数据验证,字节码验证和符号引用验证
3. 可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施,缩短虚拟机类加载的时间

#### 3. 连接阶段-准备

1. JVM会在该阶段对静态变量,分配内存并默认初始化(对应数据类型的默认初始值);这些变量所使用的内存都将在方法区中进行分配;

#### 4. 连接阶段-解析

1. 虚拟机将常量池内的符号引用替换为直接引用的过程

#### 5. initialization(初始化)

1. 到初始化阶段,才真正开始执行类中定义的Java程序代码,此阶段是执行<clinit>()方法的过程
2. <clinit>()方法是由编译器按语句在源文件中出现的顺序,一次自动手机类中的所有静态变量的复制动作和静态代码块中的语句,并进行合并
3. 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁,同步,如果多个线程同时去初始化一个类,name之后有一个线程去执行这个类<clinit>()方法,其他线程都需要阻塞等待,知道活动线程执行<clinit>()方法完毕;

## 4. 通过反射获取类的结构信息

![image-20210723190333263](/image-20210723190333263.png)

![image-20210723190414207](/image-20210723190414207.png)

![image-20210723190304259](/image-20210723190304259.png)

![image-20210723190532963](/image-20210723190532963.png)

## 5. 通过反射创建对象

1. 方式一: 调用类中的public修饰的无参构造器
2. 方式二: 调用类中的指定构造器
3. Class类相关方法
   1. newInstance:调用类中的无参构造器,获取对应类的对象
   2. getConstructor(Class...clazz):根据参数列表,获取对应的构造器对象
   3. getDecalaredConstructor(Class..clazz):根据参数列表,获取对应的构造器对象
4. Constructor类相关对象
   1. setAccessible:爆破
   2. newInstance(Object...obj):调用构造器

## 6. 通过反射访问类中的成员

### 1. 访问属性

1. 根据属性名获取Field对象

   Field f= clazz对象.getDeclaredFidld(属性名)

2. 爆破:f.setAccessible(true);

3. 访问

   f.set(对象,值) f.get(对象)

4. 注意:如果是静态属性,则set和get中的对象可以写成null;

### 2. 访问方法

1. 根据方法名和参数列表获取Method方法对象:

   Method m=clazz.getDeclaredMethod(方法名,xx.class);

2. 获取对象:Object o=clazz.newInstance();

3. 爆破:m.setAccessible(true);

4. 访问:Object returnValue=m.invoke(对象,实参列表);

5. 注意:如果是静态方法,则invoke的对象,可以写成null;

**在反射中,如果方法有返回值,同一返回Object**

