<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>CodeSniper&#39; Blog</title>
        <link>https://codesn1per.github.io/</link>
        <description>This is My New Hugo Site</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>codesniperrrrr@gmail.com (CodeSniper)</managingEditor>
            <webMaster>codesniperrrrr@gmail.com (CodeSniper)</webMaster><lastBuildDate>Sun, 27 Mar 2022 22:24:16 &#43;0800</lastBuildDate>
            <atom:link href="https://codesn1per.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>Spring事务失效情况</title>
    <link>https://codesn1per.github.io/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/</link>
    <pubDate>Sun, 27 Mar 2022 22:24:16 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/</guid>
    <description><![CDATA[1. 抛出检查异常导致事务不能正确回滚  **原因: **Srping默认只会回滚非检查异常
  解法: 配置rollbackFor属性
 2. 业务方法内自己try-catch异常导致事务不能正确回滚  原因: 事务通知只有捕捉到了目标抛出的异常,才能进行后续的回滚处理,如果目标自己处理异常,事务通知无法获悉
  解法: 1. 异常原样抛出; 2. 手动设置TransactionStatus.setRollbackOnly();
 3. aop切面顺序导致事务不能正确回滚  原因: 事务切面优先级最低,但如果自定义的切面优先级和他一样,则还是自定义切面在内层,这时若自定义切面没有抛出异常
  解法: 同情况2
 4. 非public方法导致的事务失效  原因: Spring为方法创建代理,添加事务通知,前提条件都是该方法是public
  解法: 改为public方法
 5. 父子容器导致的事务失效  原因: 子容器扫描范围过大,把未加事务配置的service扫描进来
  解法: 1. 各扫描各的,不要图简便; 2. 不要用父子容器,所有bean放在同一容器
 6. 调用本类方法导致传播行为失效  原因: 奔雷方法调用不经过代理,因此无法增强
  **解法: **1. 依赖注入自己(代理)来调用; 2. 通过AopContext拿到代理对象,来调用; 3. 通过CTW,LTW实现功能增强]]></description>
</item><item>
    <title>SpringBean的生命周期</title>
    <link>https://codesn1per.github.io/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
    <pubDate>Sun, 27 Mar 2022 13:14:08 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
    <description><![CDATA[阶段一: 处理名称,检查缓存 阶段二: 检查父工厂 阶段三: 检查DependsOn 阶段四: 按Scope创建bean  创建singleton 创建prototype 创建其他scope   阶段五: 创建bean  创建bean实例 依赖注入 初始化 登记可销毁bean   阶段六: 类型转换 阶段七: 销毁bean  阶段一: 处理名称,检查缓存  先把别名解析为实际名称,再进行后续处理 若要FactoryBean本身,需要使用&amp;名称获取 singletonObjects是一级缓存,放单例成品对象 singletonFactories是三级缓存,放单例工厂 earlySingletonObjects是耳机缓存,放单例工厂的产品,可成为提前单例对象  阶段二: 处理父子容器 阶段三: 阶段四: 按Scope创建bean  scope理解为从xxx范围内找到bean更加贴切 singleton scope表示从单例池范围获取bean,如果没有,则创建并放入单例池 prototype scope表示从不缓存bean,每次都创建新的 request scope表示从request对象范围内获取bean,如果没有,则创建并放入request  阶段五: 创建bean 1. 创建bean实例   FactoryMethod方式创建bean实例
 分成静态工厂与实例工厂 工厂方法若有参数,需要对工厂方法参数进行解析,利用resolveDependency 如果有多个工厂方法候选者,还要进一步按权重筛选    AutowiredAnnotationBeanPostProcessor
 优先选择带@Autowired注解的构造 若有唯一的带参构造,也会入选    才有默认构造]]></description>
</item><item>
    <title>MySQL索引</title>
    <link>https://codesn1per.github.io/mysql%E7%B4%A2%E5%BC%95/</link>
    <pubDate>Sat, 26 Mar 2022 15:28:31 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/mysql%E7%B4%A2%E5%BC%95/</guid>
    <description><![CDATA[1. 索引是什么?  索引时帮助MySQL高效获取数据的数据结构; 索引存储在文件系统中; 索引的文件存储形式与存储引擎有关; 索引文件的结构  hash 二叉树 B树 B+树     1. hash表的索引形式
缺点:
 利用hash存储的话需要将所有数据文件添加到内存,比较耗费内存空间 如果所有的查询都是等值查询,那么hash确实很快,但是使用范围查找情况更多,因此hash就不太适合了    2. 二叉树的索引形式
缺点:
 无论是二叉树还是红黑树,都会因为树的深度过深而造成io次数变多,影响数据读取效率    3. B树的索引形式
特点:
 所有键值分布在整棵树上 搜索有可能在非叶子节点结束,在关键字全集内做一次查找,性能逼近二次查找 每个节点最多拥有m个子树 根节点至少有两个子树 分支节点至少拥有m/2棵子树(除根节点和叶子节点都是分支节点) 所有叶子节点都在同一层,每个节点最多可以又m-1个key,并且以升序排列   ]]></description>
</item><item>
    <title>线程安全之CAS操作</title>
    <link>https://codesn1per.github.io/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8Bcas%E6%93%8D%E4%BD%9C/</link>
    <pubDate>Thu, 24 Mar 2022 18:05:17 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8Bcas%E6%93%8D%E4%BD%9C/</guid>
    <description><![CDATA[背景介绍：假设现在有一个线程共享的变量c=0，让两个线程分别对c进行c++操作100次，那么我们最后得到的结果是200吗？
**1.在线程不安全的方式下:**结果可能小于200，比如当前线程A取得c的值为3，然后线程A阻塞了，线程B取得的c的值也是3，然后线程B也阻塞了，现在线程A被唤醒执行了++操作使得c=4，结果写回c值内存，线程A执行结束，线程B被唤醒执行了++操作使得3++=4，也写回了c值内存，现在问题来了，两个线程分别进行了一次++操作，最后c值却为4而不是5，所以c值最后的结果肯定是小于200的，产生这种情况的原因就是线程不安全！，两个线程在同一时间读取了c值，然后又没有各种先执行完++操作而被阻塞（就是没有同步）
**2.在线程安全的方式下:**比如++操作加上synchronized同步锁，结果一定是200，因为这样使得读取c值和++操作是一个原子性操作，不能被打断，所以线程是安全的，保证了同步
现在问题来了，我们要保证线程安全只有加synchorized同步锁这一种办法吗？synchorized同步锁又有什么缺点呢?
当然不仅只有synchorized这一种方法，还有原子操作类，关于原子操作类我们等下再说，先说说synchorized的缺点：
syschorized缺点：
synchorized的缺点关键在于性能！我们知道synchorized关键字会让没有得到锁资源的线程进入Blocked状态，而在得到锁的资源恢复为Runnable状态，这个过程涉及到操作系统用户模式和内核模式的切换，代价比较高！
现在我们来说说原子操作类，顾名思义，就是保证某个操作的原子性，那它是怎么实现的呢？这个我们就要垃圾原子操作类的底层：CAS机制了
CAS机制的英文缩写是Compare and Swap，翻译一下就是比较和交换
CAS机制中使用3个基本操作数：内存地址V，旧的预期值A，要修改的新值B，更新一个变量的时候，只有当变量的旧的预期值A和内存地址V中的值相同的时候，才会将内存地址V中的值更新为新值B
下面举个栗子：
1）内存地址V中存放着值为10的变量
2）此时线程1要把变量值加1，对线程1来说，旧的预期值A=10，要修改的新值B=11
3）在线程1提交更新之前，另外一个线程2提前一步将内存地址V中的变量值率先更新成了11
4）线程1此时开始提交更新，首先进行A和内存地址V中的值比较，发现A不等于此时内存地址V中的值11，提交失败
5）线程1尝试重新获取内存地址V的当前值，并重新计算想要修改的值，对线程1来说，此时旧的预期值A=11，要修改的新值B=12，这个重新尝试的过程叫做自旋
6）这一次比较幸运，没有其他线程更改内存地址V中的值，线程1进行compare，发现A和内存地址V中的值相同
7）线程1进行Swap，把内存地址V中的值替换为B，也就是12
这个过程涉及到以下几个问题：
问题1：如何保证获取的当前值是内存中的最新值？（如果每次获得的当前值不是内存中的最新值，那么CAS机制将毫无意义）
用volatile关键字修饰变量，使得每次对变量的修改操作完成后一定会先写回内存，保证了每次获取到值都是内存中的最新值！
问题2：如何保证Compare和Swap过程中的原子性（如果Compare和Swap过程不是原子性操作，那么CAS机制也毫无意义）？
Compare和Swap过程的原子性是通过unsafe类来实现的，unsafe类为我们提供了硬件级别的原子操作！
总结一下：从思想上来说，Synchorized属于悲观锁，悲观的认为程序中的并发多，所以严防死守，CAS机制属于乐观锁，乐观的认为程序中并发少，让线程不断的去尝试更新
那么现在又有一个问题来了，CAS机制有什么缺点呢？
CAS机制的缺点：
1.CPU开销过大：在并发量比较高的情况下，如果许多线程反复尝试去更新一个变量，却又一直更新失败，循环往复，会消耗CPU很多资源
2.ABA问题：假设在内存中有一个值为A的变量储存在内存地址V当中，此时有三个线程使用CAS机制更新这个变量的值，每个线程的执行时间都略有偏差，线程1和线程2已经获取当前值，线程3还没有获取当前值。接下来线程1先一步执行成功，把当前值成功从A更新为B，同时线程2因为某种原因被阻塞，没有做更新操作，线程3在线程1更新成功之后获取了当前值B，再之后线程2仍然阻塞，线程3继续执行，成功将当前值更新为A，最后，线程2终于恢复了运行状态，由于线程2之前获取了“当前值A”并且经过了Compare检测，内存地址中的实际值也是A，所以线程2最后把变量A更新成了B，在这个过程中，线程2获取的当前值是一个旧值，尽管和当前值一模一样，但是内存地址中V中的变量已经经历了A-&gt;B-&gt;A的改变
表面看没有什么影响，但是如果实际中理由CAS机制从取款机上取钱，假如账户开始有100元，在取款机上取走50，取款机出现问题一共提交了两次请求（线程1，线程2），第二次请求（线程2）在执行时因为某种原因被阻塞了，这时候有人往你的账户打了50元，线程2恢复了可执行状态，这个时候就会出现问题，原本线程2应该执行失败的，但是比较后仍然与旧值一致，这样就造成了账户实际上扣款了两次！
ABA问题解决的方案：在Compare阶段不仅比较预期值和此时内存中的值，还比较两个比较变量的版本号是否一致，只有当版本号一致才进行后续操作，这样就完美的解决了ABA问题！
3.不能保证代码块的原子性：CAS机制保证的是一个变量的原子性操作，若要保证多个变量的原子性操作，可以封装在一起，但是这样得不偿失，开销太大，还不如直接采用synchorized同步锁]]></description>
</item><item>
    <title>Aop</title>
    <link>https://codesn1per.github.io/aop/</link>
    <pubDate>Wed, 16 Mar 2022 18:47:34 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/aop/</guid>
    <description><![CDATA[AOP是什么   AOP(Aspect Oriented Programming),意味面向切面编程,可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态同一添加功能的一种技术.
  AOP的编程思想就是把很多类对象的横切问题点,从业务逻辑中分离出来,从而达到解耦的目的,增加代码的重用性,提高开发效率
  AOP应用场景  日志记录 异常处理 权限验证 缓存处理 事务处理 数据持久化 效率检查 内容分发  Aspect概念  aspect:切面,切面有切点和通知组成,即包括横切逻辑的定义也包括连接点的定义 pointcut: 切点,每个类都拥有多个连接点,可以理解是连接点的集合 joinpoint: 连接点,程序执行的某个特定位置,如某个方法调用前后等 weaving: 织入,将增强添加到目标类的具体连接点的过程 advice: 通知,是织入到目标类连接点上的一段代码,就是增强到什么地方?增强什么内容? target: 目标对象,通知织入的目标类 aop Proxy: 代理对象,即增强后产生的对象  Spring AOP底层实现,是通过JDK动态代理或CGlib代理在运行时期在对象初始化阶段织入代码的
   Before advice
前置通知,即在目标方法调用之前执行.注意: 无论方法是否遇到异常都执行
  After returning advice
后置通知,在目标方法执行后执行,前提是目标方法没有遇到异常,如果有异常则不执行通知
  After throwing advice
异常通知,在目标方法抛出异常时执行,可以获取异常信息
  After finally advice
最终通知,在目标方法执行后执行,无论是否是异常执行
  Around advice]]></description>
</item><item>
    <title>动态代理</title>
    <link>https://codesn1per.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
    <pubDate>Wed, 16 Mar 2022 12:57:14 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
    <description><![CDATA[1. 动态代理的实现 1. jdk动态代理:   使用java反射包中的类和接口实现动态代理的功能 反射包 java.lang.reflect,里面有三个类:InvocationHandler,Method,Proxy   2. cglib动态代理   cglib是第三方的工具库,创建代理对象. cglib的原理是继承,cglib通过继承目标类,创建他的子类,在子类中重写父类中同名的方法,实现功能的修改. 因为cglib是继承,重写方法,所以要求目标类不能是final的,方法也不能是final的   2. jdk动态代理 1. 反射,Method类,表示方法,类中的方法.通过Method可以执行某个方法. 2. jdk动态代理的实现  InvocationHandler
  就一个方法invoke()
  invoke():表示代理对象要执行的功能代码,你的代理类要完成的功能卸载invoke()方法中.
  方法原型:
参数: Object proxy: jdk创建的代理对象,无需赋值
Method method: 目标类中的方法,jdk提供method对象的
Object[] args: 目标类中的方法的参数,jdk提供
    Method
 表示方法的,确切的说是目标类中的方法 通过Mehtod可以执行某一个目标类的方法,Method.invoke()    Proxy
 核心的对象,创建的代理对象,之前创建对象都是用new类的构造方法(),现在使用Proxy类的方法,代替new的使用 静态方法:newProxyInstance(),创建代理对象 参数:  classLoader loader: 类加载器,负责向内存中加载对象的.使用反射获取对象的ClassLoader Class&lt;?&gt;[] interfaces: 接口,目标对象实现的接口,也是反射获取的 InvocationHander h: 我们自己写的,代理类要完成的功能     ]]></description>
</item><item>
    <title>Spring事务</title>
    <link>https://codesn1per.github.io/spring%E4%BA%8B%E5%8A%A1/</link>
    <pubDate>Tue, 15 Mar 2022 12:55:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/spring%E4%BA%8B%E5%8A%A1/</guid>
    <description><![CDATA[1. 基本概念   事务是数据库操作的最小工作单元,是作为单个逻辑工作单元执行的一些列操作;这些操作作为一个整体一起向系统提交,要么都执行,要么都不执行;事务是一组不可再分割的操作集合
  通俗点说就是为了达到某个目的而做的一些列操作,要么一起成功(事务提交),要么一起失败(事务回滚)
  2. 事务的四大特性  原子性(Atomicity): 事务中所有操作时不可再分割的原子单位.事务中所有操作要么全部执行成功,要么全部执行失败 一致性(Consistency): 事务执行后,数据库状态与其他业务规则保持一致,如转账业务,无论事务执行成功与否,参与转账的两个账号余额之和应该是不变的 隔离性(Isolation): 隔离性是指在并发操作中,不同事务之间应该隔离开来,使每个并发的事务不会相干扰 持久性(Durability): 一旦事务提交成功,事务中的所有数据操作都必须被持久化到数据库中,即使提交事务后,数据库崩溃,在数据库重启时,也能保证某种机制恢复数据  3. 事务的隔离级别   脏读(读取了未提交的数据,然后被回滚了)
事务A读取了事务B中尚未提交的数据,如果事务B回滚,则A读取使用了错误的数据
  不可重复读(读取了提交的新事物,指更新操作)
不可重复读是指在对于数据库中的某个数据,一个事务范围内多次查询却返回了不同的数据,这是由于在查询间隔,被另一个事务修改并提交了
  幻读(读取了提交的新事物,指增删操作)
  ​	在事务A多次读取中,事务B对数据进行了新增操作,导致事务A多次读取的数	据不一致
  第一类事务丢失(回滚丢失)
对于第一类事务丢失,就是比如A和B同时在执行一个数据,然后B事务已经提交了,然后A事务回滚了,这样B事务的操作就因A事务的回滚二丢失了
  第二类事务丢失(覆盖丢失)
  ​	对于第二类事务丢失,也称为覆盖丢失,就是A和B一起执行一个数据,两个同时取一个数据,然后B事务首先提交,但是A事务接下来又提交,这样就覆盖了B事务
 Read uncommitted
读未提交,就是一个事务可以读取另一个未提交事务的数据,会产生脏读
  Read committed
读已提交,就是一个事务要等到另一个事务提交后才能读取数据,会产生不可重复读
  Repeatable read
重复读,就是在开始读取数据(事务开启时),不在允许修改操作,可能会产生幻读
  Serializable
最高的事务隔离级别,在该级别下,事务串行化顺序执行,可以毕淼脏读,不可重复读与幻读,但这种事务隔离级别效率低下,比较耗数据库性能,一般不使用
 ]]></description>
</item><item>
    <title>面试题</title>
    <link>https://codesn1per.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
    <pubDate>Thu, 10 Mar 2022 16:57:05 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
    <description><![CDATA[springmvc执行流程 数据参数在handler处理 mybatis 分页插件如何实现 动态sql如何写 方法和sql如何绑定 先namespace 线程 进程关系 线程的状态 6种 interipped notify all区别 线程安全 写 锁机制 new创建字符串 syn锁升级 反射可以获取私有信息吗 需要设置一下setaccess 自定义注解 多态的理解 封装 treeset如何去重 compareto 数组链表区别 序列化 反序列化 Spring如何为我们创建对象 动态代理 Springbean生命周期 init aware 对象作用域 threadlocal 私有化 线程隔离 底层机制 threallocalmap k v Spring 如何解决循环依赖 三级缓存 linux的常用 ps -ef 进程号 kill 全局找一个文件 find 动态查看日志 tail f 动态 n 末尾多少行 数据库隔离级别 读未提交 读以提交 可重复读 串行化 存储引擎 sql语句执行过程 先执行from
hashmap循环链表
1.你怎么理解线程的优先级？ 2.线程之间是如何通信的？ 3.线程池怎么配置的？ 4、并发编程的三要素是什么？ 5、hashmap的底层原理？ 6、ArrayList和 LinkedList 的区别在哪里？ 7、我们常说spring全家桶，他包含哪些部分？ 8、能说一下基于XML配置方式的搭建SSM框架的步骤嘛？ 9、如果数据库表锁了，数据插入不了，怎么办？ 10、 mysql 的存储引擎有哪些，区别是什么 11、maven有哪些优缺点，如何解决jar包的冲突？ 12、能说一下常用的linux部署命令嘛？]]></description>
</item><item>
    <title>MySQL高级</title>
    <link>https://codesn1per.github.io/mysql%E9%AB%98%E7%BA%A7/</link>
    <pubDate>Sat, 19 Feb 2022 15:25:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/mysql%E9%AB%98%E7%BA%A7/</guid>
    <description><![CDATA[1. 存储引擎 1.1. 对比MyISAM和InnoDB    对比项 MyISAM InnoDB     主外键 不支持 支持   事务 不支持 支持   行表锁 表锁,即使操作一条记录也会锁住整个表,不适合高并发的操作 行锁,操作时只锁一行,不对其他行有影响,适合高并发的操作   缓存 只缓存索引,不缓存真实数据 不仅缓存索引还要缓存真实数据,对内存要求较高,而且内存大小对性能有决定性的影响   表空间 小 大   关注点 性能 事务   默认安装 Y Y    1.2. 阿里巴巴,淘宝用哪个?    产品 价格 目标 主要功能 是否可投入生产     PerCona Server 免费 提供XtraDB存储引擎的包装器和其他分析工具 XtraDB 是   MariaDB 免费 拓展MySQL以包含XtraDB和其他性能改进 XtraDB 是   Drizzle 免费 提供比MySQL更强大的可拓展性和性能改进 高可用性 是     Percona为MySQL数据库服务器进行了改进,在功能和性能上较MySQL有着很显著的提升.]]></description>
</item><item>
    <title>SpringCloud</title>
    <link>https://codesn1per.github.io/springcloud/</link>
    <pubDate>Fri, 18 Feb 2022 20:13:04 &#43;0800</pubDate>
    <author>Author</author>
    <guid>https://codesn1per.github.io/springcloud/</guid>
    <description><![CDATA[SpringCloud 1. Eureka 1. 提供者与消费者  服务提供者: 一次业务中,被其他服务调用的服务(提供接口给其他服务) 服务消费者: 一次业务中,调用其他服务的服务(调用其他服务提供的接口) 提供者与消费者角色是相对 一个服务可以同时是服务提供者和服务消费者  2. Eureka注册中心  注册服务信息 拉取服务 负载均衡 远程调用 心跳续约 30s/次  1. Eureka的作用  消费者该如何获取服务提供者的具体信息?  服务提供者启动时向eureka注册自己的信息 eureka保存这些信息 消费者根据服务名称想eureka拉取提供者信息   如果有多个服务提供者,消费者该如何选择?  服务消费者利用负载均衡算法,从服务列表中挑选一个   消费者如何感知服务提供者健康状态?  服务提供者会每隔30s向eurekaServer发送心跳请求,报告健康状态 eureka会更新记录服务列表信息,心跳不正常会被剔除 消费者就可以拉取最新的信息    2. 服务注册  引入eureka-client依赖 在application.yml中配置eureka地址  2. Ribbon 1. Ribbon负载均衡规则  规则接口是IRule 默认实现是ZoneAvoidanceRule,根据zone选择服务列表,然后轮询  2. 负载均衡自定义方式  代码方式: 配置灵活,但修改时需要重新打包发布 配置方式: 直观,方便,无需重新打包发布,但是无法做全局配置  3. 饥饿加载  开启饥饿加载 eager-load 指定饥饿加载的服务名称  3.]]></description>
</item></channel>
</rss>
