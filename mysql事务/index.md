# MySQL事务


### 1. 基本概念

* 事务是数据库操作的最小工作单元,是作为单个逻辑工作单元执行的一些列操作;这些操作作为一个整体一起向系统提交,要么都执行,要么都不执行;事务是一组不可再分割的操作集合

* 通俗点说就是为了达到某个目的而做的一些列操作,要么一起成功(事务提交),要么一起失败(事务回滚)

### 2. 事务的四大特性

1. 原子性(Atomicity): 事务中所有操作时不可再分割的原子单位.事务中所有操作要么全部执行成功,要么全部执行失败
2. 一致性(Consistency): 事务执行后,数据库状态与其他业务规则保持一致,如转账业务,无论事务执行成功与否,参与转账的两个账号余额之和应该是不变的
3. 隔离性(Isolation): 并发执行的事务不会互相影响,其对数据库的影响和他们串行执行时一样.比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的记过一样
4. 持久性(Durability): 一旦事务提交成功,事务中的所有数据操作都必须被持久化到数据库中,即使提交事务后,数据库崩溃,在数据库重启时,也能保证某种机制恢复数据

### 3. 事务的隔离级别

* 脏读(读取了未提交的数据,然后被回滚了)

   事务A读取了事务B中尚未提交的数据,如果事务B回滚,则A读取使用了错误的数据

* 不可重复读(读取了提交的新事物,指更新操作)

  不可重复读是指在对于数据库中的某个数据,一个事务范围内多次查询却返回了不同的数据,这是由于在查询间隔,被另一个事务修改并提交了

* 幻读(读取了提交的新事物,指增删操作)

​	在事务A多次读取中,事务B对数据进行了新增操作,导致事务A多次读取的数	据不一致

* 第一类事务丢失(回滚丢失)

  对于第一类事务丢失,就是比如A和B同时在执行一个数据,然后B事务已经提交了,然后A事务回滚了,这样B事务的操作就因A事务的回滚二丢失了

* 第二类事务丢失(覆盖丢失)

​	对于第二类事务丢失,也称为覆盖丢失,就是A和B一起执行一个数据,两个同时取一个数据,然后B事务首先提交,但是A事务接下来又提交,这样就覆盖了B事务

> Read uncommitted
>
> 读未提交,就是一个事务可以读取另一个未提交事务的数据,会产生脏读

> Read committed
>
> 读已提交,就是一个事务要等到另一个事务提交后才能读取数据,会产生不可重复读

> Repeatable read
>
> 重复读,就是在开始读取数据(事务开启时),不在允许修改操作,可能会产生幻读

> Serializable
>
> 最高的事务隔离级别,在该级别下,事务串行化顺序执行,可以避免脏读,不可重复读与幻读,但这种事务隔离级别效率低下,比较耗数据库性能,一般不使用

### 4. 事务的实现原理

* 原子性是通过undo log来实现

  > * Undo Log是为了实现事务的原子性,在MySQL数据库InnoDB存储引擎中,Undo Log来实现多版本并发控制(MVCC)
  > * 在操作任何数据之前,首先将数据备份到一个地方(Undo log).然后进行数据的修改.如果出现错误或者用户执行了ROLLBACK语句,系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态
  > * Undo Log是逻辑日志,可以理解为:
  >   * 当delete一条记录时,Undo Log中会记录一条对应的insert记录
  >   * 当insert一条记录时,会记录一条对应的delete记录
  >   * update一条记录时,他记录一套对应相反的update记录

* 持久性通过redo log来实现

  > * 和Undo Log相反,Redo Log记录的是新数据的备份.在事务提交前,只要将Redo Log持久化即可,不需要将数据持久化.当系统崩溃时,虽然数据没有持久化,但是Redo Log已经持久化.系统可以根据Redo Log的内容,将所有数据恢复到最新的状态

* 隔离性是通过(读写锁 + MVCC)来实现

  > * 事务具有隔离性,理论上来说事务之间的执行不应该相互产生影响,其对数据库的影响应该和他们串行执行时一样
  > * 然而完全的隔离性会导致系统并发性能很低,降低对资源的利用率,因而实际上对隔离性的要求会有所放宽,这也会一定程度造成对数据库一致性要求降低
  > * SQL标准为事务定义了不同的隔离级别,从低到高一次是
  >   * 读未提交(READ UNCOMMITTED): 对事务处理的读取没有任何限制,不推荐
  >   * 读已提交(READ COMMITTED)
  >   * 可重复度(REPEATABLE READ)
  >   * 串行化(SERIALIZABLE)
  > * **在MySQL中,锁可以分为两类**
  >   * 共享锁: 共享锁定是将对象数据变为只读形式,不能进行更新,所以也成为读取锁定
  >   * 排它锁: 排它锁定时当执行INSERT/UPDATE/DELETE的时候,其他事务不能读取该数据
  > * 锁定粒度: 锁定对象的大小是锁的粒度
  >   * 记录
  >   * 表
  >   * 数据库

* 一致性是通过原子性,持久性,隔离性来实现的

### 5. 故障及故障恢复

* 事务的执行流程如下
  * 系统会为每个事务开辟一个私有工作区
  * 事务读操作将从磁盘中拷贝数据项到工作区,在执行写操作前所有的更新都作用于工作区中的拷贝
  * 事务的写操作将把数据输出到内存的缓冲区中,等到合适的时间在由缓冲区管理器将数据写入到磁盘
* 由于数据库存在立即修改和延迟修改,所以在事务执行过程中可能存在以下情况:
  * 在事务提交前出现故障,但是事务对数据库的部分修改已经写入磁盘数据库中,这导致了事务的原子性被破坏
  * 在系统崩溃前事务已经提交,但数据还在内存缓冲区中,没有写入磁盘.系统恢复时将丢失此次已提交的修改.这是对事务持久性的破坏
* 撤销事务undo: 将事务更新的所有数据项恢复为日志中的旧值
* 重做事务redo: 将事务更新的所有数据项恢复为日志中的新值
* 事务正常回滚/因事务故障中止将进行redo
* 系统从崩溃中恢复时将先进行redo在进行undo

