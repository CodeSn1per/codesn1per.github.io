[{"categories":null,"content":"1. 用户管理 1.1 用户列表 根据登录名称,手机号码,用户状态,创建时间,和学校等参数分页查询用户数据,返回用户列表. controller层代码 mapper层代码 页面截图 1.2 用户新增 根据用户填入的信息,创建该用户.赋予一个默认的登录密码; controller层代码 mapper层代码 页面截图 ","date":"2022-04-29","objectID":"/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/:0:1","tags":null,"title":"详细设计","uri":"/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"2. 角色管理 2.1 角色列表 根据角色名称,权限字符,角色状态,创建时间查询符合条件的用户信息,可以新增,修改,删除和导出这些数据. controller层代码 mapper层代码 页面截图 2.2 角色新增 根据管理员传入的角色信息,去创建新的角色,并赋予对应的菜单权限. controller层代码 mapper层代码 页面截图 ","date":"2022-04-29","objectID":"/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/:0:2","tags":null,"title":"详细设计","uri":"/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"3 菜单管理 3.1 菜单列表 根据菜单名称,菜单状态搜索对应的菜单,管理员用户对菜单进行新增,修改和删除操作. controller层代码 mapper层代码 3.2 菜单新增 controller层代码 mapper层代码 页面截图 ","date":"2022-04-29","objectID":"/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/:0:3","tags":null,"title":"详细设计","uri":"/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"},{"categories":["搜索引擎"],"content":"1. 添加依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-elasticsearch\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2022-04-28","objectID":"/springboot%E6%95%B4%E5%90%88es/:0:1","tags":["ElasticSearch"],"title":"SpringBoot整合ES","uri":"/springboot%E6%95%B4%E5%90%88es/"},{"categories":["搜索引擎"],"content":"2. 配置客户端 @Configuration public class RestClientConfig extends AbstractElasticsearchConfiguration { @Value(\"${elasticsearch.host}\") private String host; @Override @Bean public RestHighLevelClient elasticsearchClient() { final ClientConfiguration clientConfiguration = ClientConfiguration.builder() .connectedTo(host).build(); return RestClients.create(clientConfiguration).rest(); } } # ES主机端口elasticsearch:host:127.0.0.1:9200","date":"2022-04-28","objectID":"/springboot%E6%95%B4%E5%90%88es/:0:2","tags":["ElasticSearch"],"title":"SpringBoot整合ES","uri":"/springboot%E6%95%B4%E5%90%88es/"},{"categories":["搜索引擎"],"content":"3. 客户端对象 ElasticsearchOperations RestHighLevelClient (推荐) 1. ElasticsearchOperations 特点: 始终使用面向对象方式操作ES 相关注解: @Data @Document(indexName = \"product\",createIndex = true) public class Product { @Id private String id; @Field(type = FieldType.Keyword) private String title; @Field(type = FieldType.Double) private Double price; @Field(type = FieldType.Text) private String description; } 创建doc @Test public void testIndex(){ Product product = new Product(); product.setId(UUID.randomUUID().toString().replaceAll(\"-\",\"\")); product.setTitle(\"商品一号\"); product.setPrice(100.0); product.setDescription(\"我是一个100元的商品!!!!\"); elasticsearchOperations.save(product); } 查询单个doc @Test public void testSearch(){ Product product = elasticsearchOperations.get(\"c9c312e6196746ad8c9c9e5060f36ea8\", Product.class); System.out.println(product); } 删除doc @Test public void testDelete(){ elasticsearchOperations.delete(\"c9c312e6196746ad8c9c9e5060f36ea8\",Product.class); } ","date":"2022-04-28","objectID":"/springboot%E6%95%B4%E5%90%88es/:0:3","tags":["ElasticSearch"],"title":"SpringBoot整合ES","uri":"/springboot%E6%95%B4%E5%90%88es/"},{"categories":["搜索引擎"],"content":"1. 什么是ElasticSearch ElasticSearch简称es,是一个开源的分布式全文检索引擎,他可以近乎实时的存储,检索数据;本身拓展性很好,可以拓展到上百台服务器,处理PB级别的数据.es也使用java开发并使用lucene作为核心来实现所有的所有和搜索的功能,但是他的目的是通过简单的Restful API来隐藏Lucene的复杂性,从而让全文搜索变的简单. ","date":"2022-04-27","objectID":"/elasticsearch%E5%AD%A6%E4%B9%A0/:0:1","tags":["ElasticSearch"],"title":"ElasticSearch学习","uri":"/elasticsearch%E5%AD%A6%E4%B9%A0/"},{"categories":["搜索引擎"],"content":"2. ElasticSearch概念 2.1 概述 ElasticSearch是面向文档(document oriented)的,这意味着他可以存储整个对象或文档.然而他不仅是存储,还会索引(index)每个文档的内容使之可以被搜索.在ElasticSearch中,你可以对文档(而非成行成列的数据)进行索引,搜索,排序,过滤.与关系型数据库对比如下: Relational DB -\u003e Databases -\u003e Tables - \u003e Rows -\u003e COlumns ElasticSearch - \u003e Indices -\u003e Types -\u003e Documents -\u003e Fields 2.2 索引-index 一个索引就是一个拥有积分相似特征的文档的集合.比如说,你可以有一个客户数据的索引,另一个产品目录的索引,还有一个订单数据的索引.一个索引由一个名字来标识(必须全部是小写字母的),并且当我们要对对应于这个索引中的文档进行索引,搜索,更新和删除的时候,都要使用到这个名字.在一个集群中,可以定义人一多的索引. 2.3 类型-type 在一个索引中,你可以定义一种或多种类型,一个类型是你的索引的一个逻辑上的分类/分区,其寓意完全由你来定.通常,会为具有一组共同字段的的文档定义一个类型.比如,我们假设你运营一个博客并且将你所有的数据存储到一个索引中.在这个索引中,你可以为用户数据定义一个类型,为博客数据定义另一个类型,当然,也可以为评论数据定义另一个类型. 2.4 字段-Field 相当于是数据表的字段.对文档数据根据不同属性进行的分类标识 2.5 映射-mapping mapping是处理数据的方式和规则方面做一些限制,如某个字段的数据类型,默认值,分析器,是否被索引等,这些都是映射里面可以设置的,其他就是处理es里面的数据一些使用葛泽设置也叫做映射.俺这最优规则处理数据对性能提升很大. 2.6 文档-doucument 一个文档是一个可被索引的基础信息单元,在一个index/type里面,你可以存储人一多的文档.注意,尽管一个文档,物理上存在于一个索引之中,文档必须被索引/赋予一个索引的type. 2.7 接近实时-NRT es是一个接近实时的搜索平台.这意味着,从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟. ","date":"2022-04-27","objectID":"/elasticsearch%E5%AD%A6%E4%B9%A0/:0:2","tags":["ElasticSearch"],"title":"ElasticSearch学习","uri":"/elasticsearch%E5%AD%A6%E4%B9%A0/"},{"categories":["搜索引擎"],"content":"3. 索引操作 3.1 创建索引 postman发送put请求 127.0.0.1:9200/shopping 3.2 查看索引 postman发送get请求 127.0.0.1:9200/shopping 查看所有索引: 127.0.0.1:9200/_cat/indices?v ","date":"2022-04-27","objectID":"/elasticsearch%E5%AD%A6%E4%B9%A0/:0:3","tags":["ElasticSearch"],"title":"ElasticSearch学习","uri":"/elasticsearch%E5%AD%A6%E4%B9%A0/"},{"categories":["搜索引擎"],"content":"4. 文档操作 4.1 创建文档 postman发送post请求 127.0.0.1:9200/shopping/_doc { \"title\":\"小米手机\", \"category\":\"手机\", \"price\":4999 } 4.2 查询文档 根据主键查询: 127.0.0.1:9200/shoping/_doc/id 查询所有文档数据: 127.0.0.1:9200/shoping/_search 4.3 修改文档数据 全量数据更新: 127.0.0.1:9200/shoping/_doc/id (put请求) { \"title\":\"小米手机\", \"category\":\"手机\", \"price\":1999 } 局部更新: 127.0.0.1:9200/shoping/_update/id (post请求) { \"doc\":{ \"title\":\"苹果手机\" } } 4.4 删除文档数据 127.0.0.1:9200/shoping/_doc/id (delete请求) ","date":"2022-04-27","objectID":"/elasticsearch%E5%AD%A6%E4%B9%A0/:0:4","tags":["ElasticSearch"],"title":"ElasticSearch学习","uri":"/elasticsearch%E5%AD%A6%E4%B9%A0/"},{"categories":["搜索引擎"],"content":"5. 查询文档数据 5.1 条件查询 127.0.0.1:9200/shoping/_search (get请求) 条件: { \"query\":{ \"match\":{ //match_all 所有 \"category\":\"手机\" } } } 结果: 5.2 分页查询 条件: { \"query\":{ \"match\":{ //match_all 所有 \"category\":\"手机\" } }, \"from\":0 \"size\":1 } 结果: 5.3 查询指定字段 条件: { \"query\":{ \"match\":{ \"category\":\"手机\" } }, \"from\":0, \"size\":1, \"_source\":[\"title\"] } 结果: 5.4 查询排序 条件: { \"query\":{ \"match\":{ \"category\":\"手机\" } }, \"_source\":[\"title\",\"price\"], \"sort\":{ \"price\":{ \"order\":\"desc\" } } } 结果: 5.5 多条件查询 条件: { \"query\":{ \"bool\":{ \"must\":[ { \"match\":{ \"category\":\"手机\" } }, { \"match\":{ \"price\":1999 } } ] } } } 结果: 5.6 范围查询 条件: { \"query\":{ \"bool\":{ \"must\":[ { \"match\":{ \"category\":\"手机\" } } ], \"filter\":{ \"range\":{ \"price\":{ \"gt\":3000 } } } } } } 结果: 5.7 完全匹配 条件: { \"query\":{ \"match_phrase\":{ \"title\":\"苹果手机\" } } } 结果: 5.8 高亮显示 条件: { \"query\":{ \"match_phrase\":{ \"title\":\"苹果手机\" } }, \"highlight\":{ \"fields\":{ \"title\":{} } } } 结果: 5.9 聚合查询 分组: 条件: { \"aggs\":{ //聚合操作 \"price_group\":{ //随意起名 \"terms\":{ //分组 \"field\":\"price\" //分组字段 } } } } 结果: (无原始数据)条件: { \"aggs\":{ //聚合操作 \"price_group\":{ //随意起名 \"terms\":{ //分组 \"field\":\"price\" //分组字段 } } }, \"size\":0 } 结果: 平均值: 条件: { \"aggs\":{ //聚合操作 \"price_avg\":{ //随意起名 \"avg\":{ //分组 \"field\":\"price\" //分组字段 } } }, \"size\":0 } 结果: ","date":"2022-04-27","objectID":"/elasticsearch%E5%AD%A6%E4%B9%A0/:0:5","tags":["ElasticSearch"],"title":"ElasticSearch学习","uri":"/elasticsearch%E5%AD%A6%E4%B9%A0/"},{"categories":["搜索引擎"],"content":"6. 映射关系 6.1 创建mapping 创建index: user 创建mapping: 127.0.0.1:9200/user/_mapping (put请求) 条件: { \"properties\":{ \"name\":{ \"type\":\"text\", \"index\":true }, \"sex\":{ \"type\":\"keyword\", \"index\":true }, \"age\":{ \"type\":\"keyword\", \"index\":false } } } 6.2 查看mapping 127.0.0.1:9200/user/_mapping (get请求) ","date":"2022-04-27","objectID":"/elasticsearch%E5%AD%A6%E4%B9%A0/:0:6","tags":["ElasticSearch"],"title":"ElasticSearch学习","uri":"/elasticsearch%E5%AD%A6%E4%B9%A0/"},{"categories":["面试"],"content":"1. JavaSE StringBuffer,StringBuilder区别? 两者都是可变的字符串对象,有共同的父类AbstractStringBuilder,并且两个类的构造方法和成员方法也基本相同,不同的是,StringBuffer是线程安全的,而StringBUilder是非线程安全的,所以StringBuilder性能略高 ","date":"2022-04-06","objectID":"/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/:0:1","tags":["面试题"],"title":"面试题目整理","uri":"/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"},{"categories":["面试"],"content":"2. Spring Spring是什么? 轻量级开源JavaEE框架,它是一个容器框架,用来装javabean,中间层框架可以起一个连接作用,可以让我们企业开发更快速,更简洁. Spring中比较核心的是IOC(控制反转)和AOP(面向切面编程) IOC可以帮助我们维护对象与对象之间的依赖关系,降低了对象之间的耦合度,DI是依赖注入的意思,他是IOC实现的方式,指应用运行过程中,对象之间的关系不再需要对象的使用者来维护,而是被IOC容器进行管理注入 AOP是面向切面编程,是对OOP的补充,可以同一解决一批组件的共性需求(如权限检查,记录日志,事务管理等).我们可以将解决共性需求的代码独立出来,通过配置的方式,声明这些代码在什么地方,什么时机调用.满足调用条件,AOP会将业务代码织入到我们指定的位置,从而同一解决问题,不需要修改这一批组件的代码 BeanFactory和ApplicationContext有什么区别? ApplicationContext是BeanFacotry的子接口 ApplicationContext提供更完整的功能: 继承MessageSource,支持国际化 同一的资源文件访问方式 提供在监听器中注册bean的事件 同时加载多个配置文件 BeanFactory采用延迟加载形式来注入Bean的,即只有使用某个Bean时,才对该Bean进行加载实例化.如果Bean的某一个属性没有注入,BeanFactory加载后,知道第一次使用这个Bean才会抛出异常 ApplicationContext是在容器启动时,一次性创建所有的bean,在启动时就可以发现spring中存在的配置问题,这样有利于检查所依赖属性是否注入. 两者都都支持BeanPostProcessor,BeanFactoryPostProcessor的使用,但两者的区别是:BeanFactory需要手动注册,而ApplicationContext则是自动注册 SpringBean的生命周期? Spring中的bean的生命主要包含四个阶段:实例化Bean-\u003eBean属性填充-\u003e初始化Bean-\u003e销毁Bean 首先是实例化Bean,当客户端想容器请求一个尚未初始化的bean时,或初始化bean的时候需要注入另一个尚未初始化的bean的依赖时,容器就会调用doCreatebean()方法进行实例化,实际上就是通过反射的方式创建出一个bean对象 Bean实例创建出来后,接着就是给这个bean对象进行属性填充,也就是注入这个bean依赖的其他bean对象 属性填充完成后,进行初始化Bean操作,初始化阶段可以分为几个步骤 执行Aware接口的方法 Spring会检测该对象是否实现了xxxAware接口,通过Aware类型的接口,可以让我们拿到Spring容器的一些资源.如实现BeanNameAware接口可以获取到BeanName,实现BeanFactoryAware接口可以获取工厂对象BeanFactory等等 执行BeanPostProcessor的前置处理方法PostProcessbeforeInitiaization(),对bean进行一些自定义的前置处理 判断bean是否实现了initializingBean接口,如果实现了,将会执行initializingBean的afterPropertiesSet()初始化方法 执行用户自定义的初始化方法,如init-method等 执行BeanPostProcessor的后置处理方法postProcessAfterInitialization() 初始化完成后,Bean就成功创建了,之后就可以使用这个bean,当bean不在需要时,会进行销毁操作 首先判断bean是否实现了DestructionAwarebeanPostProcessor接口,如果实现了,则会执行DestructionAwareBeanPostProcessor后置处理器的销毁回调方法 其次会判断Bean是否实现了DisposableBean接口,如果实现了将会调用其实现destroy方法 最后判断这个bean是否配置了destroy-method等自定义的销毁方法,如果有的话,则会自动调用其配置的销毁方法 Spring的作用域? singleton: 默认,每个容器中只有一个bean的实例,单例的模式由BeanFactory自身来维护.该对象的生命周期与Spring IOC容器一致的(但在第一次被注入时才会创建) prototype: 为每个bean请求提供一个实例,在每次注入时都会创建一个新的对象 request: bean被定义每个HTTP请求中创建一个单例对象,也就是说在单个请求中都会复用这一个单例对象 session: 与request范围类似,确保每个session中都有一个bean的实例,在session过期后,bean会随之失效 application: bean被定义在ServletContext的生命周期中复用一个单例对象 websocket: bean被定义在websocket的生命周期中复用一个单例对象 SpringMVC的执行流程? DispatcherServlet接受请求,调用HandleMapping(处理器映射器) HandleMapping找到具体的处理器(可查找xml配置或注解配置),生成处理器对象及处理器拦截器(如果有),在一起返回给DispatcherServlet DispatcherServlet调用HandleAdapter(处理器适配器) HandleAdapter经过适配器调用具体的处理器(Handle/Controller),返回ModelAndView给DispatcherServlet DispatcherServlet调用ViewResolver(视图解析器),根据返回的ModelAndView中的逻辑视图名为DispatcherServlet返回一个可用的view实例 DispatcherServlet根据View渲染视图,响应给用户 Spring中的Bean是线程安全的么? Spring本省没有针对Bean做线程安全的处理 如果Bean是无状态的,那么Bean则是线程安全的,反之 另外,Bean是不是线程安全,跟Bean的作用于没有关系,Bean的作用于至少表示Bean的生命周期范围,对于任何声明周期的Bean都是一个对象,是不是线程安全还得看Bean本身 Spring中的事务是如何实现的? Spring事务底层是基于数据库事务和AOP机制 对使用了@Transactional注解的Bean,Spring会创建一个代理对象作为Bean 如果代理对象的方法加了注解,则利用事务管理器创建数据连接 修改数据库连接的autocommit为false,禁止此连接的自动提交 执行方法,方法会执行sql,没有异常就提交事务 Spring事务的隔离级别就是数据库的隔离级别 ","date":"2022-04-06","objectID":"/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/:0:2","tags":["面试题"],"title":"面试题目整理","uri":"/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"},{"categories":["面试"],"content":"3. MySQL 对MySQL索引的理解? 索引时单独的,存储在磁盘上的数据结构,包含对数据表中所有记录的引用指针.索引可以快速找到在某个或多个列有一特定值的行,所有MySQL列的类型都可以被索引. 索引时在存储引擎中实现的,因此,每种存储引擎的所有都不一定完全相同,并且每种存储引擎也不一定支持所有索引类型.MySQL中所有的存储类型有两种,即B+树和Hash,具体和表的存储引擎相关. 索引的优点? 通过创建唯一索引,可以保证数据库中的每一行数据的唯一性 加快数据的查询速度,降低数据库的IO成本,这也是创建索引的主要原因 使用分组和排序子句进行数据检索时,同样可以显著减少查询中分组和排序的时间 进行表连接操作时,索引加速表连接操作 索引的缺点? 占用一定的磁盘空间 在频繁插入,删除操作时,MySQL需要动态维护索引 索引有哪几种? 普通索引和唯一索引 普通索引时MySQL中的基本索引类型,允许在定义索引的列中插入重复值和空值 唯一索引要求索引列的值必须唯一,但允许有空值,如果是组合索引,则列值的组合必须唯一 主键索引时一种特殊的唯一索引,不允许有空值 单列索引和组合索引 单列索引即一个索引只包含单个列,一个表可以有多个单列索引 组合索引是指在表的多个字段组合上组件的索引,只有在查询条件中使用了这些字段的左边字段时,索引次啊会被使用,使用组合索引时遵循最左前缀法则 全文索引 全文索引类型为FULLTEXT,在定义一索引的列上支持值的全文查找,允许在这些索引列中插入重复值和空值.全文索引可以在CHAR,VARCHAR或者TEXT类型的列上创建 空间索引 空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MyISAM的表中创建。 如何避免索引失效? 使用组合索引,遵循\"最左前缀\"原则 不在索引列上做任何操作,例如计算,函数,类型转换,会导致索引失效而转向全表扫描 尽量使用覆盖索引(只访问索引列的查询),减少select * 覆盖索引能减少回表次数 在使用不等于(!=或者\u003c\u003e)的时候无法使用索引会导致全表扫描 LIKE以通配符开头(%abc),MySQL会失效变成全表扫描的操作 字符串不加单引号会导致索引失效(可能发生索引列的隐式转换) 少用or,用它来连接时会索引失效 不适合建索引的场合 频繁更新的字段 where条件中用不到的字段不适合建立索引 数据比较少的表不需要建索引 数据重复且分布比较均匀的字段不适合建索引,例如性别,真假值 参与列计算的列不是建索引 ","date":"2022-04-06","objectID":"/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/:0:3","tags":["面试题"],"title":"面试题目整理","uri":"/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/"},{"categories":["框架"],"content":"1.过滤器 security本质是一个过滤器链 FilterSecurityInterceptor:是一个方法级的权限过滤器,基本位于过滤器链的最底部; ExceptionTranslationFilter:是一个异常过滤器,用来处理在认证授权过程中抛出的异常; UserNamePasswordAuthenticationFilter:对/Login的post请求拦截,校验表单中用户名和密码; ","date":"2022-04-02","objectID":"/springsecurity/:0:1","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.web权限方案 1.认证 设置登录的用户名和密码 通过配置文件 server.port=5555 spring.security.user.name=root spring.security.user.password=123456 通过配置类 @Configuration public class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Autowired private PasswordEncoder passwordEncoder; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { String password = passwordEncoder.encode(\"123\"); auth.inMemoryAuthentication().withUser(\"root\").password(password).roles(\"admin\"); } } 自定义编写实现类 @Configuration public class SecurityConfigTest extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Bean PasswordEncoder passwordEncoder(){ return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder()); } } @Service(\"userDetailsService\") public class MyUserDetailService implements UserDetailsService { @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\"); return new User(\"root\",new BCryptPasswordEncoder().encode(\"123\"),role); } } 通过查询数据库校验 导入依赖 \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.4.3\u003c/version\u003e \u003c/dependency\u003e 构建实体类 @Data @NoArgsConstructor @AllArgsConstructor public class Users { private Integer id; private String name; private String pwd; } 整合mybatis-plus,继承BaseMapper @Repository public interface UserMapper extends BaseMapper\u003cUsers\u003e { } 在MyUserDetailService @Service(\"userDetailsService\") public class MyUserDetailService implements UserDetailsService { @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException { QueryWrapper\u003cUsers\u003e wrapper = new QueryWrapper\u003c\u003e(); wrapper.eq(\"name\",name); Users user = userMapper.selectOne(wrapper); if (user==null){ throw new UsernameNotFoundException(\"用户名不存在\"); } List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"role\"); return new User(user.getName(),new BCryptPasswordEncoder().encode(user.getPwd()),role); } } 自定义登录页面和权限 @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() //自定义自己编写的登录页面 .loginPage(\"/login.html\") //登录页面设置 .loginProcessingUrl(\"/user/login\") //登录访问路径 .defaultSuccessUrl(\"/test/index\").permitAll() //登录成功之后,跳转路劲 .and().authorizeRequests() .antMatchers(\"/\",\"/test/hello\",\"user/login\").permitAll() //设置安歇路径可以放行 .anyRequest().authenticated() .and().csrf().disable(); //关闭csrf防护 } 2.授权 基于角色或权限进行访问控制 第一个方法:hasAuthority():如果当前主体具有指定的权限,则返回true,否则返回false; 在配置类设置当前访问地址有哪些权限 .antMatchers(\"/test/index\").hasAnyAuthority(\"admin\") //当前登录用户只有admin才能访问这个路径 在UserDetailsService,把返回User对象设置权限 List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin\"); 第二个方法:hasAnyAuthority():如果当前的主体有任何提供的权限,则返回true,否则返回false; .antMatchers(\"/test/index\").hasAnyAuthority(\"admin\",\"manage\") 第三个方法:hasRole():给定角色进行访问 .antMatchers(\"/test/index\").hasRole(\"sale\") UserDetailService,把返回对象设置角色 List\u003cGrantedAuthority\u003e role = AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin,ROLE_sale\"); 第四个方法:hasAnyRole():具备任何一个角色就可以访问 3. 自定义403页面 http.exceptionHandling().accessDeniedPage(\"/unauth.html\"); \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e权限不够\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 4. 什么是CSRF ​ CSRF:跨站请求伪造;通过伪造用户请求访问受信任站点的非法请求; ​ 跨域: 只要网络协议,ip地址,端口中任何一个不同就是跨域请求; ​ 客户端与服务器进行交互时,由于协议本身是无状态协议,所以引入了cookie进行记录客户端身份;在cookie中会存放session id用来识别客户端身份;在跨域的情况下,seesion id可能被第三方恶意劫持,通过这个session id向服务器发起请","date":"2022-04-02","objectID":"/springsecurity/:0:2","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1. Oauth2简介 第三方认证技术方案最主要解决认证协议的通用标准问题,因为要实现跨系统认证,各系统之间要遵循一定的接口协议. Oauth协议为用户资源的授权提供了安全的,开放而简易的标准.同时任何第三方都可以使用Oauth认证服务,任何服务提供商都可以实现自身的Oauth认证服务,因而Oauth是开放的.业界提供了Oauth的多种实现如PHP,JavaScript,Java等各种语言的开发包. ","date":"2022-04-02","objectID":"/springsecurity/:1:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1.1 角色 客户端 本身不存储资源,需要通过资源拥有者的授权去请求资源服务器的资源. 资源拥有者 通常为用户,也可以是应用程序,即该资源的拥有者. 授权服务器(也称认证服务器) 用来对资源拥有的身份进行认证,对访问资源进行授权.客户端要访问资源需要通过认证服务器由资源拥有者授权后可访问. 资源服务器 存储资源的服务器,比如,网站用户管理服务器存储了网站的用户信息,网站相册服务器存储了用户的相册信息,微信的资源服务存储了微信的用户信息等.客户端最终访问资源服务器获取资源信息. ","date":"2022-04-02","objectID":"/springsecurity/:1:1","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1.2. 常用术语 客户凭证: 仅用于授权码授权类型,用于交换获取访问令牌和刷新令牌 访问令牌: 用于嗲表一个用户或服务器直接去访问受保护的资源 刷新令牌: 用于去授权服务器获取一个刷新访问令牌 BearerToken: 不管谁拿到Token都可以访问资源. Proof of Prssession Token: 可以校验client是否对Token有明确的拥有权. ","date":"2022-04-02","objectID":"/springsecurity/:1:2","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1.3. 特点 **优点: ** 更安全,客户端不需要接触用户密码,服务器端更易集中保护 广泛传播并被持续采用 短寿命和封装的token 资源服务器和授权服务器的解耦 集中式授权,简化客户端 HTTP/JSON友好,易于请求和传递token 考虑多种客户端架构场景 客户可以具有不同的信任级别 缺点 协议框架太宽泛,造成各种实现的兼容性和互操作性差 不是一个认证协议,本身并不能告诉你任何用户信息 ","date":"2022-04-02","objectID":"/springsecurity/:1:3","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2. 授权模式 ","date":"2022-04-02","objectID":"/springsecurity/:2:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.1 授权码模式(Authorization Code) ","date":"2022-04-02","objectID":"/springsecurity/:2:1","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.2 简化授权模式 ","date":"2022-04-02","objectID":"/springsecurity/:2:2","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.3 密码模式 ","date":"2022-04-02","objectID":"/springsecurity/:2:3","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.4 客户端模式 ","date":"2022-04-02","objectID":"/springsecurity/:2:4","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.5 刷新令牌 Spring Security Oauth2 ","date":"2022-04-02","objectID":"/springsecurity/:2:5","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1.1 授权服务器 Authorize Endpoint: 授权端点,进行授权 Token Endpoint: 令牌端点,经过授权拿到对应的Token Introspection Endpoint: 校验端点,校验Token的合法性 Revocation Endpoint: 撤销端点,撤销授权 ","date":"2022-04-02","objectID":"/springsecurity/:3:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1.2 流程 用户访问,此时没有token.Oauth2RestTemplate会报错.这个报错信息会被Oauth2ClientContextFilter捕获并重新定向到认证服务器 认证服务器通过Authorization Endpoint进行授权,并通过AuthorizationServerTokenServices生成授权码并返回给客户端 客户端拿到授权码去认证服务器通过Token Endpoint调用AuthorizationServerTokenServices生成Token并返回给客户端 客户端拿到Token去资源服务器访问资源,一般会通过Oauth2AuthenticationManager调用ResourcesServerTokenServices进行校验.校验通过可以获取资源 JWT ","date":"2022-04-02","objectID":"/springsecurity/:4:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1. 简介 ","date":"2022-04-02","objectID":"/springsecurity/:5:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1.1 什么是JWT JSON Web Token(JWT) 是一个开放的行业标准,他定义了一种简介的,自包含的协议格式,用于在通信双方传递json对象,传递的信息经过数字签名可以被验证和信任.JWT可以使用HMAC算法或使用RSA的公钥/私钥来签名,防止被篡改. JWT令牌的优点: JWT基于json,非常方便解析. 可以在令牌中自定义丰富的内容,易拓展. 通过非对称加密算法及签名技术,JWT防止篡改,安全性高. 资源服务使用JWT可不依赖认证服务即可完成授权. 缺点: JWT令牌较长,占存储空间比较大. ","date":"2022-04-02","objectID":"/springsecurity/:5:1","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"1.2 JWT组成 一个JWT实际上就是一个字符串,它由三部分组成,头部,负载与签名. 1.2.1 头部(header) 头部用于描述关于该JWT的最基本的信息,例如其类型以及签名使用的算法等.这也可以被表示成一个JSON对象. { \"alg\": \"HS256\" \"typ\": \"JWT\" } typ: 是类型 alg: 签名的算法,这里使用的算法是HS256算法 1.2.2 负载(Payload) 第二部分师傅在,就是存放有效信息的地方.这个名字像是特指飞机上承载的货品,这些有效信息包含三个部分: 标准中注册的声明(建议但不强制使用) iss: jwt签发者 sub: jwt所面向的用户 aud: 接受jwt的一方 exp: jwt的过期时间,这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前,该jwt都是不可用的 iat: jwt的签发时间 jti: jwt的唯一身份标识,主要用来作为一次性token,从而回避重放攻击. 公共的声明 公共的声明可以添加任何的信息,一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息,因为该部分在客户端可解密 私有的声明 私有的声明是提供者和消费者所共同定义的声明,一般不建议存放敏感信息,因为base64是对称解密的,意味着该部分信息可以归类为明文信息. 这个指的就是自定义的claim.比如下面这个举例中的name都属于自定义的claim.这些claim跟jwt标准规定的claim区别在于: jwt规定的claim.jwt的结合搜放在拿到jwt之后,都知道怎么对这些标准的claim进行验证;而private claim不会验证,除非明确告诉接收方要对这些claim进行验证以及规则才行. { \"sub\": \"1234567890\" \"name\": \"John Doe\" \"iat\": 1516239022 } 其中sub是标准的声明,name是自定义的声明(公共的或私有的) 然后将其进行base64编码,得到jwt的第二部分 提示: 声明中不要放一些敏感信息 1.2.3 签名,签名(signature) jwt的第三部分是一个签证信息,这个签证信息由三部分组成: header(base64后的) payload(base64后的) secret(盐) 这个部分需要base64加密后的header和base64加密后的payload使用,连接组成的字符串啊,然后通过header中的声明的加密方式进行加盐secret组合加密,然后就构成jwt的第三部分; 将这三部分用.连接成一个完整的字符串,构成了最终的jwt; 注意: secret是保存在服务器端的,jwt的签发生成也是在服务器端的,secret就是用来进行jwt的签发和jwt的验证,所以,他就是你服务器端的私钥,在任何场景都不应该流露出去.一旦客户端得知这个secret,那就意味着客户端是可以自我签发jwt了 ","date":"2022-04-02","objectID":"/springsecurity/:5:2","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2. JJWT简介 ","date":"2022-04-02","objectID":"/springsecurity/:6:0","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.1 什么事JJWT JJWT是一个提供端到端的JWT创建和验证的java库.永远免费和开源,JJWT很容易使用和理解.他被设计成一个以建筑为中心的流畅界面,隐藏了他的大部分复杂性; ","date":"2022-04-02","objectID":"/springsecurity/:6:1","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.2 token创建 导入依赖 \u003cdependency\u003e \u003cgroupId\u003eio.jsonwebtoken\u003c/groupId\u003e \u003cartifactId\u003ejjwt\u003c/artifactId\u003e \u003cversion\u003e0.9.1\u003c/version\u003e \u003c/dependency\u003e public void jwtBuilderTest() { JwtBuilder builder = Jwts.builder() //设置id {\"jtl\":\"555\"} .setId(\"555\") //签发用户 .setSubject(\"CodeSniper\") //签发时间 .setIssuedAt(new Date()) .signWith(SignatureAlgorithm.HS256,\"xxxx\"); //生成token String token = builder.compact(); System.out.println(token); String[] split = token.split(\"\\\\.\"); //头部 System.out.println(Base64Codec.BASE64.decodeToString(split[0])); //负载 System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //签名,乱码 System.out.println(Base64Codec.BASE64.decodeToString(split[2])); } ","date":"2022-04-02","objectID":"/springsecurity/:6:2","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.3 解析token public void parseToken(){ String token=\"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI1NTUiLCJzdWIiOiJDb2RlU25pcGVyIiwiaWF0IjoxNjMwMjE1NTkxfQ.Ztnwgh8USc1iEPez7RmHGcrH_6RLFKE60TKAzM1wOTw\"; //获取claims(荷载) Claims claims = Jwts.parser() .setSigningKey(\"xxxx\") .parseClaimsJws(token) .getBody(); System.out.println(\"jti:\"+claims.getId()); System.out.println(\"sub:\"+claims.getSubject()); System.out.println(\"iat:\"+claims.getIssuedAt()); ","date":"2022-04-02","objectID":"/springsecurity/:6:3","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.4 token过期校验 //创建token (过期时间) @Test public void jwtBuilderTestHasExp() { long now = System.currentTimeMillis(); long exp = now + 60 * 1000; JwtBuilder builder = Jwts.builder() //设置id {\"jtl\":\"555\"} .setId(\"555\") //签发用户 .setSubject(\"CodeSniper\") //签发时间 .setIssuedAt(new Date()) .signWith(SignatureAlgorithm.HS256, \"xxxx\") .setExpiration(new Date(exp)); //生成token String token = builder.compact(); System.out.println(token); String[] split = token.split(\"\\\\.\"); //头部 System.out.println(Base64Codec.BASE64.decodeToString(split[0])); //负载 System.out.println(Base64Codec.BASE64.decodeToString(split[1])); //签名,乱码 System.out.println(Base64Codec.BASE64.decodeToString(split[2])); } //解析token(过期时间) @Test public void parseTokenHasExp() { String token = \"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiI1NTUiLCJzdWIiOiJDb2RlU25pcGVyIiwiaWF0IjoxNjMwMjE1NTkxfQ.Ztnwgh8USc1iEPez7RmHGcrH_6RLFKE60TKAzM1wOTw\"; //获取claims(荷载) Claims claims = Jwts.parser() .setSigningKey(\"xxxx\") .parseClaimsJws(token) .getBody(); System.out.println(\"jti:\" + claims.getId()); System.out.println(\"sub:\" + claims.getSubject()); System.out.println(\"iat:\" + claims.getIssuedAt()); System.out.println(\"当前时间\"+new Date()); SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); System.out.println(\"过期时间\"+format.format(claims.getExpiration())); } ","date":"2022-04-02","objectID":"/springsecurity/:6:4","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["框架"],"content":"2.4 自定义声明 参数是map .claim(\"logo\",\"xxx.jpg\") 获取 claims.get(\"logo\") ","date":"2022-04-02","objectID":"/springsecurity/:6:5","tags":["SpringSecurity"],"title":"SpringSecurity","uri":"/springsecurity/"},{"categories":["数据库"],"content":"1. 锁的分类 共享锁 Share Lock (简称S锁,属于行锁) 排它锁 Exclusive Locks (简称X锁,属于行锁) 意向共享锁 Intention Shared Locks (简称IS锁,属于表锁) 意向排他锁 Intention Exclusive Locks (简称IX锁,属于表锁) 自增锁 AUTO-INC Locks ","date":"2022-04-02","objectID":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/:0:1","tags":["MySQL","锁"],"title":"MySQL锁机制","uri":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/"},{"categories":["数据库"],"content":"2. 共享锁 共享锁就是多个事务对同一数据可以共享一把锁,都能访问到数据库,但是只能读不能修改 事务A: select * from student where id = 1 lock in share mode; 事务B: select * from student where id = 1 (读数据没有问题) 事务B: update student set name = “haha” where id = 1 注意: 无法修改会卡死,当事务A提交事务之后,会立刻修改成功 ","date":"2022-04-02","objectID":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/:0:2","tags":["MySQL","锁"],"title":"MySQL锁机制","uri":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/"},{"categories":["数据库"],"content":"3. 排它锁 排它锁不能与其他锁并存,如一个事务获取了一个数据行的排它锁,其他事务就不能再获取该行的锁,只有当前获取了排它锁的事务可以对数据进行读取和修改 delete,update,insert默认是排它锁 事务A: select * from student where id = 1 for update; 事务B: select * from student where id = 1 for update; ​ select * from student where id = 1 lock in share mode; 注意: 事务B操作的时候会卡死,提交事务立马成功 ","date":"2022-04-02","objectID":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/:0:3","tags":["MySQL","锁"],"title":"MySQL锁机制","uri":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/"},{"categories":["数据库"],"content":"4. 意向共享锁 意向共享锁: 表示事务准备给数据行加入共享锁,也就是说给一个数据行在加共享锁之前必须先获得该表的IS锁 意向排它锁: 表示事务准备给数据行加入排它锁,也就是说一个数据行加排它锁之前必须取得该表的IX锁 意向锁是InnoDB数据操作之前自动加的,不需要用户干预 ","date":"2022-04-02","objectID":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/:0:4","tags":["MySQL","锁"],"title":"MySQL锁机制","uri":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/"},{"categories":["数据库"],"content":"5. 自增锁 针对自增列自增张的一个特殊的表级别锁 SHOWVARIABLESLIKE'innodb_autoinc_lock_mod;de ","date":"2022-04-02","objectID":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/:0:5","tags":["MySQL","锁"],"title":"MySQL锁机制","uri":"/mysql%E9%94%81%E6%9C%BA%E5%88%B6/"},{"categories":["框架"],"content":"1. 抛出检查异常导致事务不能正确回滚 **原因: **Srping默认只会回滚非检查异常 解法: 配置rollbackFor属性 ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:1","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":"2. 业务方法内自己try-catch异常导致事务不能正确回滚 原因: 事务通知只有捕捉到了目标抛出的异常,才能进行后续的回滚处理,如果目标自己处理异常,事务通知无法获悉 解法: 1. 异常原样抛出; 2. 手动设置TransactionStatus.setRollbackOnly(); ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:2","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":"3. aop切面顺序导致事务不能正确回滚 原因: 事务切面优先级最低,但如果自定义的切面优先级和他一样,则还是自定义切面在内层,这时若自定义切面没有抛出异常 解法: 同情况2 ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:3","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":"4. 非public方法导致的事务失效 原因: Spring为方法创建代理,添加事务通知,前提条件都是该方法是public 解法: 改为public方法 ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:4","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":"5. 父子容器导致的事务失效 原因: 子容器扫描范围过大,把未加事务配置的service扫描进来 解法: 1. 各扫描各的,不要图简便; 2. 不要用父子容器,所有bean放在同一容器 ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:5","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":"6. 调用本类方法导致传播行为失效 原因: 奔雷方法调用不经过代理,因此无法增强 **解法: **1. 依赖注入自己(代理)来调用; 2. 通过AopContext拿到代理对象,来调用; 3. 通过CTW,LTW实现功能增强 ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:6","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":"7. @Transactional没有保证原子行为 原因: 事务的原子性仅涵盖insert,update,delete,select.. for update语句,select方法并不阻塞 ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:7","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":"8. @Transactional方法导致synchronized失效 原因: synchronized保证的仅是目标方法的原子性,环绕目标方法的还有commit等操作,他们并未处于synchronized块内 解法: 1. synchronized范围应扩大至代理方法调用; 2. 使用select..for update替换select ","date":"2022-03-27","objectID":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/:0:8","tags":["Spring","事务"],"title":"Spring事务失效情况","uri":"/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5/"},{"categories":["框架"],"content":" 阶段一: 处理名称,检查缓存 阶段二: 检查父工厂 阶段三: 检查DependsOn 阶段四: 按Scope创建bean 创建singleton 创建prototype 创建其他scope 阶段五: 创建bean 创建bean实例 依赖注入 初始化 登记可销毁bean 阶段六: 类型转换 阶段七: 销毁bean ","date":"2022-03-27","objectID":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:0:0","tags":["Spring"],"title":"SpringBean的生命周期","uri":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["框架"],"content":"阶段一: 处理名称,检查缓存 先把别名解析为实际名称,再进行后续处理 若要FactoryBean本身,需要使用\u0026名称获取 singletonObjects是一级缓存,放单例成品对象 singletonFactories是三级缓存,放单例工厂 earlySingletonObjects是耳机缓存,放单例工厂的产品,可成为提前单例对象 ","date":"2022-03-27","objectID":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:0:1","tags":["Spring"],"title":"SpringBean的生命周期","uri":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["框架"],"content":"阶段二: 处理父子容器 ","date":"2022-03-27","objectID":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:0:2","tags":["Spring"],"title":"SpringBean的生命周期","uri":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["框架"],"content":"阶段三: ","date":"2022-03-27","objectID":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:0:3","tags":["Spring"],"title":"SpringBean的生命周期","uri":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["框架"],"content":"阶段四: 按Scope创建bean scope理解为从xxx范围内找到bean更加贴切 singleton scope表示从单例池范围获取bean,如果没有,则创建并放入单例池 prototype scope表示从不缓存bean,每次都创建新的 request scope表示从request对象范围内获取bean,如果没有,则创建并放入request ","date":"2022-03-27","objectID":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:0:4","tags":["Spring"],"title":"SpringBean的生命周期","uri":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["框架"],"content":"阶段五: 创建bean 1. 创建bean实例 FactoryMethod方式创建bean实例 分成静态工厂与实例工厂 工厂方法若有参数,需要对工厂方法参数进行解析,利用resolveDependency 如果有多个工厂方法候选者,还要进一步按权重筛选 AutowiredAnnotationBeanPostProcessor 优先选择带@Autowired注解的构造 若有唯一的带参构造,也会入选 才有默认构造 如果上面的后处理器和BeanDefiniation都没找到构造,采用默认构造,即使是私有的 2. 依赖注入 AutowireAnnotationBeanPostProcessor(注解匹配) 识别@Autowired及@Value标注的成员,封装为InjectionMetadata进行依赖注入 CommonAnnotationBeanPostProcessor(注解匹配) 识别@Resource标注的成员,封装为InjectionMetadata进行依赖注入 AUTOWIRE_BY_NAME(根据名字匹配) 根据成员名字找bean对象,修改mbd的propertyValues,不会考虑简单类型的成员 AUTOWIRE_BY_TYPE(根据类型匹配) 根据成员类型执行resolveDependency找到依赖注入的值,修改mbd的propertyValues applyPropertyValues(xml中\u003cproperty name ref|value/\u003e) 根据mbd的propertyValues进行依赖注入 ","date":"2022-03-27","objectID":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/:0:5","tags":["Spring"],"title":"SpringBean的生命周期","uri":"/springbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"categories":["Spring"],"content":"AOP是什么 AOP(Aspect Oriented Programming),意味面向切面编程,可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态同一添加功能的一种技术. AOP的编程思想就是把很多类对象的横切问题点,从业务逻辑中分离出来,从而达到解耦的目的,增加代码的重用性,提高开发效率 ","date":"2022-03-16","objectID":"/aop/:0:1","tags":["aop"],"title":"Aop","uri":"/aop/"},{"categories":["Spring"],"content":"AOP应用场景 日志记录 异常处理 权限验证 缓存处理 事务处理 数据持久化 效率检查 内容分发 ","date":"2022-03-16","objectID":"/aop/:0:2","tags":["aop"],"title":"Aop","uri":"/aop/"},{"categories":["Spring"],"content":"Aspect概念 aspect:切面,切面有切点和通知组成,即包括横切逻辑的定义也包括连接点的定义 pointcut: 切点,每个类都拥有多个连接点,可以理解是连接点的集合 joinpoint: 连接点,程序执行的某个特定位置,如某个方法调用前后等 weaving: 织入,将增强添加到目标类的具体连接点的过程 advice: 通知,是织入到目标类连接点上的一段代码,就是增强到什么地方?增强什么内容? target: 目标对象,通知织入的目标类 aop Proxy: 代理对象,即增强后产生的对象 Spring AOP底层实现,是通过JDK动态代理或CGlib代理在运行时期在对象初始化阶段织入代码的 Before advice 前置通知,即在目标方法调用之前执行.注意: 无论方法是否遇到异常都执行 After returning advice 后置通知,在目标方法执行后执行,前提是目标方法没有遇到异常,如果有异常则不执行通知 After throwing advice 异常通知,在目标方法抛出异常时执行,可以获取异常信息 After finally advice 最终通知,在目标方法执行后执行,无论是否是异常执行 Around advice 环绕通知,最强大的通知类型,可以控制目标方法的执行(通过调用ProceedingJoinPoint.proceed()),可以在目标执行全过程进行执行 @Aspect驱动 定义一个切面类Aspect 即在声明的类,增加@Component @Aspect两个注解,Springboot中引入Spring-boot-starter-aop依赖 定义切点Pointcut 定义切点,并定义切点在哪些地方执行,采用@pointcut注解完成,如@Pointcut(public * com.xxx.xxx..(..)) *规则:修饰符(可以不写,但不能用)+返回类型+哪些包下的类+那些方法+方法参数\"*“代表不限,”..“两个点代表参数不限 ** 定义Advice通知 利用通知的5中类型注解@Before,@After,@AfterReturning,@AfterThrowing,@Around来完成在某些切点的增强动作,如@Before(“myPointcut(),mypointcut为第二步骤定义的切点”) ","date":"2022-03-16","objectID":"/aop/:0:3","tags":["aop"],"title":"Aop","uri":"/aop/"},{"categories":["面试"],"content":"springmvc执行流程 数据参数在handler处理 mybatis 分页插件如何实现 动态sql如何写 方法和sql如何绑定 先namespace 线程 进程关系 线程的状态 6种 interipped notify all区别 线程安全 写 锁机制 new创建字符串 syn锁升级 反射可以获取私有信息吗 需要设置一下setaccess 自定义注解 多态的理解 封装 treeset如何去重 compareto 数组链表区别 序列化 反序列化 Spring如何为我们创建对象 动态代理 Springbean生命周期 init aware 对象作用域 threadlocal 私有化 线程隔离 底层机制 threallocalmap k v Spring 如何解决循环依赖 三级缓存 linux的常用 ps -ef 进程号 kill 全局找一个文件 find 动态查看日志 tail f 动态 n 末尾多少行 数据库隔离级别 读未提交 读以提交 可重复读 串行化 存储引擎 sql语句执行过程 先执行from hashmap循环链表 1.你怎么理解线程的优先级？ 2.线程之间是如何通信的？ 3.线程池怎么配置的？ 4、并发编程的三要素是什么？ 5、hashmap的底层原理？ 6、ArrayList和 LinkedList 的区别在哪里？ 7、我们常说spring全家桶，他包含哪些部分？ 8、能说一下基于XML配置方式的搭建SSM框架的步骤嘛？ 9、如果数据库表锁了，数据插入不了，怎么办？ 10、 mysql 的存储引擎有哪些，区别是什么 11、maven有哪些优缺点，如何解决jar包的冲突？ 12、能说一下常用的linux部署命令嘛？ concurrenthashmap synchronized锁 jvm内存模型 事务传播特性 循环依赖 spring bean生命周期 springmvc执行流程 gc ","date":"2022-03-10","objectID":"/%E9%9D%A2%E8%AF%95%E9%A2%98/:0:0","tags":["面试题"],"title":"面试题","uri":"/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["集合"],"content":"1. 两者对比 Hashtable与ConcurrentHashMap都是线程安全的Map集合 Hashtable并发度低,整个Hashtable对应一把锁,同一时刻,只能有一个线程操作它 1.8之前ConcurrentHashMap使用了Segment+数组+链表的结构,每个Segment对应一把锁,如果多个线程访问不同的Segment,则不会冲突 1.8开始ConcurrentHashMap将数组的每个头结点作为锁,如果多个线程访问的头结点不同,则不会冲突 ","date":"2022-03-08","objectID":"/hashtable%E5%92%8Cconcurrenthashmap/:0:1","tags":["ConcurrentHashMap","Hashtable"],"title":"Hashtable和ConcurrentHashMap","uri":"/hashtable%E5%92%8Cconcurrenthashmap/"},{"categories":["数据库"],"content":"1. 索引是什么? 索引时帮助MySQL高效获取数据的数据结构; 索引存储在文件系统中; 索引的文件存储形式与存储引擎有关; 索引文件的结构 hash 二叉树 B树 B+树 1. hash表的索引形式 缺点: 利用hash存储的话需要将所有数据文件添加到内存,比较耗费内存空间 如果所有的查询都是等值查询,那么hash确实很快,但是使用范围查找情况更多,因此hash就不太适合了 2. 二叉树的索引形式 缺点: 无论是二叉树还是红黑树,都会因为树的深度过深而造成io次数变多,影响数据读取效率 3. B树的索引形式 特点: 所有键值分布在整棵树上 搜索有可能在非叶子节点结束,在关键字全集内做一次查找,性能逼近二次查找 每个节点最多拥有m个子树 根节点至少有两个子树 分支节点至少拥有m/2棵子树(除根节点和叶子节点都是分支节点) 所有叶子节点都在同一层,每个节点最多可以又m-1个key,并且以升序排列 ","date":"2022-02-26","objectID":"/mysql%E7%B4%A2%E5%BC%95/:0:1","tags":["MySQL","索引"],"title":"MySQL索引","uri":"/mysql%E7%B4%A2%E5%BC%95/"},{"categories":["数据库"],"content":"2. 索引分类(InnoDB) 主键索引 设定为主键后数据库会自动建立索引,innodb为聚簇索引,主键索引索引列值不能有空 单值索引 单列索引 普通索引 即一个索引只包含单个列,一个表可以有单列索引 唯一索引 索引列的值必须唯一,但允许有空值 复合索引 一个索引包含多个列 全文索引(5.7之后) 全文索引类型为FULL TEXT,在定义索引的列上支持值的全文查找,允许在这些所偶遇列中插入重复值和空值,全文索引可以在CHAR,VARCHAR上创建 ","date":"2022-02-26","objectID":"/mysql%E7%B4%A2%E5%BC%95/:0:2","tags":["MySQL","索引"],"title":"MySQL索引","uri":"/mysql%E7%B4%A2%E5%BC%95/"},{"categories":["数据库"],"content":"3. 主键索引进行排序?为什么要排休 ","date":"2022-02-26","objectID":"/mysql%E7%B4%A2%E5%BC%95/:0:3","tags":["MySQL","索引"],"title":"MySQL索引","uri":"/mysql%E7%B4%A2%E5%BC%95/"},{"categories":["并发编程"],"content":"背景介绍：假设现在有一个线程共享的变量c=0，让两个线程分别对c进行c++操作100次，那么我们最后得到的结果是200吗？ **1.在线程不安全的方式下:**结果可能小于200，比如当前线程A取得c的值为3，然后线程A阻塞了，线程B取得的c的值也是3，然后线程B也阻塞了，现在线程A被唤醒执行了++操作使得c=4，结果写回c值内存，线程A执行结束，线程B被唤醒执行了++操作使得3++=4，也写回了c值内存，现在问题来了，两个线程分别进行了一次++操作，最后c值却为4而不是5，所以c值最后的结果肯定是小于200的，产生这种情况的原因就是线程不安全！，两个线程在同一时间读取了c值，然后又没有各种先执行完++操作而被阻塞（就是没有同步） **2.在线程安全的方式下:**比如++操作加上synchronized同步锁，结果一定是200，因为这样使得读取c值和++操作是一个原子性操作，不能被打断，所以线程是安全的，保证了同步 现在问题来了，我们要保证线程安全只有加synchorized同步锁这一种办法吗？synchorized同步锁又有什么缺点呢? 当然不仅只有synchorized这一种方法，还有原子操作类，关于原子操作类我们等下再说，先说说synchorized的缺点： syschorized缺点： synchorized的缺点关键在于性能！我们知道synchorized关键字会让没有得到锁资源的线程进入Blocked状态，而在得到锁的资源恢复为Runnable状态，这个过程涉及到操作系统用户模式和内核模式的切换，代价比较高！ 现在我们来说说原子操作类，顾名思义，就是保证某个操作的原子性，那它是怎么实现的呢？这个我们就要垃圾原子操作类的底层：CAS机制了 CAS机制的英文缩写是Compare and Swap，翻译一下就是比较和交换 CAS机制中使用3个基本操作数：内存地址V，旧的预期值A，要修改的新值B，更新一个变量的时候，只有当变量的旧的预期值A和内存地址V中的值相同的时候，才会将内存地址V中的值更新为新值B 下面举个栗子： 1）内存地址V中存放着值为10的变量 2）此时线程1要把变量值加1，对线程1来说，旧的预期值A=10，要修改的新值B=11 3）在线程1提交更新之前，另外一个线程2提前一步将内存地址V中的变量值率先更新成了11 4）线程1此时开始提交更新，首先进行A和内存地址V中的值比较，发现A不等于此时内存地址V中的值11，提交失败 5）线程1尝试重新获取内存地址V的当前值，并重新计算想要修改的值，对线程1来说，此时旧的预期值A=11，要修改的新值B=12，这个重新尝试的过程叫做自旋 6）这一次比较幸运，没有其他线程更改内存地址V中的值，线程1进行compare，发现A和内存地址V中的值相同 7）线程1进行Swap，把内存地址V中的值替换为B，也就是12 这个过程涉及到以下几个问题： 问题1：如何保证获取的当前值是内存中的最新值？（如果每次获得的当前值不是内存中的最新值，那么CAS机制将毫无意义） 用volatile关键字修饰变量，使得每次对变量的修改操作完成后一定会先写回内存，保证了每次获取到值都是内存中的最新值！ 问题2：如何保证Compare和Swap过程中的原子性（如果Compare和Swap过程不是原子性操作，那么CAS机制也毫无意义）？ Compare和Swap过程的原子性是通过unsafe类来实现的，unsafe类为我们提供了硬件级别的原子操作！ 总结一下：从思想上来说，Synchorized属于悲观锁，悲观的认为程序中的并发多，所以严防死守，CAS机制属于乐观锁，乐观的认为程序中并发少，让线程不断的去尝试更新 那么现在又有一个问题来了，CAS机制有什么缺点呢？ CAS机制的缺点： 1.CPU开销过大：在并发量比较高的情况下，如果许多线程反复尝试去更新一个变量，却又一直更新失败，循环往复，会消耗CPU很多资源 2.ABA问题：假设在内存中有一个值为A的变量储存在内存地址V当中，此时有三个线程使用CAS机制更新这个变量的值，每个线程的执行时间都略有偏差，线程1和线程2已经获取当前值，线程3还没有获取当前值。接下来线程1先一步执行成功，把当前值成功从A更新为B，同时线程2因为某种原因被阻塞，没有做更新操作，线程3在线程1更新成功之后获取了当前值B，再之后线程2仍然阻塞，线程3继续执行，成功将当前值更新为A，最后，线程2终于恢复了运行状态，由于线程2之前获取了“当前值A”并且经过了Compare检测，内存地址中的实际值也是A，所以线程2最后把变量A更新成了B，在这个过程中，线程2获取的当前值是一个旧值，尽管和当前值一模一样，但是内存地址中V中的变量已经经历了A-\u003eB-\u003eA的改变 表面看没有什么影响，但是如果实际中理由CAS机制从取款机上取钱，假如账户开始有100元，在取款机上取走50，取款机出现问题一共提交了两次请求（线程1，线程2），第二次请求（线程2）在执行时因为某种原因被阻塞了，这时候有人往你的账户打了50元，线程2恢复了可执行状态，这个时候就会出现问题，原本线程2应该执行失败的，但是比较后仍然与旧值一致，这样就造成了账户实际上扣款了两次！ ABA问题解决的方案：在Compare阶段不仅比较预期值和此时内存中的值，还比较两个比较变量的版本号是否一致，只有当版本号一致才进行后续操作，这样就完美的解决了ABA问题！ 3.不能保证代码块的原子性：CAS机制保证的是一个变量的原子性操作，若要保证多个变量的原子性操作，可以封装在一起，但是这样得不偿失，开销太大，还不如直接采用synchorized同步锁 ","date":"2022-02-24","objectID":"/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8Bcas%E6%93%8D%E4%BD%9C/:0:0","tags":["并发","多线程"],"title":"线程安全之CAS操作","uri":"/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B9%8Bcas%E6%93%8D%E4%BD%9C/"},{"categories":["数据库"],"content":"1. 存储引擎 1.1. 对比MyISAM和InnoDB 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁,即使操作一条记录也会锁住整个表,不适合高并发的操作 行锁,操作时只锁一行,不对其他行有影响,适合高并发的操作 缓存 只缓存索引,不缓存真实数据 不仅缓存索引还要缓存真实数据,对内存要求较高,而且内存大小对性能有决定性的影响 表空间 小 大 关注点 性能 事务 默认安装 Y Y 1.2. 阿里巴巴,淘宝用哪个? 产品 价格 目标 主要功能 是否可投入生产 PerCona Server 免费 提供XtraDB存储引擎的包装器和其他分析工具 XtraDB 是 MariaDB 免费 拓展MySQL以包含XtraDB和其他性能改进 XtraDB 是 Drizzle 免费 提供比MySQL更强大的可拓展性和性能改进 高可用性 是 Percona为MySQL数据库服务器进行了改进,在功能和性能上较MySQL有着很显著的提升.该版本提升了在高负载情况下的InnoDB的性能,为DBA提供一些非常有用的性能诊断工具;另外有很多的参数和命令来控制服务器行为. 该公司新建了一款存储引擎交XtraDB完全可以替代InnoDB,并且在性能和并发上做的很好. 阿里巴巴大部分MySQL数据库其实使用的PerCona的原型加以修改. AliSql+AliRedis ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:1","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["数据库"],"content":"2. 性能分析 2.1. 性能下降SQL慢,执行时间长,等待时间长 查询语句写的烂 索引失效-单值,复合 关联查询太多join(设计缺陷或不得已的需求) 服务器调优及各个参数设置(缓冲,线程数等) 2.2. 常见通用的join查询 SQL执行顺序 手写 SELECT -\u003e FROM -\u003e WHERE -\u003e GROUP BY -\u003e HAVING -\u003e ORDER BY -\u003e LIMIT 机读 FROM -\u003e ON -\u003e WHERE -\u003e GROUP BY -\u003e HAVING -\u003e SELECT -\u003e DISTINCT -\u003e ORDER BY -\u003e LIMIT 总结 JOIN图 ​ 2.3. 索引简介 是什么? MySQL官方对索引的定义为: 索引(Index)是帮助MySQL搞笑获取数据的数据结构.可以得到索引的本质: 索引是数据结构,索引的目的在于提高查询下效率,可以类比字典. 你可以简单理解为\"排好序的快速查找数据结构\" 详解: 在数据之外,数据库系统还维护这满足特定查找算法的数据结构,这些数据结构以某种方式引用数据,这样就可以在这些数据结构上实现高级查找算法.这种数据结构就是索引,下图就是一种可能的索引方式示例: 为了加快Col2的查找,可以维护一个右边所示的二叉查找树,每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针,这样就可以运用而查找树在一定的复杂度内获取到相应数据,从而快速的检索出复合条件的记录. 一般来说索引本身也很大,不可能全部存储在内存中,因此索引往往以索引文件的形式存户磁盘上. 我们平常所说的索引,如果没有特别指明,都是指B树(多路搜索树,并不一定是二叉的)结构组织的索引.其中聚集索引,次要索引,复合索引,前缀索引,唯一索引默认都是使用B+树索引,统称索引.当然,除了B+树这种类型的索引之外,还有哈希索引 优势 提高数据检索的效率,降低数据库的IO成本 通过索引列队数据进行排序,降低数据排序的成本,降低了CPU的消耗 劣势 实际上索引也是一张表,该表保存了主键与索引字段,并指向实体表的记录了,所以索引列也是要占用空间的 虽然索引大大提高了查询速度,同时却会降低更新表的速度,如对表进行INSERT,UIPDATE和DELETE.因为更新表时,MySQL不仅要保存数据,还要保存一下索引文件每次更新了索引列的字段,都会调整因为更新所带来的键值变化后的所有信息. MySQL索引分类 单值索引: 即一个索引只包含单个列,一个表可以有多个单列索引 唯一索引: 索引列的值必须唯一,但允许有空值 复合索引: 即一个索引包含多个列 MySQL索引结构 BTree索引 Hash索引 full-text全文索引 R-Tree索引 哪些情况需要创建索引 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段,外键关系建立索引 频繁更新的字段不适合不适合创建索引,因为每次更新不单单是更新了记录还会更新索引. where条件里用不到的字段不创建索引 单键/组合索引的选择问题,在高并发下倾向创建组合索引 查询中排序的字段,排序字段若通过索引去访问将大大提高排序素速度 查询在中统计或者分组字段 哪些情况不需要创建索引 表记录太少 经常增删改的表 数据重复且分布平均的表字段,因此应该只为最经常查询和最经常排序的数据列建立索引(如果某个数据列包含许多重复的内容,为他建立索引就没有太大的意义) ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:2","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["数据库"],"content":"3. 性能分析 3.1. MySQL Query Optimizer MySQL中有专门负责优化SELECT语句的优化器模块,主要功能: 通过计算分析系统中收集到的统计信息,为客户端请求的Query提供他任务最优的执行计划 当客户端想MySQL请求一条Query,命令解析器模块完成请求分类,区别出事SELECT并抓饭给MySQL Query Optimizer时,MySQL Query Optimizer首先会对整条Query进行优化,处理掉一些常量表达式的预算,之间换算成常量值,并对Query中的查询条件进行简化和转换,如去掉一些无用或显而易见的条件,结构调整等,然后分析Query中的Hint,看显示Hint信息是否可以完全确定该Query的执行计划.如果没有Hint或Hint信息还不足以完全确定执行计划,则会读取所涉及对象的统计信息,根据Query进行写响应的计算分析,然后再得出最后的执行计划. 3.2. MySQL的常见瓶颈 CUP: CUP在饱和的时候一般发生在数据装入内存或磁盘上读取数据时候 IO: 磁盘I/O瓶颈发生在装入数据远大于内存容量的时候 服务器硬件性能瓶颈; top,free,iostat和vmstat来查看系统的性能状态 ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:3","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["数据库"],"content":"4. 性能分析 索引失效 最佳左前缀法则 ​ 如果索引了多列,要遵守最左前缀法则,指的是查询从索引的最左前列开始并且不跳过索引中的列 不要在索引列上做任何操作(计算,函数,(自动或手动)类型转换),会导致索引失效而转向全表扫描 存储引擎不能使用索引中范围条件右边的列 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select * mysql在使用不等于(!=或者\u003c\u003e)的时候无法使用索引会导致全表扫描 is null ,is not null也无法使用索引 like以通配符开头('%abc'),mysql索引失效编程全表扫描的操作 字符串不加单引号索引失效 ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:4","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["框架"],"content":"SpringCloud ","date":"2022-02-18","objectID":"/springcloud/:0:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"1. Eureka 1. 提供者与消费者 服务提供者: 一次业务中,被其他服务调用的服务(提供接口给其他服务) 服务消费者: 一次业务中,调用其他服务的服务(调用其他服务提供的接口) 提供者与消费者角色是相对 一个服务可以同时是服务提供者和服务消费者 2. Eureka注册中心 注册服务信息 拉取服务 负载均衡 远程调用 心跳续约 30s/次 1. Eureka的作用 消费者该如何获取服务提供者的具体信息? 服务提供者启动时向eureka注册自己的信息 eureka保存这些信息 消费者根据服务名称想eureka拉取提供者信息 如果有多个服务提供者,消费者该如何选择? 服务消费者利用负载均衡算法,从服务列表中挑选一个 消费者如何感知服务提供者健康状态? 服务提供者会每隔30s向eurekaServer发送心跳请求,报告健康状态 eureka会更新记录服务列表信息,心跳不正常会被剔除 消费者就可以拉取最新的信息 2. 服务注册 引入eureka-client依赖 在application.yml中配置eureka地址 ","date":"2022-02-18","objectID":"/springcloud/:0:1","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"2. Ribbon 1. Ribbon负载均衡规则 规则接口是IRule 默认实现是ZoneAvoidanceRule,根据zone选择服务列表,然后轮询 2. 负载均衡自定义方式 代码方式: 配置灵活,但修改时需要重新打包发布 配置方式: 直观,方便,无需重新打包发布,但是无法做全局配置 3. 饥饿加载 开启饥饿加载 eager-load 指定饥饿加载的服务名称 ","date":"2022-02-18","objectID":"/springcloud/:0:2","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"3. Nacos 1. yml配置 cloud:nacos:server-addr:110.40.236.91:8848# nacos服务端地址discovery:cluster-name:HZ# 集群名称2. 根据权重负载均衡 权重为0不会被访问 3. 环境隔离-namespace Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西,用来做最外层隔离! namespace用来做环境隔离 每个namespace都有唯一id 不同namespace下的服务不可见 5. nacos注册中心细节分析 6. 临时实例和非临时实例 服务注册到Nacos时,可以选择注册为临时或非临时实例,通过下面的配置来设置: ephemeral:true# 是否是临时实例7. Nacos与eureka异同 Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态: 临时实例采用心跳模式,非临时实例采用主动检测模式 临时实例心跳不正常会被剔除,非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式,服务列表更新更加及时 Nacos集群默认采用AP方式,当集群中存在非临时实例时,采用CP模式;Eureka采用AP模式 8. 统一配置管理 将配置交给Naocs管理的步骤 在Nacos中添加配置文件 在微服务中引入nacos的config依赖 在微服务中添加bootstrap.yml,配置nacos地址,当前环境,服务名称,文件后缀名.这些决定了启动时去nacos读取哪个文件 9. 配置自动刷新 Nacos中的配置文件变更后,微服务无需重启就可以感知.不过需要通过下面两种配置实现: 方式一: 在@Value注入的变量所在类添加注解@RefreshScope 方式二: 使用@ConfigurationProperties注解 @Data @Component @ConfigurationProperties(prefix = \"pattern\") public class PatternProperties { private String dateformat; } @Autowired private PatternProperties patternProperties; 不是所有的配置都适合放到配置更新,维护起来比较麻烦 建议将一些关键参数,需要运行时调整的参数放到nacos配置中心,一般都是自定义配置 10. 多环境配置共享 微服务启动时会从nacos读取多个配置文件,无论profile如何变化,共享的文件一定会被加载 多种配置的优先级: 服务名-profile.yaml \u003e 服务名称.yaml \u003e 本地配置 ","date":"2022-02-18","objectID":"/springcloud/:0:3","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"4. Feign RestTemplate方式调用存在的问题: 代码可读性差,编程体验不统一 参数复杂URl难以维护 Feign: Feign是一个声明式的http客户端,起作用就是帮助我们优雅的实现http请求的发送,解决上面提到的问题. 1. Feign的使用步骤: 引入依赖 添加@EnableFeignClients注解 编写FeignClient接口 使用FeignClient中定义的方法代替RestTemplate 2. 自定义Feign的配置 Feign运行自定义配置来覆盖默认配置,可以修改的配置如下: 一般我们需要配置的就是日志级别 配置Feign日志有两种方式: 方式一: 配置文件方式 全局生效: feign:client:config:default:loggerLevel:FULL 局部生效: feign:client:config:userservice:# 服务名loggerLevel:FULL 方式二: java代码方式,需要先声明一个Bean public class FeignClientConfiguration { @Bean public Logger.Level FeignLogLevel(){ return Logger.Level.BASIC; } } 如果是全局配置,则霸道放到@EnableFeignClients这个注解中 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class) 如果是局部配置,则把他放到@FeignClient这个注解中 @FeignClient(value = \"userservice\" , configuration = FeignClientConfiguration.class) 3. Feign的性能优化 Feign底层的客户端实现: URLConnection : 默认实现,不支持连接池 Apache HttpClient : 支持连接池 OKHttp: 支持连接池 因此优化Feign的性能主要包括: 使用连接池代替默认的URLConnection 日志级别,最好用basic 或none 设置连接池参数 httpclient:enabled:true# 开启feign对HttpClient的支持max-connections:200# 最大的连接数max-connections-per-route:50# 每个路径的最大连接数4. Feign的最佳实践 方式一(继承): 给消费者的feignClient和提供者的controller定义同一的父接口作为标准 服务紧耦合 父接口参数列表中的映射不会被继承 方式二(抽取): 将FeignClient抽取为独立模块,并且把接口有关的pojo,默认的Feign配置都放到这个模块中,提供给所有消费者使用 5. 抽取FeignClient 实现最佳实践方式二的步骤: 创建一个module,命名为feign-api,然后引入feign的starter依赖 将原先的client,pojo都移到feign-api项目中 在@EnableFeignClients注解中添加clients,指定具体FeignClient的字节码 ","date":"2022-02-18","objectID":"/springcloud/:0:4","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"5. Gateway 1. 为什么需要网关 身份认证和权限校验 服务路由,负载均衡 请求限流 2. 网关的技术实现 在SpringCloud中网关的实现包括两种: gateway zuul 3. 搭建网关服务 引入依赖: 网关依赖,服务发现依赖 编写配置文件 server:port:8084spring:application:name:gateway# 服务名称cloud:nacos:server-addr:110.40.236.91:8848gateway:routes:- id:user-service# 路由标识uri:lb://userservice# 路由的目标地址predicates:# 路由断言,判断是否符合规则- Path=/user/**# 路径断言,.判断路径是否是以/user开头- id:order-service# 路由标识uri:lb://orderservice# 路由的目标地址predicates:# 路由断言,判断是否符合规则- Path=/order/**# 路径断言,.判断路径是否是以/user开头","date":"2022-02-18","objectID":"/springcloud/:0:5","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"6. RabbitMQ 1.安装MQ 拉取镜像: docker pull RabbitMQ:3-management 运行MQ容器: docker run -d –name my_rabbitMQ -e RABBITMQ_DEFAULT_USER=codesniper -e RABBITMQ_DEFAULT_PASS=gongxiwu -p 15672:15672 -p 5672:5672 rabbitmq:3-management 2. RabbitMQ概述 RabbitMQ的结构和概念 3. RabbitMQ的几个概念 channel: 操作MQ的工具 exchange: 路由消息到队列中 queue: 缓存消息 virtual host: 虚拟主机,是对queue,exchange等资源的逻辑分组 4. 常见消息模型 MQ的官方文档中给出了几个MQ的demo实例: 基本消息队列(BasicQueue) 工作消息队列(WorkQueue) 发布订阅,根据交换机不同分3种 Fanout Exchange: 广播 Direct Exchange: 路由 Topic Exchange: 主题 Hello World案例 官方的HelloWorld是基于最基础的消息队列模型来实现的,只包括三个角色 publisher: 消息发布者,将消息发送到队列queue queue: 消息队列,负责接受并缓存消息 Consumer: 订阅队列,处理队列中的消息 基本消息队列的消息的发送流程: 建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息 基本消息队列的消息接受流程: 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 5. SpringAMQP 利用SpringAMQP实现HelloWorld中的基础消息队列功能 流程如下: 在父工程中引入spring-amqp的依赖 在publisher服务中利用RabbitTemplate发送消息到simple.queue中 在consumer服务中编写消费逻辑,绑定simple.queue这个队列 1. 在publisher中编写测试方法,向simple.queue中发送消息 在publisher服务中编写application.yml,添加mq连接信息 spring:rabbitmq:host:110.40.236.91port:5672virtual-host:/username:***password:*****在publisher服务中编写测试方法 @SpringBootTest class PublisherApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; @Test public void sendMessageToSimpleQueueTest(){ String queueName = \"simple.queue\"; String message = \"hello,world!\"; rabbitTemplate.convertAndSend(queueName,message); } } 2. 在consumer中编写消费逻辑,监听simple.queue 在consumer服务中编写application.yml,添加mq连接信息 spring:rabbitmq:host:110.40.236.91port:5672virtual-host:/username:***password:*****在consumer服务中新建一个类,编写消费逻辑 @Component public class RabbitMQListener { @RabbitListener(queues = \"simple.queue\") public void listenSimpleQueue(String msg){ System.out.println(\"msg = \" + msg); } } Work Queue工作队列 Work Queue,工作队列,可以提高消息处理速度,避免队列消息堆积 1. 消费预取限制 spring:rabbitmq:host:110.40.236.91port:5672virtual-host:/username:***password:***listener:simple:prefetch:1 发布(Publish),订阅(Subscribe) 发布订阅模式之前案例的区别就是允许将同一信息发送给多个消费者. 常见exchange类型包括: Fanout: 广播 Direct: 路由 Topicc: 话题 1. 发布订阅-Fanout Exchange Fanout Exchange会将接受到的消息路由到每一个跟其绑定的queue 演示FanoutExchange的使用 实现思路如下 在consumer服务中,利用代码声明队列,交换机,并将两者绑定 在consumer服务中,利用两个消费方法,分别监听两个fanout.queue1和fanout.queue2 在publisher中编写测试方法,想itcast.fanout发送消息 步骤1: 在consumer服务声明Exchange,Queue,Binding 在consumer服务新建一个类,添加@configuration注解,声明FanoutExchange,Queue和绑定关系对象Binding /** * 声明交换机 * @return FanoutExchange */ @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\"my.fanout\"); } /** * 声明队列1 * @return Queue */ @Bean public Queue fanoutQueue1(){ return new Queue(\"fanout.queue1\"); } /** * 队列1绑定到交换机 * @param queue * @param fanoutExchange * @return Binding */ @Bean public Binding fanoutQueueBinding1(@Qualifier(\"fanoutQueue1\") Queue queue, FanoutExchange fanoutExchange){ return BindingBuilder.bind(queue).to(fanoutExchange); } /** * 声明队列2 * @return Queue */ @Bean public Queue fanoutQueue2(){ return new Queue(\"fanout.queue2\"); } /** * 队列2绑定到交换机 * @param queue * @param fanoutExchange * @return Binding */ @Bean public Binding fanoutQueueBinding2(@Qualifier(\"fanoutQueue2\") Queue queue,FanoutExchange fanoutExchange){ return BindingBuilder.bind(queue).to(fanoutExchange); } 步骤2: 在consumer服务声明两个消费者 在consumer服务的监听类中,分别添加方法监听两个队列 @RabbitListener(queues = \"fanout.queue1\") public void listenFanoutQueue1(String msg){ System.out.println(\"接受fanout.queue1的消息: \" + msg + LocalTime.now()); } @RabbitListener(queues = \"fanout.queue2\") public void listenFanoutQueue2(String msg){ System.out.println(\"接受fanout.queue2的消息: \" + msg + LocalTime.now()); } 步骤3: 在publisher服务发送消息到FanoutExchange 在publisher服务发送消息 @Test public void sendMessageToFanoutExchange(){ String exchangeName = \"my.fanout\"; String message = \"Hello,FanoutExchange!!\"; rabbitTemplate.convertAndSend(exchangeName,\"\",message); } 2. 发布订阅-DirectExchange Direct Exchange 会将接受到的消息根据规则路由到指定的Queue 每一个Queue都与Exchange设置一个BindingKey 发布者发送消息时,指定信息的RoutingKey Exchange将消息路由到BindingKey与消息RoutingKey一致的队列 演示DirectExchange的使用 步骤1: 在co","date":"2022-02-18","objectID":"/springcloud/:0:6","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"7. ES 概念: MySQL ES 说明 Table Index 索引(index),就是文档的集合,类似数据库的表(table) Row Document 文档(Document),就是一条条的数据,类似数据库的行(Row),文档就是JSON格式 Column Field 字段(Field),就是JSON文档中的字段,类似数据库的列(COlumn) Schema Mapping Mapping(映射)是索引中的文档的约束,例如字段类型约束.类似数据库的表结构 SQL DSL DSL是elasticsearch提供的JSON风格的请求语句,用来操作elasticsearch,实现CRUD 架构: MySQL: 擅长事务类型操作,可以确保数据的安全和一致性 Elasticsearch: 擅长海量数据的搜索,分析,计算 docker run –name elasticsearch -p 9200:9200 -p 9300:9300 -e “discovery.type=single-node” -e ES_JAVA_OPTS=\"-Xms64m -Xmx128m\" -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.4.2 9d2f21adf463 docker run -it -e ELASTICSEARCH_URL=http://127.0.0.1:9200 –name kibana –network=container:elasticsearch 9d2f21adf463 docker run --name elasticsearch --net hahanetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -d elasticsearch:7.4.1 ","date":"2022-02-18","objectID":"/springcloud/:0:7","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["并发编程"],"content":"1. 进程与线程 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:0","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"1.1 进程与线程 1.1.1 进程 程序由指令和数据组成,但这些指令要运行,数据要读写,就必须将指令加载至CPU,数据加载至内存.在指令运行过程中还需要用到磁盘,网络等设备.进程用来加载指令,管理内存,管理IO的. 当一个程序被运行,从磁盘加载这个程序至内存,这时就开启了一个进程. 进程就可以视为程序的一个实例.大部分程序可以同时运行多个实例进程,也有的程序只能启动一个实例进程. 1.1.2 线程 一个进程之内可以分一到多个线程. 一个线程就是一个指令流,将指令流中的一条条指令以一定的顺序交给CPU执行 Java中,线程作为最小调度单位,进程作为资源分配的最小单位,在Windows中进程是不活动的,知识作为线程的容器. 1.1.3 二者对比 进程基本上相互独立,线程在进程内,是进程的一个子集. 进程拥有共享的资源,如内存空间等,供内部的线程共享. 进程间通信较为复杂 同一台计算机的进程通信成为IPC 不同计算机之间的进程通信,需要通过网络,并遵守共同的协议. 线程通信相对简单,因为他们共享进程的内存,一个例子是多个线程可以访问同一个共享变量 线程更轻量,线程上下文切换成本一般要比进程上下文切换低. ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:1","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"1.2 并行与并发 单核cpu下,线程实际还是串行执行的.操作系统中有一个组件叫做任务调度器,将cpu的时间片分给不同的线程使用,只是由于cpu在线程间的切换非常快,感觉是同时运行的. 一般会将这种线程轮流使用cpu的做法成为并发. 多核cpu下,每个核都可以调度运行线程,这时候线程是并行的. 并发: 同一时间应对多件事情的能力. 并行: 同一时间动手做多件事情的能力. ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:2","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"1.3 应用 1.3.1 异步调用案例 从方法调用角度来说: 需要等地啊结果返回,才能继续运行就是同步 不需要等待结果返回,就能继续运行就是异步 注意: 同步在多线程中海油另外一层的意思,是让多个线程步调一致 设计: 多线程可以让方法执行变为异步的,比如说读取磁盘文件时,假设读取操作话费了5s,如果没有线程调度机制,这5s调用者什么都做不了,其代码都得暂停. 结论: 比如在项目中,视频文件需要转换格式等操作比较费时,这时开一个新线程处理视频转换,避免阻塞主线程. tomcat的异步servlet也是类似的目的,让用户线程处理耗时比较长的操作,避免阻塞tomcat的工作线程 1.3.2 提高效率案例 充分利用多核cpu的有事,提高运行效率.想象下面的场景,执行3个计算,最后将计算结果汇总. 计算 1 花费 10 ms 计算 2 花费 11 ms 计算 3 花费 5 ms 汇总需要 1 ms 如果是串行执行,name总共花费 10 + 11 + 5 + 1 = 27ms 但如果是四核cpu,各个核心分别使用线程1执行计算1 ,线程2执行计算2…..花费时间只取决于最长的那个线程运行的时间,及11ms 最后加上汇总的时间只会花费12ms 注意: 需要在多核cpu才能提高效率,单核仍然是轮流执行 结论 单核cpu下,多线程不能实际提高程序运行效率,知识为了能够在不同的任务之间切换,不同线程轮流使用cpu,不至于一个线程总占用cpu,别的线程没法干活 多核cpu可以并行跑多个线程,但能否提高程序运行效率还是要分情况的 有些任务,经过精心设计,将任务拆分,并行执行,当然可以提高程序的运行效率,但不是所有计算任务都能拆分 也不是所有任务都需要拆分,任务的目的如果不同,谈拆分和效率没啥意义 IO操作不占用cpu,知识我们一般拷贝文件使用的是阻塞IO,这相当于线程虽然不用cpu,但需要一直等待IO结束,没能充分利用线程,所以才有后面的非阻塞IO和异步IO优化 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:3","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2. Java线程 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:0","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.1 创建和运行线程 2.1.1 方法一,直接使用Thread public class CreateThread { public static void main(String[] args) { Thread t = new Thread(()-\u003e{ System.out.println(Thread.currentThread().getName()+ \"-\u003e\" + \"running...\"); }); t.setName(\"t1\"); t.start(); System.out.println(Thread.currentThread().getName()+ \"-\u003e\" + \"running...\"); } } 2.1.2 方法二,使用Runnable配合Thread public class CreateThreadByRunnable { public static void main(String[] args) { //创建任务对象 Runnable runnable = () -\u003e System.out.println(Thread.currentThread().getName() + \"-\u003e\" + \"running\"); Thread t1 = new Thread(runnable, \"t1\"); t1.start(); System.out.println(Thread.currentThread().getName() + \"-\u003e\" + \"running\"); } } 2.1.3 方法三,FutureTask配置Thread public class CreateThreadByFutureTask { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u003cString\u003e futureTask = new FutureTask\u003c\u003e(()-\u003e{ System.out.println(Thread.currentThread().getName() + \"running...\"); Thread.sleep(2000); return \"continue running...\"; }); Thread thread = new Thread(futureTask,\"t1\"); thread.start(); System.out.println(futureTask.get()); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:1","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.2 观察多个线程同时运行 主要是理解 交替执行 谁先谁后,不由我们控制 public class ThreadRunSameTime { public static void main(String[] args) { //线程t1 new Thread(()-\u003e{ while (true) { System.out.println(Thread.currentThread().getName()+ \"running...\"); } },\"t1\").start(); //线程t2 new Thread(()-\u003e{ while (true) { System.out.println(Thread.currentThread().getName()+ \"running...\"); } },\"t2\").start(); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:2","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.3 查看进程线程的方法 linux ps -fe 查看所有进程 ps -fT -p 查看某个进程(PID) 的所有信息 kill 杀死进程 top 按大写H切换是否显示进程 top -H -p 查看某个进程(PID)的所有信息 Java jps 查看所有Java进程 jstack 查看某个Java进程(PID)的所有线程状态 jconsole 查看某个Java进程中线程的运行状态(图形界面) ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:3","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.4 线程运行原理 2.4.1 栈与栈帧 我们知道JVM中由堆,栈,方法区所组成,其中栈内存是给谁用的呢?其实就是线程,每个线程启动后,虚拟机就会为其分配一块栈内存. 每个栈由多个栈帧(Frame)组成,对应着每个方法调用时所占用的内存 每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法 2.4.2 线程上下文切换(Thread Context Switch) 因为以下一些原因导致cpu不在执行当前线程,转而执行另一个线程的代码 线程的cpu时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用sleep,yield,wait,join,park,synchronized,lock等方法 当Context Switch 发生时,需要由操作系统保存当前线程的状态,并恢复另一个线程的状态,Java中对应的概念就是程序计数器,它的作用就是记住下一条jvm指令的执行地址,是线程私有的 状态包括程序计数器,虚拟机栈中的每个栈帧的信息,如局部变量,操作数栈,返回地址等 COntext Switch 频繁发生会影响性能 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:4","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.5 常见方法 方法名 功能说明 注意 start() 启动一个新线程,在新的线程运行run方法中的代码 start方法只是让线程进入就绪,里面代码不一定立刻执行(cpu的时间片还没分给它).每个线程对象的start方法只能调用一次,如果调用了多次会出现IllegalThreadStateException run() 新线程启动后会调用的方法 如果在构造Thread对象时传递了Runnable参数,则线程启动后会调用Runnable中的run方法,否则默认不执行任何操作,但可以创建Thread的子类对象,来覆盖默认行为 join() 等待线程运行结束 join(long n) 等待线程运行结束最多等待n毫秒 getId() 获取线程长整形id id唯一 getName() 获取线程名 setName(String) 修改线程名 getPriority() 获取线程优先级 setPriority(int) 修改线程优先级 Java中规定线程优先级是1~10的整数,较大的优先级能提高该线程被cpu调用的几率 getState() 获取线程黄台 Java中线程状态是用6个enum表示,分别是: NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED isInterrupted() 判断是否被打断 不会清除 isAlive 线程是否存活 interrupt() 打断线程 如果被打断线程正在sleep,wait,join会导致被打断的线程抛出InterruptedExcepiton,并清除打断标记;如果打断的正在运行的线程,则会设置打断标记;park的线程被打断,也会设置打断标记 interrupted() (static) 判断当前线程是否打断 会清除打断标记 currentThread() (static) 获取当前正在执行的线程 sleep(long n) (static) 让当前执行的线程休眠n毫秒,休眠时让出cpu的时间片给其他线程 yield() (static) 提示线程调度器让出当前线程对cpu的使用 主要用于测试和调试 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:5","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.6 start与run 调用run public class StartAndRun { public static void main(String[] args) { Thread thread = new Thread(\"t1\"){ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"running...\"); } }; thread.run(); System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"do other things...\"); } } 程序仍然在main线程运行,方法调用还是同步 调用start public class StartAndRun { public static void main(String[] args) { Thread thread = new Thread(\"t1\"){ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"running...\"); } }; //thread.run(); thread.start(); System.out.println(thread.getState()); System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"do other things...\"); } } 方法调用是异步的!!!! ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:6","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.7 sleep与yield sleep 调用sleep会让当前线程从Running进入Timed Waiting状态 其他线程可以使用interrupt方法打断正在睡眠的线程,这是sleep方法会抛出InterrupttedException 睡眠结束后的线程尾部会立刻得到执行 建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性 yield 调用yield会让当前线程从Running进入Runnable状态,然后调度执行其他同优先级的线程.如果这是没有同优先级的线程,name不能保证让当前线程暂停的效果 具体的实现依赖操作系统的任务调度器 线程优先级 线程优先级会提示(hint)调度器优先级调度该线程,但他仅仅是一个提示,调度器可以忽略他 如果cpu比较忙,那么优先级高的线程会获得更多的时间片,但cpu闲时,优先级几乎没有用 public class Priority { public static void main(String[] args) { //任务一 Runnable task1 = ()-\u003e{ int count = 0; for(;;){ System.out.println(Thread.currentThread().getName() + \"-\u003e\" +count++); } }; //任务二 Runnable task2 = ()-\u003e{ int count = 0; for(;;){ //让出时间片 Thread.yield(); System.out.println(Thread.currentThread().getName() + \"-----------------\u003e\" +count++); } }; Thread t1 = new Thread(task1, \"t1\"); Thread t2 = new Thread(task2, \"t2\"); t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t1.start(); t2.start(); } } 案例-防止CPU占用100% sleep实现: 在没有利用cpu计算时,不要让while(true)空转浪费cpu,这时可以使用yield或sleep来让出cpu的使用权给其他程序 while (true){ try { Thread.sleep(500); }catch (InterruptedException e){ e.printStackTrace(); } } } 可以用wait或条件变量达到类似的效果 不同的是,或两种都需要加锁,并且需要响应的唤醒操作,一般适用于进行同步的场景 sleep使用与无需锁同步的场景 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:7","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.8 join方法详解 为什么需要join? public class JoinThread { static int count = 0; public static void main(String[] args) { test(); } public static void test(){ Thread t1 = new Thread(()-\u003e{ try { System.out.println(\"start\"); sleep(1); System.out.println(\"end\"); count = 10; } catch (InterruptedException e) { e.printStackTrace(); } }); thread.start(); System.out.println(\"结果是---\u003e\" +count); System.out.println(\"end\"); } } 分析: 因为主线程和线程t1是并行执行的,t1线程需要1秒后才能得到count = 10 而主线程一开始就要打印count的结果,所以只能打印count = 0 解决方法 主线程中对t1调用join()方法,等待t1线程执行完毕 public class JoinThread { static int count = 0; public static void main(String[] args) throws InterruptedException { test(); } public static void test() throws InterruptedException { Thread t1 = new Thread(()-\u003e{ try { System.out.println(\"start\"); sleep(1); System.out.println(\"end\"); count = 10; } catch (InterruptedException e) { e.printStackTrace(); } }); t1.start(); t1.join(); System.out.println(\"结果是---\u003e\" +count); System.out.println(\"end\"); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:8","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.9 interrupt方法详解 打断sleep,wait,join的线程 public class InterruptThread { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ try { System.out.println(\"sleep...\"); Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); t1.start(); Thread.sleep(2000); t1.interrupt(); System.out.println(\"打断标记-\u003e\" + t1.isInterrupted()); } } 打断正常运行的线程(不会清空打断标记) public class InterruptNormalThread { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ while (true){ boolean flag = Thread.currentThread().isInterrupted(); if (flag){ System.out.println(\"打断状态-\u003e\" + flag); break; } System.out.println(\"打断状态-\u003e\" + flag); } },\"t1\"); t1.start(); Thread.sleep(1000); System.out.println(\"interrupt\"); t1.interrupt(); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:9","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.10 两阶段终止模式 在一个线程T1中如何\"优雅\"的终止线程T2? 这里的\"优雅\" 指的是给T2一个机会去料理后事; 错误思路: 使用线程对象的stop方法停止 stop方法会真正杀死线程,如果这是线程锁住了共享资源,那么当他被杀死后就再没机会释放锁,其他区线程将永远无法获取锁 使用System.exit(int) 方法停止线程 目的仅仅是停止一个线程,但这种做法会让整个程序都停 实现: public class TwoPhaseTerminationTest { public static void main(String[] args) throws InterruptedException { TwoPhaseTermination twoPhaseTermination = new TwoPhaseTermination(); twoPhaseTermination.start(); Thread.sleep(3000); twoPhaseTermination.stop(); } } class TwoPhaseTermination { private Thread monitor; /** * 启动线程 * @return void */ public void start(){ monitor = new Thread(()-\u003e{ Thread current = Thread.currentThread(); while (true){ if (current.isInterrupted()){ System.out.println(\"线程被打断了\"); break; } try { // 情况一: 睡眠状态被打断 Thread.sleep(1000); // 情况二: 执行监控记录被打断 System.out.println(\"执行监控记录\"); } catch (InterruptedException e) { e.printStackTrace(); //重新设置打断标记 monitor.interrupt(); } } }); // 启动线程 monitor.start(); } /** * 停止线程 * @return void */ public void stop(){ monitor.interrupt(); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:10","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.11 打断park线程 public class InterruptParkThread { public static void main(String[] args) throws InterruptedException { test(); } public static void test() throws InterruptedException { Thread t1 = new Thread(()-\u003e{ System.out.println(\"park...\"); LockSupport.park(); System.out.println(\"unPark...\"); System.out.println(\"打断状态-\u003e\" + Thread.currentThread().isInterrupted()); },\"t1\"); t1.start(); Thread.sleep(1000); t1.interrupt(); } } 打断标记为true时,park失效 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:11","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.12 不推荐的方法 还有一些不推荐的方法,这些方法已经过时,容易破坏同步代码块,造成线程死锁 方法名 功能说明 stop() 停止线程运行 suspend() 挂起(暂停)线程运行 resume() 恢复线程运行 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:12","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.13 主线程与守护线程 默认情况下,Java进程需要等待所有线程都运行结束,才会结束,有一种特殊的线程叫做守护线程,只要其他守护线程运行结束,即使守护线程的代码没有执行完,也会强制结束. 例如: public class DaemonThread { public static void main(String[] args) throws InterruptedException { Thread daemon = new Thread(()-\u003e{ while (true){ System.out.println(\"running...\"); } }); // 设置为守护线程 daemon.setDaemon(true); daemon.start(); Thread.sleep(1000); System.out.println(\"end...\"); } } 注意: 垃圾回收线程就是一种守护线程 Tomcat中的Acceptor和Poller线程都是守护线程,所以Tomcat接受到shutdown命令后,不会等待他们处理完当前请求 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:13","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.14 五种状态 这是从操作系统层面来描述的: 初始状态: 仅是在语言层面创建了线程对象,还未与操作系统线程关联 可运行状态: (就绪状态) 指该线程已经被创建(与操作系统线程关联).可以由cpu调度执行 运行状态: 指获取了cpu时间片运行中的状态 当cpu时间片用完,会从运行状态转换至可运行状态,会导致线程的上下文切换 阻塞状态 如果调用了阻塞API,如BIO读写文件,这时该线程实际不会用到cpu,会导致线程上下文切换,进入阻塞状态 等BIO操作完毕,会由操作系统唤醒阻塞的线程,转换至可运行状态 与可运行状态的区别是,对阻塞状态的线程来说只要他们一直不唤醒,调度一直不会考虑调度他们 终止状态: 表示线程已经执行完毕,声明周期已经结束,不会再转换为其他状态 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:14","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.15 六种状态 这是从Java API层面来描述的,根据Thread.State枚举,分为6种状态 NEW: 线程刚被创建,但是还没有调用start()方法 RUNNABLE当调用了start()方法之后,注意,Java API层面的RUNNABLE状态涵盖了操作系统层面的 可运行状态,运行状态和阻塞状态(由于BIO导致的线程阻塞,在Java中无法区分,仍然认为是可运行的) BLOCKED,WAITING,TIMED_WAITING都Java API层面对阻塞状态的细分 TERMINATED: 当线程代码运行结束 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:15","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3. 共享模型之管程 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:0","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.1 共享带来的问题 Java的体现: public class SimultaneousOperation { static int count = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { count++; } },\"t1\"); Thread t2 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { count--; } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count); } } 临界区 Critical Section 一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源 多个线程读共享资源其实也没问题 在多个线程对共享资源读写操作时发生指令交错,就会出现问题 竞态条件 Race Condition 多个线程在临界区内执行,由于代码的执行序列不同而导致结果无法预测,称之为发生了竞态条件 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:1","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.2 Synchronized 解决方案 为了避免临界区的竞态条件发生,有多种手段可以达到目的. 阻塞式的解决方案: synchronized,Lock 非阻塞式的解决方案: 原子变量 使用synchronized来解决上述问题,即俗称的\"对象锁\",他采用互斥的方式让同一时刻至多只能有一个线程能持有\"对象锁\",其他线程再想获取这个\"对象锁\"时就会阻塞住.这样就能保证拥有锁的线程可以安全的执行临界区的代码,不用担心线程上下文的切换 synchronized 语法: synchronized(对象) { 临界区 } 解决: public class SimultaneousOperation { static int count = 0; static final Object lock = new Object(); public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { synchronized (lock){ count++; } } },\"t1\"); Thread t2 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { synchronized (lock){ count--; } } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count); } } synchronized实际是用对象锁保证了临界区内代码的原子性,临界区的代码对外是不可分割的,不会被线程切换所打断 面向对象改进 public class SimultaneousOperation { public static void main(String[] args) throws InterruptedException { Room room = new Room(); Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 5000; i++) { room.increase(); } }, \"t1\"); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 5000; i++) { room.reduce(); } }, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(room.getValue()); } } //面向对象改进 class Room{ private int count = 0; /** * 加操作 * @return void */ void increase(){ synchronized (this){ count++; } } /** * 减操作 * @return void */ void reduce(){ synchronized (this){ count--; } } /** * 获取值 * @return int */ int getValue(){ synchronized (this){ return count; } } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:2","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.3 方法上的synchronized 成员方法上的synchronized等于锁这个对象 静态方法上的synchronized等于锁这个类对象 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:3","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.4 变量的线程安全分析 成员变量和静态变量是否线程安全? 如果他们没有共享,则线程安全 如果他们被共享了,根据他们的状态是否能够改变,又分两种情况 如果只有读操作,则线程安全 如果有读写操作,则这段代码是临界区,需要考虑线程安全 局部变量是否线程安全? 局部变量是线程安全的 但局部变量引用的对象则未必 如果该对象没有逃离方法的作用访问,他是线程安全的 如果该对象逃离方法的作用范围,需要考虑线程安全 常见线程安全类 String Integer StringBuffer Random Vector Hashtable java.util.concurrent包下的类 这里说他们是线程安全是指,多个线程调用他们同一个实例的某个方法时,是线程安全的. 他们的每个方法时原子的 但注意他们多个方法的组合不是原子的 不可变类线程安全性 String,Integer等都是不可变类,因为其内部的状态不可以改变,因此他们的方法都是线程安全的 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:4","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.5 Monitor概念 Monitor(锁) Monitor被翻译成监视器或管程 每个Java对象都可以关联一个Monitor对象,如果使用synchronized给对象上锁之后,.该对象头的Mark Word中就被设置指向Monitor对象的指针 Monitor结构如下: 刚开始Monitor中Owner为null 当Thread-2执行synchronized(obj)就会将Monitor中的所有者Owner置为Thread-2,Monitor中只能有一个Owner 在Thread-2上锁的过程中,如果Thread-3,Thread-4,Thread-5也来执行synchronized(obj),就会进入EntryList BLOCKED Thread-2执行完同步代码块中的内容,然后唤醒EntryList中等待的线程来竞争锁,竞争时是非公平的 WaitSet中的Thread-0,Thread-1是之前获得过锁,但条件不满足进入WAITING状态的线程 注意: synchronized必须是进入同一个对象的monitor才有的效果 不加synchronized的对象不会关联监视器,不遵从以上规则 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:5","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.6 synchronized原理进阶 轻量级锁 创建锁记录(Lock Record)对象,每个线程的栈帧都会包含一个锁记录的结构,内部可以存储锁定对象的Mark Word 让锁记录中的Object reference指向锁对象,并尝试用cas替换Object的Mark Word,将Mark Word的值存入锁记录 如果cas替换成功,对象头中存储了锁记录地址和状态00,表示由该线程给对象加锁 如果cas替换失败,有两种情况 如果是其他线程已经持有该Object的轻量级锁,这时表明有竞争,进入锁膨胀过程 如果是自己执行了synchronized锁重入,那么在添加一条Lock Record作为重入的计数 当退出synchronized代码块时(解锁时),如果有取值为null的锁记录,表示有重入,这时重置锁记录,表示重入计数减一 当退出synchronized代码块(解锁时)锁记录的值不为null,这时使用cas将Mark Word的值恢复给对象头 成功,则解锁成功 失败,说明轻量级锁进入了锁膨胀或已经升级为重量级锁,进入重量级锁解锁流程 锁膨胀 如果在尝试加轻量级锁的过程中,CAS操作无法成功时,这时一种情况就是有其他线程为此对象加上了轻量级锁(有竞争),这时需要进行锁膨胀,将轻量级锁变为重量级锁 当Thread-1进行轻量级加锁时,Thread-0已经对该对象加了轻量级锁 这时Thread-1加轻量级锁失败,进入锁膨胀流程 即为Object对象申请Monitor锁,让Object指向重量级锁地址 然后进入Monitor的EntryList BLCOKED 当Thread-0退出同步块解锁时,使用cas将Mark Word的值恢复给对象头,失败.这时进入重量级解锁流程,按照Monitor地址找到Monitor对象,设置Owner为null,唤醒EntryList中的BLOCKED线程 自旋优化 重量级锁竞争的时候,还可以使用自旋来进行优化,如果当前线程自旋成功(即这时候持有锁线程已经退出了同步块,释放了锁),这时当前线程就可以避免阻塞 线程1(cpu1上) 对象Mark Word 线程2(cpu2上) - 10(重量级锁) - 访问同步块,获取monitor 10(重量级锁) - 成功(加锁) 10(重量级锁) - 执行同步块 10(重量级锁) - 执行同步块 10(重量级锁) 访问同步块,获取monitor 执行同步块 10(重量级锁) 自旋重试 执行完毕 10(重量级锁) 自旋重试 成功(解锁) 01(无锁) 自旋重试 - 10(重量级锁) 成功(加锁) - 10(重量级锁) 执行同步块 自旋失败,会阻塞 在Java6以后自旋锁是自适应的,比如对象刚刚的一次自旋操作成功过,那么认为这次自旋成功的可能性会高,就多自旋几次 自旋会占用cpu时间,单核cpu自旋就是浪费,多核cpu自旋才能发挥优势 Java7之后不能控制是否开启自旋功能 偏向锁 轻量级锁在没有竞争时(就自己这个线程),每次重入仍然需要执行CAS操作. Java6中引入了偏向锁来做进一步优化,只有第一次使用CAS操作将线程ID设置到对象的Mark Word中,之后发现这个线程ID是自己的表示没有竞争,不用重新CAS.以后只要不发生竞争,这个对象就归该线程所有 1. 偏向状态 一个对象创建时: 如果开启了偏向锁(默认开启),name对象创建以后,markWord值为0x05即最后3位位101,这时他的thread,epoch,age都为0 偏向锁默认是延迟的,不会在程序启动时立即生效,如果想避免延迟,可以加VM参数:-xx:BiasedLockingStartupDelay=0来禁用延迟 如果没有开启偏向锁,那么对象创建后,MarkWord值为0x01即最后3位位001,这时他的hashcode,age都为0,第一次用到hashcode时才会赋值 2. 撤销-调用对象hashCode 调用了对象的hashCode,但偏向锁的对象MarkWord中存储的是线程id,如果调用hashCode会导致偏向锁被撤销 轻量级锁会在锁记录中记录hashCode 重量级锁会在Monitor中记录hashCode 在调用hashCode后使用偏向锁,记得去掉-xx:-UseBiasedLocking 3. 撤销-其他线程使用对象 当其他线程使用偏向锁对象时,会将偏向锁升级为轻量级锁 4. 撤销-调用wait/notify 5. 批量重偏向 如果对象虽然被多个线程访问,但没有竞争,这时偏向了线程t1的对象仍有机会重新偏向t2,重偏向会重置对象的线程id 当撤销偏向锁阈值20次后,jvm会觉得,我是不是偏向错了,于是会给这些对象加锁时重新偏向加锁线程 6. 批量撤销 当撤销偏向锁阈值超过40次后,jvm会这样觉得,自己确实偏向错了,根本就不应该偏向,于是整个类的所有对象都会变为不可偏向,新建的对象也是不可偏向 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:6","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.7 wait notify介绍 wait/notify原理 Owner线程发现条件不满足,调用wait方法,即可进入WatiSet变为WAITING状态 BLOCKED和WAITING的线程都处于阻塞状态,不占用CPU时间片 BLOCKED线程会在Owner线程释放锁时唤醒 WAITING线程会在Owner线程调用notify或notifyAll时唤醒,但唤醒后并不意味着立刻获得锁,仍需进入EntryList重新竞争 API介绍 obj.wait()让进入object监视器的线程到WaitSet等待(无限制等待) obj.wait(long timeout)有时限的等地啊,到n毫秒后结束等待,或是被notify obj.notify()让object上正在WaitSet等待的线程中挑一个唤醒 obj.notifyALl()让object上正在WaitSet等待的线程全部唤醒 他们都是线程之间进行协作的手段,都属于Object对象的方法,必须获得此对象的锁,才能调用这几个方法 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:7","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.8 wait/notify正确使用 sleep(long n)和wait(long n)的区别 sleep是Thread方法,而wait是Object的方法 sleep不需要强制和synchronized配合使用,但wait需要 sleep在睡眠的同时,不会释放锁对象的,但wait在等待的时候会释放锁对象 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:8","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Spring"],"content":"1. 动态代理的实现 1. jdk动态代理: 使用java反射包中的类和接口实现动态代理的功能 反射包 java.lang.reflect,里面有三个类:InvocationHandler,Method,Proxy 2. cglib动态代理 cglib是第三方的工具库,创建代理对象. cglib的原理是继承,cglib通过继承目标类,创建他的子类,在子类中重写父类中同名的方法,实现功能的修改. 因为cglib是继承,重写方法,所以要求目标类不能是final的,方法也不能是final的 ","date":"2022-01-16","objectID":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:0:1","tags":["反射"],"title":"动态代理","uri":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["Spring"],"content":"2. jdk动态代理 1. 反射,Method类,表示方法,类中的方法.通过Method可以执行某个方法. 2. jdk动态代理的实现 InvocationHandler 就一个方法invoke() invoke():表示代理对象要执行的功能代码,你的代理类要完成的功能卸载invoke()方法中. 方法原型: 参数: Object proxy: jdk创建的代理对象,无需赋值 Method method: 目标类中的方法,jdk提供method对象的 Object[] args: 目标类中的方法的参数,jdk提供 Method 表示方法的,确切的说是目标类中的方法 通过Mehtod可以执行某一个目标类的方法,Method.invoke() Proxy 核心的对象,创建的代理对象,之前创建对象都是用new类的构造方法(),现在使用Proxy类的方法,代替new的使用 静态方法:newProxyInstance(),创建代理对象 参数: classLoader loader: 类加载器,负责向内存中加载对象的.使用反射获取对象的ClassLoader Class\u003c?\u003e[] interfaces: 接口,目标对象实现的接口,也是反射获取的 InvocationHander h: 我们自己写的,代理类要完成的功能 ","date":"2022-01-16","objectID":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:0:2","tags":["反射"],"title":"动态代理","uri":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["框架"],"content":"1. 基本概念 事务是数据库操作的最小工作单元,是作为单个逻辑工作单元执行的一些列操作;这些操作作为一个整体一起向系统提交,要么都执行,要么都不执行;事务是一组不可再分割的操作集合 通俗点说就是为了达到某个目的而做的一些列操作,要么一起成功(事务提交),要么一起失败(事务回滚) ","date":"2022-01-15","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:0:1","tags":["MySQL","事务"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["框架"],"content":"2. 事务的四大特性 原子性(Atomicity): 事务中所有操作时不可再分割的原子单位.事务中所有操作要么全部执行成功,要么全部执行失败 一致性(Consistency): 事务执行后,数据库状态与其他业务规则保持一致,如转账业务,无论事务执行成功与否,参与转账的两个账号余额之和应该是不变的 隔离性(Isolation): 并发执行的事务不会互相影响,其对数据库的影响和他们串行执行时一样.比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的记过一样 持久性(Durability): 一旦事务提交成功,事务中的所有数据操作都必须被持久化到数据库中,即使提交事务后,数据库崩溃,在数据库重启时,也能保证某种机制恢复数据 ","date":"2022-01-15","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:0:2","tags":["MySQL","事务"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["框架"],"content":"3. 事务的隔离级别 脏读(读取了未提交的数据,然后被回滚了) 事务A读取了事务B中尚未提交的数据,如果事务B回滚,则A读取使用了错误的数据 不可重复读(读取了提交的新事物,指更新操作) 不可重复读是指在对于数据库中的某个数据,一个事务范围内多次查询却返回了不同的数据,这是由于在查询间隔,被另一个事务修改并提交了 幻读(读取了提交的新事物,指增删操作) ​ 在事务A多次读取中,事务B对数据进行了新增操作,导致事务A多次读取的数据不一致 第一类事务丢失(回滚丢失) 对于第一类事务丢失,就是比如A和B同时在执行一个数据,然后B事务已经提交了,然后A事务回滚了,这样B事务的操作就因A事务的回滚二丢失了 第二类事务丢失(覆盖丢失) ​ 对于第二类事务丢失,也称为覆盖丢失,就是A和B一起执行一个数据,两个同时取一个数据,然后B事务首先提交,但是A事务接下来又提交,这样就覆盖了B事务 Read uncommitted 读未提交,就是一个事务可以读取另一个未提交事务的数据,会产生脏读 Read committed 读已提交,就是一个事务要等到另一个事务提交后才能读取数据,会产生不可重复读 Repeatable read 重复读,就是在开始读取数据(事务开启时),不在允许修改操作,可能会产生幻读 Serializable 最高的事务隔离级别,在该级别下,事务串行化顺序执行,可以避免脏读,不可重复读与幻读,但这种事务隔离级别效率低下,比较耗数据库性能,一般不使用 ","date":"2022-01-15","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:0:3","tags":["MySQL","事务"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["框架"],"content":"4. 事务的实现原理 原子性是通过undo log来实现 Undo Log是为了实现事务的原子性,在MySQL数据库InnoDB存储引擎中,Undo Log来实现多版本并发控制(MVCC) 在操作任何数据之前,首先将数据备份到一个地方(Undo log).然后进行数据的修改.如果出现错误或者用户执行了ROLLBACK语句,系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态 Undo Log是逻辑日志,可以理解为: 当delete一条记录时,Undo Log中会记录一条对应的insert记录 当insert一条记录时,会记录一条对应的delete记录 update一条记录时,他记录一套对应相反的update记录 持久性通过redo log来实现 和Undo Log相反,Redo Log记录的是新数据的备份.在事务提交前,只要将Redo Log持久化即可,不需要将数据持久化.当系统崩溃时,虽然数据没有持久化,但是Redo Log已经持久化.系统可以根据Redo Log的内容,将所有数据恢复到最新的状态 隔离性是通过(读写锁 + MVCC)来实现 事务具有隔离性,理论上来说事务之间的执行不应该相互产生影响,其对数据库的影响应该和他们串行执行时一样 然而完全的隔离性会导致系统并发性能很低,降低对资源的利用率,因而实际上对隔离性的要求会有所放宽,这也会一定程度造成对数据库一致性要求降低 SQL标准为事务定义了不同的隔离级别,从低到高一次是 读未提交(READ UNCOMMITTED): 对事务处理的读取没有任何限制,不推荐 读已提交(READ COMMITTED) 可重复度(REPEATABLE READ) 串行化(SERIALIZABLE) 在MySQL中,锁可以分为两类 共享锁: 共享锁定是将对象数据变为只读形式,不能进行更新,所以也成为读取锁定 排它锁: 排它锁定时当执行INSERT/UPDATE/DELETE的时候,其他事务不能读取该数据 锁定粒度: 锁定对象的大小是锁的粒度 记录 表 数据库 一致性是通过原子性,持久性,隔离性来实现的 ","date":"2022-01-15","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:0:4","tags":["MySQL","事务"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["框架"],"content":"5. 故障及故障恢复 事务的执行流程如下 系统会为每个事务开辟一个私有工作区 事务读操作将从磁盘中拷贝数据项到工作区,在执行写操作前所有的更新都作用于工作区中的拷贝 事务的写操作将把数据输出到内存的缓冲区中,等到合适的时间在由缓冲区管理器将数据写入到磁盘 由于数据库存在立即修改和延迟修改,所以在事务执行过程中可能存在以下情况: 在事务提交前出现故障,但是事务对数据库的部分修改已经写入磁盘数据库中,这导致了事务的原子性被破坏 在系统崩溃前事务已经提交,但数据还在内存缓冲区中,没有写入磁盘.系统恢复时将丢失此次已提交的修改.这是对事务持久性的破坏 撤销事务undo: 将事务更新的所有数据项恢复为日志中的旧值 重做事务redo: 将事务更新的所有数据项恢复为日志中的新值 事务正常回滚/因事务故障中止将进行redo 系统从崩溃中恢复时将先进行redo在进行undo ","date":"2022-01-15","objectID":"/mysql%E4%BA%8B%E5%8A%A1/:0:5","tags":["MySQL","事务"],"title":"MySQL事务","uri":"/mysql%E4%BA%8B%E5%8A%A1/"},{"categories":["数据库"],"content":"1. NoSQL数据库概述 NoSQL泛指非关系型数据库.NoSQL不依赖业务逻辑方式存储,而已简单的key_value模式存储.因此大大增加了数据库的拓展能力; 不遵循SQL标准 不支持ACID 远超于SQL的性能 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:0:1","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"2. NoSQL使用场景 对数据高并发的读写 海量数据的读写 对数据高可拓展性的 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:0:2","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"3. NoSQL不适用场景 需要事务支持 基于sql的结构查询存储,处理复杂的关系,需要即席查询 用不着sql和用了sql也不行的情况,考虑用NoSQL ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:0:3","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"4. 常见NoSQL数据库 Memcache Redis MongoDB ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:0:4","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"2. Redis概述安装 Redis是一个开源的key-value存储系统 和Memcached类似,他支持存储的value类型相对更对,包括string,list,set,zset(sorted set–有序集合)和hash 这些数据类型都支持push/pop add/remove及取交集并集和差集及更丰富的操作,而且这些操作都是原子性的; 在此基础上,Redis支持各种不同方式的排序 与memcached一样,为了保证效率,数据都是缓存在内存中. 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的几率文件; 并且在此基础上实现了master-slave(主从)同步; 1. redis安装 1. 安装目录: /usr/local/bin 查看默认安装目录: redis-benchmark: 性能检测工具,可以在自己本子运行,看看自己本子性能如何 redis-check-aof: 修复有问题的AOF文件,rdb和aof后面讲 redis-check-rdb: 修复有问题的dump.rdb文件 redis-sentinel: Redis集群使用 redis-server: Redis服务器启动命令 redis-cli: 客户端,操作入口 2. 后台启动(前台启动不推荐) 备份redis.conf 文件 sudo cp redis.conf /etc/redis.conf ,将redis.conf里面的daemonize no改成yes redis-server /etc/redis.conf 客户端访问:redis-cli 2. Redis 相关知识介绍 默认16个数据库,类似数组下标从0开始,初始默认使用0号库 使用命令 select index 来切换数据库 ,例如select 7 同一密码管理,所有库相同密码 dbsize: 查看当前数据库的key数量 flushdb: 清空当前库 flushall: 通杀全部库 Redis是单线程+多路IO复用技术.与Mencache三点不同: 支持多数据类型,支持持久化,单线程+多路IO复用 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:1:0","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"3. 常用5大数据类型 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:2:0","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"1. Redis键(key) keys * : 查看当前库所有key exists key: 判断某个key是否存在 type key: 查看你的key是什么类型 del key: 删除指定key数据 unlink key: 根据value选择非阻塞删除 (仅将keys从keyspace元数据中删除,真正的删除会在后续异步操作) expire key 10 : 10秒钟: 为给定的key设置过期时间 ttl key: 查看还有多少, -1表示永不过期,-2表示过期 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:2:1","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"2. Redis字符串 1. 简介 String是Redis最基本的类型,可以理解成与Memcacahed一样的类型,一个key对应一个value String类型是二进制安全的,以为这Redis的String可以包含任何数据,比如jp图片或者序列化的对象 String类型是Redis最基本的数据类型,一个Redis中字符串value最多可以是512M 2. 常用命令 set key value : 添加键值对 get key: 查询对应键值 append key value: 将给定的value追加到原值的末尾 strlen key: 戳去值的长度 setnx key value: 只有在key不存在是,设置key的值 incr key: 将key中存储的数字增1,只能对数字值操作,如果为空,新值值为1 decr key: 将key中存储的数字减1,只能对数字值操作,如果为空,新值值为-1 incrby/decrby key 步长 : 将key中存储的数字值增减.自定义步长 mset key1 value1 key2 value2: 设置多个键值对 mget key1 key2 key3: 查询多个对应键值 getrange key 起始位置 结束位置: 获得值的范围 setrange key 起始位置 value: 用value覆写key所存储的字符串值,从起始位置开始 setex key 过期时间 value: 设置键值的同时,设置过期时间,单位秒 getset key value: 以新换旧,设置了新值同时获得旧值 原子性: 所谓原子操作是指不会被线程调度机制打断的操作; 这种操作一旦开始,就一直运行到结束,中间不会有任何context switch(切换到另一个线程) 在单线程中,能够在单挑指令中完成的操作都可以认为是原子操作,因为终端只发生在指令之间 在多线程中,不能被其他进程打断的操作就叫原子操作,Redis单命令的原子性主要得益于Redis的单线程 3. 数据结构 String的数据结构为简单动态字符串,是可以修改的字符串,颞部结构实现上类似java的ArrayList,.采用预分配冗余空间的 方式来减少内存的频繁分配; 如图所示,内部为当前字符串实际分配的空间capacity一般要高于时间字符串长度 len.当字符串长度小于1M时,扩容都是加倍现有空间,如果超过1m,扩容时一次智慧多扩1M的空间,需要注意的是字符串崔大长度为512M ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:2:2","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"2. Redis列表(List) 1. 简介(单列多值) Redis列表是简单的字符串列表,按照插入顺序排序,你可以添加一个元素到列表的头部或者尾部 他的底层实际是一个双向链表,对两端的操作性能很高,通过索引下标的操作中间的就节点性能较差 问题: 列表插入出错 强制停止redis快照导致，redis运行用户没有权限写rdb文件或者磁盘空间满了 2. 常用命令 lpush/rpush key value1 value2.. : 从左边/右边插入一个或多个值 lpop/rpop key : 从左边/右边吐出一个值.值在键在,值光键亡 rpoplpush key1 key2 : 从key1列表右边吐出一个值,插入到key2列表的左边 lrange key start stop: 参照索引下标获得元素(从左到右,0 -1表示所有) lindex key index: 按照索引下标获得元素(从左到右) llen key: 获得列表长度 linsert key before/after value (new value): 在value的后面插入newvalue lrem key n value: 从左边删除n个value(从左到右) lset key index value: 将列表key下标为index的值替换成value 3. 数据结构 Lisst的数据结构为快速链表qucikList 首先在列表元素较少的情况下会使用一块连续存储的内存存储,这个结构是ziplist,也就是压缩列表; 他将所有的元素紧挨着一起存储,分配的是一块连续的内存,当数据量比较多的时候才会改成quicklist; 因为普通的链表需要的附加指针空间太大,会比较浪费空间;比如这个列表里村的只是int类型的数据,结构上还需要两个额外的指针prev和next; ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:2:3","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"3. Redis集合(Set) 1. 简介 Redis Set对外提供的功能与list类似是一个列表的功能,特殊之处在于set是可以自动排重的,当你需要存储一个列表数据,又不希望出现重复数据时,set是一个很好的选择; set提供了判断某个成员是否在一个set集合的重要接口,这个也是list没有的; Redis的Set是string类型的无序集合,底层是一个value为null的hash表,所以添加,删除,查找的复杂度都是O(1); 2. 常用命令 sadd key value1 value2: 将一个或多个member元素加入到集合key中,已经存在的member元素将被忽略 smembers key: 取出该集合的所有值 sismember key value : 判断集合key是否为含有该value值,有1,没有0 scard key : 返回该 集合的元素个数 srem key value1 value2: 删除集合中的某个元素 spop key: 随机从该集合中吐出一个值 srandmember key n: 随机从该集合中取出n个值,不会从集合中删除 smove value : 把集合中一个值从一个集合移动到另一个集合 sinter key1 key2: 返回两个集合的交集元素 sunion key1 key2: 返回两个集合的并集元素 sdiff key1 key2 : 返回两个集合的差集元素(key1中的,不包含key2中的) 3. 数据结构 Set数据结构是dict字典,字典是用哈希表实现的; Java中的HashSet的每部实现使用的是HashMap,只不过所有的value都指向同一个对象 Redis的set结构也是一样,他的内部也使用hash结构,所有的value都直线沟通一个内部值; 2. 常用命令 hset key field value给key:集合中的field键复制value hget key field : 从key集合field取出value hmset key1 field1 value1 field2 value2: 批量设置hash的值 hexists key1 fidld: 查看哈希表key中,给定域field是否存在 hkeys key: 列出该hash集合的所有field hvals key: 列出该hash集合的所有value hincrby key fidld increment: 为哈希表key中的域field的值加上增量 hsetnx key field value : 将哈希表key中的域 field的值设置为value(当且仅当field不存在) ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:2:4","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"4. Redis有序集合Zset(sorted set) 1. 简介 Redis有序集合zset与普通集合set非常相似,是一个没有重复元素的字符串集合. 不同之处是有序集合的每个成员都关联一个评分score,这个评分被用来按照从最低分到最高分的方式排序集合中的成员.集合的成员是唯一的,但是评分可以是重复的 因为元素是有序的,所有你也可以很快的根据评分或者次序来获取一个范围的元素 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的只能列表 2. 常用命令 zadd key score1 value1 score2 value2 : 将一个或多个member元素及其score值加入到有序集key当中 zrange key start stop (withscores): 返回有序集key中,下标在start stop之间的元素,逮withscores,可以让分数一起和值返回到结果集 zrangebyscore key minmax (withscores) (limit offset count): 返回有序集key中,所有score值结余min和max之间(包括等于min或max的成员).有序集成员按score值递增次序排列 zrevrangebyscore key maxmin (withscores ) (limit offset count):同上,改为从大到小排列 3. 数据结构 SortedSet(zset)是Redis提供的一个非常忒别的数据结构,一方面他等价于java的数据结构map,可以给每个元素value 赋予一个权重score,另一方面他又类似于treeset,内部的元素会按照权重score进行排序,可以得到每个元素的名次,还可以通过score的范围来获取元素的列表 zset底层使用两个数据结构 hash,hash的作用就是关联元素value和权重score,保障元素value的唯一性,可以通过元素value找到相应的score值 跳跃表,跳跃表的目的在于给元素value排序,根据score的范围获取元素列表 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:2:5","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"4. Redis 配置文件介绍 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:3:0","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"1. ###Units单位### 配置大小单位,开头定义了一些基本的度量单位,只支持bytes,不支持bit ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:3:1","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"5.Redis的发布和订阅 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:4:0","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"5.1 什么是发布和订阅 Redis发布订阅是一种消息通信模式: 发送者发送消息,订阅者接受消息 Redis客户端可以订阅任意数量的频道 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:4:1","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"5.2 Redis的发布和订阅 注: 发布的消息没有持久化,如果在订阅的客户端收不到,只能收到订阅后发布消息 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:4:2","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"6. Redis新数据类型 ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:5:0","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"6.1 简介 Redis提供了Bitmaps这个\"数据类型\" 可以实现对位的操作: Bitmaps本身不是一种数据类型,实际上它就是字符串,但是他可以对字符串的位进行操作; Bitmaps单独提供一套命令,所以在Redis中使用Bitmaps和使用字符串的方法不太相同.可以把Bitmaps想象成一个以位为单位的数组,数组的每个的那位只能存储0和1,数组的下标在Bitmaps中叫做偏移量; ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:5:1","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"6.2 命令 setbit setbit 设置Bitmaps中某个偏移量的值(0或1) offset:偏移量从0开始 getbit getbit 获取某个偏移量的值 获取键的第offset位的值(从0开始计算) bittop ","date":"2021-07-02","objectID":"/redis%E5%9F%BA%E7%A1%80/:5:2","tags":["Redis"],"title":"Redis基础","uri":"/redis%E5%9F%BA%E7%A1%80/"},{"categories":["操作系统"],"content":"Linux ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:0:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"1. Linux的应用领域 服务器领域 linux在服务器领域的应用是最强的; linux免费,稳定,高效等特点在这里得到了很好的提现,尤其砸一些高端领域尤为广泛(c/c++/php/java/python/go); 嵌入式领域 linxu运行稳定,对网络的良好支持性,低成本,且可以根据需要进行软件裁剪,内核最小可以达到几百KB等特点,使其近年来在嵌入式领域的应用得到非常大的提高 主要应用: 机顶盒,数字电视,网络电话,程控交换机,手机,智能家居 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:1:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"2. Linux介绍 Linux是一个开源,免费的操作系统,其稳定性,安全性,处理多并发已经得到业界的认可,目前很多企业级的项目都会部署到linux服务器上; Linux Linux之父: Linus Torvalds Git创作者,世界著名黑客 Linux主要的发行版: Ubuntu ,RedHat ,CentOS ,Debain ,Fedora ,SuSE ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:2:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"3. Linux目录结构 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"1. 基本介绍 linux的文件系统是采用层级式的目录结构,在此结构中的最上层是根目录\"/\",然后再此目录下载创建其他的目录; 深刻理解linux梳妆目录是非常重要的,这里我给大家说明一下; 记住一句经典的话: 在Linux世界里,一切皆为文件! ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:1","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"2. 具体目录结构 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:3:2","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"4. 远程登录Linux ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:4:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"1. 为什么要远程登录 Linux服务器是开发小组共享 正式上线的项目是运行在公网 因此程序员需要远程登录到Linux进行项目管理或者开发 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:4:1","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"5. Vim快捷键 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:5:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"6. 关机\u0026重启命令 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"1. 基本介绍 shutdown -h now : 立刻进行关机 shutdown -h 1: 一分钟后关机 shutdown -r now : 现在重新启动计算机 halt: 关机,作用和上面一样 reboot: 现在重新启动计算机 sync: 把内存的数据同步到磁盘 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:1","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"2. 注意细节 不关事重启系统还是关闭系统,首先要运行sync命令,把内存中的数据写到磁盘中; 目前的shutdown/reboot/halt等命令均已经在关机前进行了sync; ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:6:2","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"7. 用户登录和注销 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"1. 基本介绍 登录时尽量少用root账号登录,因为他是系统管理员,最大的权限,避免操作失误;可以利用普通用户登录,登录后在\"su - 用户名\"命令来切换成系统管理员身份; 在提示符下输入logout即可注销用户 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:1","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"2. 使用细节 logout注销指令在图形运行级别无效,在运行级别3下有效; ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:7:2","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"8. 用户管理 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"1. 基本介绍 Linux系统是一个多用户多任务的操作系统,任何一个要使用系统资源的用户,都必须首先向系统管理员申请一个账号,然后以这个账号的身份进入系统 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:1","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"2. 添加用户 基本语法: useradd 用户名 细节说明: 当创建用户成功后,会自动的创建和用户同名的家目录 也可以通过useradd -d 指定目录 新的用户名,给新创建的用户指定家目录 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:2","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"3. 指定/修改密码 基本语法: passwd 密码 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:3","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"4. 删除用户 基本语法: userdel 用户名 (保留家目录) ​ userdel -r 用户名 (不保留家目录) ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:4","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"5. 查询用户信息指令 基本语法: id 用户名 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:5","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"6. 切换用户 基本语法: su - 用户名 细节说明: 从权限高的用户切换到权限低的用户,不需要输入密码,反之需要; 当需要返回到原来用户时,使用exit/logout指令; ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:6","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"7. 用户组 1. 介绍 类似于角色,系统可以对有共性的多个用户进行同一的管理 2. 新增组 指令: groupadd 组名 3. 删除组 指令: groupdel 组名 4. 增加用户时直接加上组 指令: useradd -g 用户组 用户名 5. 修改用户的组 指令: usermod -g 用户组 用户名 6. 用户和组相关文件 /etc/passwd 文件 用户(user)的配置文件,记录用户的各种信息 每行的含义: 用户名:口令: 用户标识号(uid):组标识号(gid) /etc/shadow文件 口令的配置文件 每行的含义: 登录名:加密口令:最后一次修改的时间:最小时间间隔:警告时间:不活动时间:失效时间:标志 /etc/group文件 组(group)的配置文件,记录Linux包含的组的信息 每行的含义:组名:口令:组标识号:组内用户列表 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:8:7","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"9. 实用指令 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:10:0","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"1. 指定运行级别 1. 基本介绍 运行级别说明: 0:关机 1: 单用户(找回丢失密码) 2: 多用户状态没有网络服务 3: 多用户状态有网络服务 4: 系统未使用保留给用户 5: 图形界面 6: 系统重启 常用运行级别是3和5 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:10:1","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"2. 帮助指令 man获得帮助信息 基本语法: man[命令或配置文件] 在linux下,隐藏文件是以.开头,选项可以组合使用 比如 ls -al help指令 基本语法: help 命令(功能描述:获得shell内置命令的帮助信息) ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:10:2","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"3. 文件目录类 mkdir指令:用于创建目录 基本语法: mkdir [选项] 要创建的目录 常用选项: -p: 创建多级目录; rmdir指令: 删除空目录 基本语法: rmdir [选项] 要删除的空目录 使用细节: rmdir删除的是空目录,如果目录下由内容时无法删除 ​ 如果需要删除非空目录,需要使用rm -rf 要删除的目录 touch指令:创建空文件 基本语法: touch 文件名 cp指令:拷贝文件到指定目录 基本语法:cp [选项] source dest 常用选项: -r 递归复制整个文件夹 rm指令: 移除文件或目录 基本语法: rm [选项] 要删除的文件或目录 常用选项: -r:递归删除整个文件夹 ​ -f:强制删除不提示 mv指令:移动文件与目录或重命名 基本语法: mv oldNameFile newNameFile(重命名) ​ mv /temp/movefile /targetFolder(移动文件) cat指令:查看文件内容 基本语法: cat [选项] 要查看的文件 常用选项:-n: 显示行号 more指令:是一个基于VI编辑器的文本过滤器,他以全屏幕的方式按页显示文本文件的内容.more指令中内置了若干快捷键; 基本语法: more 要查看的文件 less指令:用来分屏查看文件内容,他的功能与more指令类似,但是比more指令更加强大,支持各种显示终端;less指令在显示文件内容时,并不是一次整个文件加载之后才显示,而是根据显示需要加载内容,对于显示大型文件具有较高的效率; 基本语法: less 要查看的文件 echo指令:输出内容到控制台 基本语法:echo [选项] [输出内容] head指令:用于显示文件的开头部分内容,默认情况下head指令显示文件的前十行内容 基本语法: head 文件 (查看文件头10行内容) ​ head -n 5 文件:查看文件头5行内容,5可以是任意行数 tail指令:用于输出文件中尾部的内容,默认情况下tail指令显示文件的后10行内容 基本语法: tail 文件(查看文件尾10行内容) tail -n 5 文件(查看文件尾5行内容) tail -f 文件 (实时追踪该文档的所有更新) ln指令:软链接也成为符号链接,类似于windows里的快捷方式,主要存放了链接其他文件的路径 基本语法: ln -s [源文件或目录] [软链接名] (给源文件创建一个软链接) 细节说明: 当我们使用pwd 指令查看目录时,仍然看到的是软链接所在的目录 history指令: 查看已经执行过历史命令.也可以执行历史命令 基本语法: history(查看已经执行过历史命令) ​ history 10 :查看最近的10条命令 ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:10:3","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"4. 时间日期类 1. date指令: 显示当前日期 基本语法 date (显示当前时间) date + %Y (显示当前年份) date + %m (显示当前月份) date + %d (显示当前是哪一天) date “+%Y -%m -%d %H:%M:%S” (显示年月日时分秒) 2. date指令-设置日期 基本语法 date -s 字符串时间 3. cal指令:显示日历 基本语法 cal [选项] (不加选项,显示本月日历) ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:10:4","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"4. 搜索查找类 1. find指令: 从指定目录向下递归遍历其各个子目录,将满足条件的文件或者目录显示在终端 基本语法: find [搜索范围] [选项] 选项说明: 2. locate指令: 可以快速定位文件路径;locate指令利用事先建立的系统中的所有文件名称及路径的locate数据库实现快速定位给定的文件;locate指令无序遍历整个文件系统,查询速度较快,为了保证查询结果的准确度,管理员必须定期更新locate时刻; 基本语法: lcoate 搜索文件 特别说明: 由于locate指令基于数据库进行查询,所以第一次运行前,必须使用updatedb指令创建locate数据库; 3. grep指令和管道符号 | : grep过滤查找,管道符,\"|\" ,表示将前一个命令处理结果输出传递给后面的命令处理; 基本语法: grep [选项] 查找内容 源文件 常用选项: ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:10:5","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["操作系统"],"content":"5. 压缩和解压类 1. gzip/gunzip指令: gzip用于压缩文件,gunzip用于解压的 基本语法: gzip 文件 (压缩文件,只能将文件压缩为*.gz文件) gunzip 文件.gz (解压缩文件命令) 2. zip/unzip指令: zip用于压缩文件,unzip用于解压的,这个在项目打包发布中很有用的 基本语法: zip [选项] xxx.zip 将要压缩的内容 (压缩文件和目录的命令) unzip [选项] xxx.zip (解压缩文件) zip常用选项 -r :递归压缩,即压缩目录 unzip常用选项 -d \u003c目录\u003e : 指定解压后文件的存放目录 3. tar指令: 是打包指令,最后打包后的文件时间.tar.gz的文件 基本语法: tar [选项] xxx.tar.gz 打包的内容 (打包目录,压缩后的文件格式. tar.gz) ","date":"2021-06-02","objectID":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/:10:6","tags":["Linux"],"title":"Linux基本命令","uri":"/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"categories":["JavaSE"],"content":"1. 文件 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:1:0","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"1. 什么是文件? 保存数据的地方 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:1:1","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"2. 文件流 文件在程序中是以流的形式来操作的 流: 数据在数据源(文件)和程序(内存)之间经历的路径 输入流: 数据从数据源(文件)到程序(内存)的路径 输出流: 数据从程序(内存)到数据源(文件)的路径 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:1:2","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"3. 常用文件操作 new File(String pathname) //根据路径创建一个File对象 new File(File parent,String child) //根据父目录文件+子路径创建 new File(String parent,String child) //根据父目录+子路径构建 createNewFile 创建文件 getName,getAbsoutePath,getParent,length,exists,isFile,isDirectory mkdir:创建一级目录,mkdirs: 创建多级目录,delete:删除空目录或文件 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:1:3","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"2. IO流原理及流的分类 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:2:0","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"1. io流原理 I/O是input/output的缩写,I/O技术是非常实用的技术,用于处理数据传输,如读写文件,网络通信等; java程序中,对于数据的输入/输出操作以流(stream)的方式进行; java.io包下提供各种\"流\"类和接口,用以获取不同种类的数据,并通过方法输入或输出数据; 输入input:读取外部数据(磁盘,光盘等存储设备的数据)到程序(内存)中; 输出output:将程序数据输出到磁盘,光盘等存储设备中; ","date":"2021-04-02","objectID":"/io%E6%B5%81/:2:1","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"2. 流的分类 按操作数据单位不同分为: 字节流(8bit) 二进制文件,字符流(按字符) 文本文件; 按数据流的流向不同分为: 输入流,输出流 按流的角色的不同分为: 节点流,处理流/包装流 java的IO流共设计40多个类,实际上非常规则,都是从如上4个抽象基类派生的. 由这四个类派生出来的子类名称都是以其父类作为子类名后缀; ","date":"2021-04-02","objectID":"/io%E6%B5%81/:2:2","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"3. IO流常用的类 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:3:0","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"1. FileInputStream/FileOutStream ","date":"2021-04-02","objectID":"/io%E6%B5%81/:3:1","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"2. FileReader/FileWriter 是字符流,按照字符来操作io FileReader相关方法: new FileReader(File/String) read: 每次读取单个字符,返回该字符,如果到文件末尾返回-1; read(char[]): 批量读取多个字符到数组,返回读取到的字符数,如果到文件末尾返回-1; new String(char[]): 将char[]转换成String new String(char[],off,len): 将char[]的指定部分转换成String FileWriter相关方法: new FileWriter(File/String): 覆盖模式,相当于流的指针在首端 new FileWriter(File/String,true): 追加模式,相当于流的指针在末尾 write(int) : 写入单个字符 write(char[]):写入指定数组 write(char[],off,len): 写入指定数组的指定部分 write(string):写入整个字符串 write(string,off,len): 写入字符串的指定部分 toCharArray:将String转换成char[] 注意:FileWriter使用后,必须要关闭或刷新,否则写入不到指定的文件 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:3:2","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"3. 节点流和处理流 1. 基本介绍 节点流可以从一个特定的数据源读写数据,如FileReader,FileWriter 处理流(也叫包装流)是\"连接\"在已存在的流(节点流或处理流)之上,为程序提供更为强大读写功能,如BufferedReader,BufferedWreter 2. 节点流和处理流的区别和联系 节点流是底层流/低级流,直接跟数据源相接; 处理流(包装流)包装节点流,既可以消除不同节点流的实现差异,也可以提供更方便的方法来完成输入输出; 处理流对节点流进行包装,使用了修饰器设计模式,不会直接与数据源相连; 3. 处理流的功能主要提现在以下两个方面: 性能的提高: 主要以增加缓冲的方式来提高输入输出的效率; 操作的编写: 处理流可以提供一系列便捷的方法来一次输入输出大批量的数据,使用更加灵活方便; 4. 处理流-BufferedReader和BufferedWriter BufferedReader和BufferedWriter属于字符流,是按照字符来读取数据的; 关闭时,只需要关闭外层流即可; 5. 处理流-BufferedInputStream和BufferedOutputStream BufferedInputStream是字节流,在创建BufferedInputStream时,会创建一个内部缓冲区数组; 6. 对象流-ObectInputStream和ObjectOutputStream 序列化和反序列化 序列化就是在保存数据时,保存数据的值和数据类型 反序列化就是在恢复数据时,恢复数据的值和数据类型 需要让某个对象支持序列化机制,则必须让其类是可序列化的,为了让某个类是可序列化的,该类必须实现如下两个接口之一; Serializable //这是标记接口,没有方法 Externalizable //该接口有方法实现,所以一般使用Serializable 1. 基本介绍 功能: 提供了对基本类型或对象类型的序列化和反序列化的方法 ObjectOutputStream提供序列化功能 ObjectInputStream提供反序列化功能 调用对象的方法,需要向下转型 2. 注意事项和细节说明 读写顺序要一致 要求序列化或反序列化对象,需要实现Serializable 序列化的类中建议添加SerialVersionUID,为了提高版本的兼容性,private static final long serialVersionUID=1L; 序列化对象时,默认将里面所有属性都进行序列化,但除了static或transient修饰的成员 序列化对象时,要求里面属性的类型也需要实现序列化接口 序列化具备可继承性,也就是如果某类已经实现了序列化,则他的所有子类也已经 默认实现了序列化 7. 标准输入输出流 1. 介绍 2. System.in 编译类型 InputStream 运行类型 BufferedInputStream 标准输入 :键盘 3. System.out 编译类型 ,运行类型 PrintStream 8. 转换流-InputStreamReader和OutputStreamWriter 1. 介绍 InputStreamReader: Reader的子类,可以将InputStream(字节流)包装成(转换成)Reader(字符流) OutputStreamWriter: Writer的子类,实现将OutputStream(字节流)包装成Writer(字符流) 当处理纯文本数据时,如果使用字符流效率更高,并且可以有效解决中文问题,所以讲义将字节转换成字符流 可以在使用时指定编码格式(比如utf-8,gbk,gb2312) 9. 打印流-PrintStream和PrintWriter ","date":"2021-04-02","objectID":"/io%E6%B5%81/:3:3","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"3. Properties类 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:4:0","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["JavaSE"],"content":"1. 基本介绍 专门用于读写配置文件的集合类 配置文件的格式: 键=值 注意: 键值对不需要有空格,值不需要用引号,默认类型是String Properties的常见方法 load: 加载配置文件的键值对到Properties对象 list: 将数据显示到指定设备 getProperty(key): 根据键获取值 getProperty(key,value): 设置键值对到Properties对象 store: 将Properties中的键值对存储到配置文件,在idea中,保存信息到配置文件,如果含有中文,会存储为unicode码 ","date":"2021-04-02","objectID":"/io%E6%B5%81/:4:1","tags":["IO流"],"title":"IO流","uri":"/io%E6%B5%81/"},{"categories":["算法与数据结构"],"content":"1. comparable接口 代码测试: package Sort.comparable; public class student implements Comparable\u003cstudent\u003e{ private String username; private int age; public student() { } public student(String username, int age) { this.username = username; this.age = age; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"student{\" + \"username='\" + username + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(student o) { return this.getAge()-o.getAge(); } } package Sort.comparable; public class comparableTest { //创建两个对象 public static void main(String[] args) { student s1 = new student(); student s2 = new student(); s1.setUsername(\"张三\"); s1.setAge(15); s2.setUsername(\"李四\"); s2.setAge(17); Comparable max = getMax(s1, s2); System.out.println(max); } public static Comparable getMax(Comparable c1,Comparable c2){ int result = c1.compareTo(c2); if (result\u003e=0){ return c1; }else { return c2; } } } ","date":"2021-02-18","objectID":"/sort/:0:1","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"2. 冒泡排序 排序原理: 比较相邻的元素,如果前一个元素比后一个元素大,就交换这两个元素; 对每一对相邻的元素做同样的工作,从开始第一对元素到结尾的最后一个元素;最终最后位置的元素就是最大值; 代码实现: /*冒泡排序*/ public class MyBubble { public static void sort(Comparable[] a ){ for (int i = a.length; i \u003e0 ; i--) { for (int j = 0; j \u003c i; j++) { //比较两个索引处的大小 if (greater(a[j],a[j])){ exchange(a,j,j+1); } } } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MyBubbleTest { public static void main(String[] args) { Integer[] arr={1,4,6,7,2,9}; MyBubble.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:2","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"3. 选择排序 排序原理: 每一次遍历的过程中,都假定第一个索引处的元素是最小值,和其他索引处的值一次进行比较,如果当前索引处的值大于其他某个索引处的值,则假定其他某个索引处的值为最小值,最后可以找到最小值所在的索引; 交换第一个索引处和最小值所在的索引处的值; 代码实现: public class MySelection { public static void sort(Comparable [] a){ for (int i = 0; i \u003c= a.length - 2; i++) { int minIndex=i; for (int j = i+1; j \u003c a.length; j++) { if (greater(a[minIndex],a[j])){ minIndex=j; } } exchange(a,i,minIndex); } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MySelectionTest { public static void main(String[] args) { Integer[] arr={1,4,6,5,9,7}; MySelection.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:3","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"4. 插入排序 原理: 把所有的元素分为两组,已经排序的和未排序的; 找到未排序的组中的第一个元素,向已经排序的组中进行插入; 倒叙遍历已经排序的元素,一次和待插入的元素进行比较,知道找到一个元素小于等于待插入元素,那么就把待插入元素放到这个位置,其他元素向后移动一位; 代码实现: /*插入排序*/ public class MyInsertion { public static void sort(Comparable[] a){ for (int i = 1; i \u003c a.length; i++) { for (int j = i; j \u003e=0 ; j--) { if (greater(a[j-1],a[j])){ exchange(a,j,j-1); }else { break; } } } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MyInsertionTest { public static void main(String[] args) { Comparable[] arr={1,4,6,8,9,3,6,8}; MyInsertion.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:4","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"5. 希尔排序 排序原理: 选定一个增长量h,按照曾长量h作为数据分组的依据,对数据进行分组; 对分好组的每一组数据完成插入排序; 减小曾长量,最小减为3,重复第二步操作; 增长量h的确定(没一固定的原则): int h=1; while(h\u003cleng/2){ h=2*h+1; } //循环结束后我们就可以确定h的最大值; h的减小规则为: h=h/2 代码实现: public class MyShell { public static void sort(Comparable[] a){ //得到曾长量h的值 int h=1; while(h\u003ca.length/2){ h=h*2+1; } while (h\u003e=1){ //找到待插入的元素 for (int i = h; i \u003ca.length ; i++) { //把待插入的元素插入到有序序列中 for (int j = i; j \u003e=h ; j-=h) { if (greater(a[j-h],a[j])){ exchange(a,j-h,j); }else { //待插入元素找到合适位置,结束循环 break; } } } //减小曾长量h h=h/2; } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MyShellTest { public static void main(String[] args) { Comparable[] arr={1,5,8,9,5,8,5,9,45,67,23,7}; MyShell.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:5","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"6. 归并排序 排序原理: 尽可能的一组数据拆分成两个元素的子组,并对每一个子组继续拆分,知道拆分后的每个子组的元素个数是1为止; 将相邻的两个子组进行合并成一个有序的大组; 不断的重复步骤2,知道最终只有一个组为止; 归并排序API设计: 类名 Merge 构造方法 Merge():创建Merge对象 成员方法 1.public static void sort(Comparable[] a):对组内元素进行排序 2. private static void sort(Comparable[] a ,int left,int right):对组内索引lo到索引hi的元素进行排序 3.private static void merge(Comparable[] a ,int left,int mid,int right):从索引left到索引mid为一个子组,从索引mid+1到索引right为另一个子组,吧数组a中的这两个子组的数据合并成一个有序的大组(从索引leftPos到索引rightPos) 4.private static boolean less(Comparable v,Comparable w):判断v是否小于w 成员变量 1.private static Comparable[] assist:完成归并操作需要的辅助数组 代码实现: package Sort.merge; public class MyMerge { //归并所需要的辅助数组 private static Comparable[] assist; //比较a是否小于b public static boolean less(Comparable v,Comparable w){ return v.compareTo(w)\u003c=0; } //对数组a中的元素进行排序(private递归型方法sort的驱动程序) public static void sort(Comparable[] a){ //初始化辅助数组 assist = new Comparable[a.length]; int left=0; int right=a.length-1; sort(a,left,right); } //对数组a中lo到hi的元素进行排序 private static void sort(Comparable[] a,int left,int right){ //安全性检验 if(right\u003c=left) return; int mid=(left+right)/2; sort(a,left,mid); sort(a,mid+1,right); merge(a,left,mid+1,right); } /*对数组中,从lo到mid为一组,mid+1到hi为一组, leftPos,rightPos分别记录左右两数组中的开始位置,rightEnd记录最后的位置*/ private static void merge(Comparable[]a ,int leftPos,int rightPos,int rightEnd){ //记录左边数组的最后位置 int leftEnd=rightPos-1; //记录辅助数组的位置 int assistPos=leftPos; //当左右数组都还有元素 while (leftPos\u003c=leftEnd \u0026\u0026 rightPos\u003c=rightEnd) //判断元素大小 if (less(a[leftPos],a[rightPos])) assist[assistPos++]=a[leftPos++]; else assist[assistPos++]=a[rightPos++]; //当左数组没有元素时 while (rightPos\u003c=rightEnd) assist[assistPos++]=a[rightPos++]; //当右数组没有元素时 while (leftPos\u003c=leftEnd) assist[assistPos++]=a[leftPos++]; //拷贝回原数组 for (int i = 0; i \u003c rightPos; i++,rightEnd--) { a[rightEnd]=assist[rightEnd]; } } } 测试代码: package Sort.merge; import java.util.Arrays; public class MyMergeTest { public static void main(String[] args) { Comparable[] arr={3,4,5,7,9,7,4,9,32,45,33,55,33}; MyMerge.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:6","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"7. 快速排序 排序原理: 首先设定一个分界值,通过该分界值将数组分成左右两个部分; 将大于或等于分界值的数据放到数组右边,小于分界值的数据放到数组的左边,此时左边部分中各元素都小于分界值,而右边部分中各元素都大于或等于分界值; 然后,左边和右边的数据可以独立排序.对于左侧的数组数据,又可以取一个分界值,将该部分数据分成左右两个部分,同样在左边放置较小值,右边放置较大值.右侧的数组数据也可以做类似处理; 重复上述过程,可以看出,这是一个递归定义.通过递归将左侧部分拍好序,在递归排好右边部分的顺序,当左侧和右侧两个部分的数据排完序后,整个数组的排序也就完成了; 快速排序API设计: 类名 Quick 构造方法 Quick():创建Quick对象 成员方法 1.public static void sort(Comparable[] a):对组内元素进行排序 2. private static void sort(Comparable[] a ,int left,int right):对组内索引lo到索引hi的元素进行排序 3.private static int partition(Comparable[] a ,int left , int right):对数组a中,从索引left到索引right进行分组,并返回分组界限对应的索引 4.private static boolean less(Comparable v,Comparable w):判断v是否小于w 切分原理: 一个数组气氛成两个子数组的基本思想: 找一个基准值,用两个指针分别指向数组的头部和尾部; 先从尾部向头部开始搜索一个比基准值小的元素,搜索到即停止,并记录指针的位置; 再从头部向尾部开始搜索一个比基准值大的元素,所有到即停止,并记录指针的位置; 交换当前左边指针位置和右边指针位置的元素; 重复2,3,4步骤,知道左边指针的值大于右边指针的值停止; 代码实现: public class MyQuick { public static void sort(Comparable[] a){ int left=0; int right=a.length-1; sort(a,left,right); } //对数组索引left到right进行排序 private static void sort(Comparable [] a,int left,int right){ if (right\u003cleft){ return; } //对数组索引left到right之间的元素进行分组(左子组,右子组) int partition = partition(a, left, right);//返回的是变化后的分界值索引 //让左子组有序 sort(a,left,partition-1); //让右子组有序 sort(a,partition+1,right); } //比较a是否小于b public static boolean less(Comparable v,Comparable w){ return v.compareTo(w)\u003c=0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } //对数组a中,索引left到right之间的元素进行分组,并返回分界值对应的索引 public static int partition(Comparable[] a,int left,int right){ //确定分界值 Comparable key=a[left]; //定义两个指针,分别指向切分元素最小索引处和最大索引处的下一个元素 int leftPos=left; int rightPos=right+1; //切分 while(true){ //从右往左扫描,移动rightPos指针,遇到比key小的值就停止 while (less(key,a[--rightPos])){ if (rightPos==left){ break; } } //从左往右扫描,移动leftPos指针,遇到比key大的值就停止 while (less(a[++leftPos],key)){ if (leftPos==right){ break; } } //判断leftPos\u003e=rightPos,如果是,则结束,不是则交换元素 if (leftPos\u003e=rightPos){ break; }else { exchange(a,leftPos,rightPos); } //分界值和相遇的元素交换 } exchange(a,left,rightPos); return rightPos; } } 代码测试: package Sort.quick; import java.util.Arrays; public class MyQuickTest { public static void main(String[] args) { Integer [] arr={6,1,2,7,9,3,4,5,8}; MyQuick.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:7","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["框架"],"content":"1. SpringMVC组件 ","date":"2021-02-02","objectID":"/springmvc/:1:0","tags":["Spring","SpringMVC"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"2. 请求方式 ","date":"2021-02-02","objectID":"/springmvc/:2:0","tags":["Spring","SpringMVC"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"3. 处理器方法的参数 处理器方法可以包含一下四类参数,这些参数会在系统调用时由系统自动赋值,即程序员可在方法内直接使用; HttpServletRequest HttpServletResponse HttpServletSession 请求中所携带的请求参数 ","date":"2021-02-02","objectID":"/springmvc/:3:0","tags":["Spring","SpringMVC"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"3.1 逐个参数接收 逐个接收:请求中的参数名和控制器方法的形参名一样; 接受参数的问题: 参数最好使用包装类型,例如Integer,能接收空值情况,接收的是null post请求中有乱码问题,使用字符集过滤器 ","date":"2021-02-02","objectID":"/springmvc/:3:1","tags":["Spring","SpringMVC"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"3.2 请求中参数名和形参名不一样,使用@RequestParam @RequestParam: 解决名称不一样的问题 属性: value 请求中的参数名称 ​ required: boolean类型的,默认是true ​ true: 请求中必须有此参数 ​ false:请求中可以没有此参数 位置: 在形参定义的前面 ","date":"2021-02-02","objectID":"/springmvc/:3:2","tags":["Spring","SpringMVC"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"3.3 对象接收 对象接收: 在控制器方法的形参是java对象,使用java对象的属性接收请求中的参数值 要求: java对象的属性名和请求中的参数名一样 ","date":"2021-02-02","objectID":"/springmvc/:3:3","tags":["Spring","SpringMVC"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["框架"],"content":"4. SpringMVC执行流程 SpringMVC内部请求的处理过程: 用户发起请求给DispatcherServlet DispatcherServlet把请求(request)交给处理器映射器 处理器映射器:springmvc框架中的对象,需要实现HandlerMapping接口 映射器作用: 从springmvc容器中,获取控制器对象,把找到的控制器和拦截器对象都放到处理器执行链对象中,保存,并返回给中央调度器; DispatcherServlet把获取到的处理器执行链中的控制器对象,交给处理器适配器; 处理器适配器: 是springmvc框架中的实现.实现HandlerAdapter接口 适配器作用: 执行控制器的方法,得到结果ModelAndView; DispatcherServlet把控制器执行结果交给了视图解析器 视图解析器: springmvc中的对象,需要实现ViewResolver接口 视图解析器作用:处理视图的,组成视图的完整路径,能创建View类型的对象; DispatcherServlet调用View类的方法,把Model中的数据放到request作用域; ","date":"2021-02-02","objectID":"/springmvc/:4:0","tags":["Spring","SpringMVC"],"title":"SpringMVC","uri":"/springmvc/"},{"categories":["算法与数据结构"],"content":"1. 二叉查找树 二叉树结点类API的设计: 类名 Node\u003cKey,Value\u003e 构造方法 Node(Key key,Value value,Node left,Node right):创建Node对象 成员变量 1. public Node left:记录左子结点 2. public Node right:记录右子结点 3. public Key key:存储键 4. public Value value:存储值 代码实现: public class Node\u003cKey,Value\u003e { //存储键 public Key key; //存储值 public Value value; //存储左子结点 public Node left; //存储右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) { this.key = key; this.value = value; this.left = left; this.right = right; } } 二叉查找树的API设计 类名 BinaryTree\u003cKey extends Comparable,Vlaue value\u003e 构造方法 BinaryTree():创建BinaryTree对象 成员变量 1. private Node root:记录根结点 2. private int N :记录树中元素的个数 成员方法 1. public void put(Key key,Value value):向书中插入一个键值对 2. private Node put(Node x,Key key,Value value):给指定树x上,添加一个键值对,并返回添加后的新树 3. public Value get(Key key):根据key从书中找出相对应的值 4. private Value get(Node x,Key key):从指定的数x中,找出key对应的值 5. public] void delete(Key key):根据key,删除数中对应的键值对 6. private Node delete(Node x,Key key):删除指定树x上的键为key的键值对,并返回删除后的新树 7. public int size():获取树中元素的个数 二叉查找树实现 如果当前树中没有任何一个结点,则直接把新节点当做根结点使用 如果当前树不为空,则从根结点开始: 如果新结点的key小于当前结点的key,则继续找当前结点的左子节点; 如果新结点的key大于当前结点的key,则继续找当前结点的右子节点; 如果新结点的key等于当前结点的key,则树中已经存在这样的结点,替换该结点的value值即可; 代码实现: //向指定的树x中添加key-value,并返回添加元素后的新树 public Node put(Node x,Key key,Value value){ //如果x子树为空 if (x==null){ //元素个数+1 N++; return new Node(key,value,null,null); } //如果x子树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 x.right = put(x.right, key, value); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 x.left=put(x.left,key,value); }else { //如果key等于x结点的键,则替换x结点的值为value x.value=value; } return x; } 查询方法get实现思想: 从根结点开始: 如果要查询的key小于当前结点的key,则继续寻找当前结点的左子结点; 如果要查询的key大于当前结点的key,则继续寻找当前结点的右子结点; 如果要查询的key等于当前结点的key,则树中返回当前结点的value. 代码实现: //从指定的数x中,查询key对应的值 public Value get(Node x,Key key){ //如果x子树为空 if (x==null){ return null; } //如果x子树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 return get(x.right,key); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 return get(x.left,key); }else { //如果key等于x结点的键,则找到了键为key的结点,返回x结点的value即可 return x.value; } } 删除方法delete的实现思想: 找到被删除结点; 找到被删除结点右子树的最小结点minNode 删除右子树中的最小结点 让被删除结点的左子树称为最小结点minNode的左子树,让被删除结点的右子树称为最小结点minNode的右子树 让被删除结点的父结点指向最小结点minNode 代码实现: //删除指定树中key对应的value,并返回删除后的新树 public Node delete(Node x,Key key){ //如果x树为空 if (x==null){ return null; } //如果x树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 x.right= delete(x.right,key); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 x.left=delete(x.left,key); }else { //元素个数-1 N--; //如果key等于x结点的键,则要删除的结点就是x; //寻找右子树的最小结点 if (x.right==null){ return x.left; } if (x.left==null){ return x.right; } //默认情况记为右子树 Node minNode = x.right; while (minNode.left!=null){ minNode=minNode.left; } //删除右子树中的最小结点 Node n = x.right; while (n.left!=null){ if (n.left.left==null){ n.left=null; }else{ //变换n结点 n=n.left; } } //让x结点的左子树成为minNode的左子树 minNode.left=x.left; //让x结点的右子树成为minNode的右子树 minNode.right=x.right; //让x结点的父结点指向minNode x = minNode; } return x; } 完整代码: public class MyBinaryTree\u003cKey extends Comparable\u003cKey\u003e,Value\u003e { //记录根结点 private Node root; //记录树中元素的个数 private int N; private class Node { //存储键 public Key key; //存储值 private Value value; //存储左子结点 public Node left; //存储右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) { this.key = key; this.value = value; this.left = left; this.right = right; } } //获取树种元素的个数 public int size(){ return N; } //向树中添加元素key-value public void put(Key key, Value value){ root = put(root, key, value); } //向指定的树x中添加key-value,并返回添加元素后的新树 public Node put(Node x,Key key,Value value){ //如果x子树为空 if (x==null){ //元素个数+1 N++; return new Node(key,value,null,null); } //如果x子树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 x.right = put(x.right, key, value); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 x.left=put(x.left,key,value); }else { //如果key等于x结点的键,则替换x结点的值为value x.value=val","date":"2021-01-17","objectID":"/tree/:0:1","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"2. 二叉树的最小和最大键 查找二叉树中最小的键 在某些情况下,我们需要查找出数中存储所有元素的键的最小值,比如我们的树中存储的是学生的排名和姓名数据,那么需要查找出排名最低是多少名\u003e这里我们设计如下两个方法来完成: public Key min() 找出树中最小的值 private Node min(Node x) 找出指定树x中,最小键所在的结点 //找出整个树中的最小键 public Key min(){ return min(root).key; } //找出指定树中的最小键所在的结点 private Node min(Node x){ //判断x是否还有左子结点,如果有则继续向左找,如果没有,则x就是最小键所在的结点 if (x.left!=null){ return min(x.left); }else { return x; } } 查找二叉树中最大的键 public Key max() 找出树中最大的键 private Node max(Node x) 找出指定树x中,最大键所在的结点 //找出整个树中最大键 public Key max(){ return max(root).key; } //找到指定树中最大的键所在的结点 private Node max(Node x){ //判断x是否还有右结点,如果有,则继续向右找,如果没有,则x就是最大的键所在的结点 if (x.right!=null){ return max(x.right); }else{ return x; } } ","date":"2021-01-17","objectID":"/tree/:0:2","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"3. 二叉树的基础遍历 很多情况下,我们可能需要像遍历数组一样遍历树,从而拿出书中存储的每一个元素,由于树状结构和线性结构不一样,他没有办法从头开始依次向后遍历,所以存在如何遍历,也就是按照什么样的搜索路径进行遍历的问题. 我们可以把二叉树的遍历分为以下三种方式: 前序遍历: 先访问根结点,然后在访问左子树,最后访问右子树 中序遍历: 先访问左子树,中间访问根结点,最后访问右子树 后序遍历: 先访问左子树,在访问右子树,最后访问根结点 前序遍历 public Queue\u003cKey\u003e preErgodic():使用前序遍历,获取真个树中的所有键 private void proErgodic(Node x, Queue\u003cKey\u003e keys):使用前序遍历,把指定树x中的所有键放入到keys队列中 实现过程中,我们通过前序遍历,把每个结点的key取出,放入到队列中返回即可. 实验步骤: 把当前结点的key放入到队列中; 找到当前结点的左子树,如果不为空,递归遍历左子树; 找到当前结点的右子树,如果不为空,递归遍历右子树 代码实现: //获取整个树中的所有键 public MyQueue\u003cKey\u003e preErgodic(){ MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); preErgodic(root,keys); return keys; } //获取指定树x中的所有键,并放到keys队列中 private void preErgodic(Node x ,MyQueue\u003cKey\u003e keys){ //判断x是否为空 if (x==null){ return; } //把x结点的key放入keys队列中 keys.inQueue(x.key); //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } } 代码测试: package Tree.BinaryTree; import List.Queue.MyQueue; public class BinaryTreeErgodicTest { public static void main(String[] args) { MyBinaryTree\u003cString, String\u003e tree = new MyBinaryTree\u003c\u003e(); tree.put(\"E\",\"5\"); tree.put(\"B\",\"2\"); tree.put(\"G\",\"7\"); tree.put(\"A\",\"1\"); tree.put(\"D\",\"4\"); tree.put(\"F\",\"6\"); tree.put(\"H\",\"8\"); tree.put(\"C\",\"3\"); MyQueue\u003cString\u003e keys = tree.preErgodic(); for(String key:keys){ String value = tree.get(key); System.out.println(value); } } } 中序遍历 public Queue\u003cKey\u003e minErgodic():使用中序遍历,获取整个树的所有键 private void midErgodic(Node x, Queue\u003cKey\u003e keys):使用中序遍历,把指定树x的素有键放入到keys队列中 实现步骤: 找到当前结点的左子树,如果不为空,递归遍历左子树; 把当前结点的key放到队列中; 找到当前结点的右子树,如果不为空,递归遍历右子树; 代码实现: //获取整个树中的所有键 public MyQueue\u003cKey\u003e midErgodic(){ MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); midErgodic(root,keys); return keys; } //获取指定树x中的所有键,并放到keys队列中 private void midErgodic(Node x ,MyQueue\u003cKey\u003e keys){ //判断x是否为空 if (x==null){ return; } //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //把x结点的key放入keys队列中 keys.enQueue(x.key); //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } } 后序遍历 实现步骤: 找到当前结点的左子树,如果不为空,递归遍历左子树; 找到当前结点的右子树,如果不为空,递归遍历右子树; 把当前结点的key放入到队列中; public Queue\u003cKey\u003e afterErgodic():使用中序遍历,获取整个树的所有键 private void afterErgodic(Node x, Queue\u003cKey\u003e keys):使用中序遍历,把指定树x的素有键放入到keys队列中 代码实现: //获取整个树中的所有键 public MyQueue\u003cKey\u003e afterErgodic(){ MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); afterErgodic(root,keys); return keys; } //获取指定树x中的所有键,并放到keys队列中 private void afterErgodic(Node x ,MyQueue\u003cKey\u003e keys){ //判断x是否为空 if (x==null){ return; } //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } //把x结点的key放入keys队列中 keys.enQueue(x.key); } ","date":"2021-01-17","objectID":"/tree/:0:3","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"4. 二叉树层序遍历 所谓的层序遍历,就是从根结点(第一层)开始,依次向下,获取每一层所有结点的值; 实现: public Queue\u003cKey\u003e layerErgodic():使用层序遍历,获取整个树中的所有键 实验步骤: 创建队列,存储每一层结点; 使用循环从队列中弹出一个结点: 获取当前结点的key; 如果当前结点的左子节点不为空,则把左子节点放入队列中; 如果当前结点的右子结点不为空,则把右子节点放入队列中; 代码实现: public MyQueue\u003cKey\u003e layerErgodic() throws InterruptedException { //定义两个队列,分别存储树中的键和树中的结点 MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); MyQueue\u003cNode\u003e nodes = new MyQueue\u003c\u003e(); //默认把根结点root放入队列中 nodes.enQueue(root); while (!nodes.isEmpty()){ //如果队列不为空,则弹出一个结点,把该结点的key放入keys中 Node n = nodes.deQueue(); keys.enQueue(n.key); //如果该结点有左子树,则把左子树放入队列中 if (n.left!=null){ nodes.enQueue(n.left); } //如果该结点有右子树,则把右子树放入队列中 if (n.right!=null){ nodes.enQueue(n.right); } } return keys; } 代码测试: MyBinaryTree\u003cString, String\u003e tree = new MyBinaryTree\u003c\u003e(); tree.put(\"E\", \"5\"); tree.put(\"B\", \"2\"); tree.put(\"G\", \"7\"); tree.put(\"A\", \"1\"); tree.put(\"D\", \"4\"); tree.put(\"F\", \"6\"); tree.put(\"H\", \"8\"); tree.put(\"C\", \"3\"); MyQueue\u003cString\u003e keys = tree.layerErgodic(); for (String key:keys){ String s = tree.get(key); System.out.println(s); } ","date":"2021-01-17","objectID":"/tree/:0:4","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"5. 二叉树的最大深度问题 需求: 给定一棵树,计算树的最大深度(树的根结点到最远叶子结点的最长路径上的结点树); 实现: public int maxDepth():计算整个树的最大深度 private int maxDepth(Node x):计算指定树的最大深度 实现步骤: 如果根结点为空,则最大深度为0; 计算左子树的最大深度; 计算右子树的最大深度; 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 代码实现: //计算树的最大深度 public int maxDepth(){ return maxDepth(root); } private int maxDepth(Node x){ if (x==null) return 0; //记录整个树的最大深度 int max=0; //记录左子树的最大深度 int maxLeft=0; //记录右子树的最大深度 int maxRight=0; //计算x结点左子树的最大深度 if (x.left!=null){ maxLeft=maxDepth(x.left); } //计算x结点右子树的最大深度 if (x.right!=null){ maxRight=maxDepth(x.right); } //计算整个树的最大深度 max=Math.max(maxLeft+1,maxRight+1); return max; } 代码测试: MyBinaryTree\u003cString, String\u003e tree = new MyBinaryTree\u003c\u003e(); tree.put(\"E\", \"5\"); tree.put(\"B\", \"2\"); tree.put(\"G\", \"7\"); tree.put(\"A\", \"1\"); tree.put(\"D\", \"4\"); tree.put(\"F\", \"6\"); tree.put(\"H\", \"8\"); tree.put(\"C\", \"3\"); MyQueue\u003cString\u003e keys = tree.layerErgodic(); for (String key:keys){ String s = tree.get(key); System.out.println(s); } int i = tree.maxDepth(); System.out.println(i); ","date":"2021-01-17","objectID":"/tree/:0:5","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["JavaSE"],"content":"1. 反射机制 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:1:0","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"1. 介绍 反射机制允许程序在执行期借助ReflectionAPI取得任何类的内部信息(比如成员变量,构造方法,成员方法等等),并能操作对象的属性及方法.反射在设计模式和框架底层都会用到; 加载完类后,在堆中就产生了一个Class类型的对象(一个类只有一个Class对象),这个对象包含了类的完整结构信息.通过这个对象得到类的结构.这个对象就像一面镜子,透过这个镜子看到类的结构,所以,形象的称为反射; ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:1:1","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"2. 原理示意图 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:1:2","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"3. 反射机制作用 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时得到任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的成员变量和方法 生成动态代理 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:1:3","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"4. 反射相关的主要类 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:1:4","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"5. 反射的有点和缺点 优点: 可以动态的创建和使用对象(也是框架底层核心),使用灵活,没有反射机制,框架技术就失去底层支撑; 缺点: 使用反射基本是解释执行,对执行速度有影响; ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:1:5","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"6. 反射调用优化-关闭访问检查 Method和Field,Constructor对象都有setAccessible()方法; setAccessible作用是启动和禁用访问安全检查的开关; 参数值为true表示反射的对象在使用时取消访问检查,提高反射的效率,参数值为false则表示反射的对象执行访问检查; ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:1:6","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"2. Class类 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:2:0","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"1. 基本介绍 Class也是类,因此也继承Object类; Class类对象不是new出来的,而是系统创建的; 对于某个类的Class类对象,在内存中只有一份,因为类只加载一次; 每个类的实例都会记得自己是由哪个Class实例所生成; 通过Class可以完整的得到一个类的完整结构,通过一系列API Class对象时存放在堆的 类的字节码二进制数据,是放在方法区的,有点地方称为类的元数据; ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:2:1","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"2. 获取Class类对象 1. Class.forName() 前提:已知一个类的全类名,且该类路径下,可通过Class类的静态方法forName()获取,可能抛出ClassNotFoundException 应用场景:多用于配置文件,读取类全路径,加载类; 2. 类名.class 前提:若已知具体的类,通过类的class获取,该方式最为安全可靠,程序性能最高; 应用场景:多用于参数传递,比如通过反射得到对应构造器对象; 3. 对象.getClass() 前提:已知某个类的实例,调用该实例的getClass()方法获取Class对象 应用场景:通过创建好的对象,获取Class对象; 4. 其他方式 ClassLoader cl=对象.getClass().getClassLoader(); Class clazz=cl.loadClass(“类的全类名”); 5. 基本数据类型 Class clazz=基本数据类型.class 6. 基本数据类型对应的包装类,可以通过.TYPE得到Class类对象 Class clazz=包装类.TYPE ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:2:2","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"3. 哪些类型有Class对象 外部类,成员内部类,静态内部类,局部内部类,匿名内部类 interface 数组 enum annotation 基本数据类型 void ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:2:3","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"3. 类加载 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:3:0","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"1. 基本说明 反射机制是java实现动态语言的关键,也就是通过反射实现类动态加载 静态加载:编译时加载相关的类,如果没有则报错,依赖性太强; 动态加载:运行时加载需要的类,如果运行时不用该类,则不报错,降低了依赖性; ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:3:1","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"2. 类加载时机 当创建对象时(new) 当子类被加载时 调用类中的静态成员时 通过反射 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:3:2","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"3. 类加载过程 1. 加载阶段 JVM在该阶段的主要目的是将字节码从不同的数据源转化为二进制字节流加载到内存中,并生成一个代表该类的Class对象; 2. 连接阶段-验证 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全 包括:文件格式验证,元数据验证,字节码验证和符号引用验证 可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施,缩短虚拟机类加载的时间 3. 连接阶段-准备 JVM会在该阶段对静态变量,分配内存并默认初始化(对应数据类型的默认初始值);这些变量所使用的内存都将在方法区中进行分配; 4. 连接阶段-解析 虚拟机将常量池内的符号引用替换为直接引用的过程 5. initialization(初始化) 到初始化阶段,才真正开始执行类中定义的Java程序代码,此阶段是执行()方法的过程 ()方法是由编译器按语句在源文件中出现的顺序,一次自动手机类中的所有静态变量的复制动作和静态代码块中的语句,并进行合并 虚拟机会保证一个类的()方法在多线程环境中被正确的加锁,同步,如果多个线程同时去初始化一个类,name之后有一个线程去执行这个类()方法,其他线程都需要阻塞等待,知道活动线程执行()方法完毕; ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:3:3","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"4. 通过反射获取类的结构信息 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:4:0","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"5. 通过反射创建对象 方式一: 调用类中的public修饰的无参构造器 方式二: 调用类中的指定构造器 Class类相关方法 newInstance:调用类中的无参构造器,获取对应类的对象 getConstructor(Class…clazz):根据参数列表,获取对应的构造器对象 getDecalaredConstructor(Class..clazz):根据参数列表,获取对应的构造器对象 Constructor类相关对象 setAccessible:爆破 newInstance(Object…obj):调用构造器 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:5:0","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"6. 通过反射访问类中的成员 ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:6:0","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"1. 访问属性 根据属性名获取Field对象 Field f= clazz对象.getDeclaredFidld(属性名) 爆破:f.setAccessible(true); 访问 f.set(对象,值) f.get(对象) 注意:如果是静态属性,则set和get中的对象可以写成null; ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:6:1","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["JavaSE"],"content":"2. 访问方法 根据方法名和参数列表获取Method方法对象: Method m=clazz.getDeclaredMethod(方法名,xx.class); 获取对象:Object o=clazz.newInstance(); 爆破:m.setAccessible(true); 访问:Object returnValue=m.invoke(对象,实参列表); 注意:如果是静态方法,则invoke的对象,可以写成null; 在反射中,如果方法有返回值,同一返回Object ","date":"2020-11-02","objectID":"/%E5%8F%8D%E5%B0%84/:6:2","tags":["反射"],"title":"反射","uri":"/%E5%8F%8D%E5%B0%84/"},{"categories":["框架"],"content":"Mybatis配置 ","date":"2020-02-18","objectID":"/mybatis/:0:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1. 搭建实验数据库 创建一个MyBatis实验数据库,并创建一个user表 ","date":"2020-02-18","objectID":"/mybatis/:0:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2. Idea新建项目,连接数据库 新建一个普通的maven项目 pom.xml中导入相关的maven依赖 Mysql驱动 Mybatis驱动 junit驱动 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.21\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 连接我们的Mysql 解决时区问题 ","date":"2020-02-18","objectID":"/mybatis/:0:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3. 编写MyBatis核心配置文件 创建一个子模块mybatis-01 在该模块下的resource目录下,新建mybatis-config.xml文件,这是MyBatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSH=true\u0026amp;serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4. 编写MyBatis工具类 在子模块mybatis-01/src/main/java目录下,新建一个utils工具类包,新建MybatisUntils类 * 该类用来从XML中构建SqlSessionFactory package utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //从 SqlSessionFactory 中获取 SqlSession public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //从 SqlSessionFactory 中获取 SqlSession public static SqlSession getSqlSession() { SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; } } ","date":"2020-02-18","objectID":"/mybatis/:0:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5. 创建表对应实体类 package pojo; public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } ","date":"2020-02-18","objectID":"/mybatis/:0:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6.编写Mapper接口 在mybatis-01/src/main/java目录下,新建mapper包,其中新建UerMapper接口 * 其中抽象方法getUerList()用来返回Uer对象集合 package mapper; import pojo.User; import java.util.List; public interface UserMapper { List\u003cUser\u003e getUserList(); } ","date":"2020-02-18","objectID":"/mybatis/:0:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7.编写Mapper.xml配置文件 在子模块/src/main/java/mapper下,新建UerMappering.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUserList\" resultType=\"pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e namespase=自己创建Mapper接口 id=对应Mapper接口的方法名 resuletType=返回结果类型 select中间是Sql语句 ","date":"2020-02-18","objectID":"/mybatis/:0:7","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8. 编写junit测试类 在mybatis-01/test/java下新建mapper包，该包下新建测试类UserMapperTest *junit测试 package mapper; import mapper.UserMapper; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import pojo.User; import utils.MybatisUtils; import java.util.List; public class UserMapperTest { @Test public void test() { //获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } //关闭sqlSession sqlSession.close(); } } ","date":"2020-02-18","objectID":"/mybatis/:0:8","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"9. 给Maper.xml添加注册 每一个Mapper.xml都需要在MyBatis核心配置文件中注册 我们要在mybatis-config.xml中进行注册，最后加上以下代码 \u003cmappers\u003e \u003cmapper resource=\"mapper/UserMapping.xml\"/\u003e \u003c/mappers\u003e 这里的路径是我们定义的xml配置文件的路径 注意:改路径的中间要用/进行分割 ","date":"2020-02-18","objectID":"/mybatis/:0:9","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"10. 测试运行 ","date":"2020-02-18","objectID":"/mybatis/:0:10","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"11. 可能遇到的问题 maven配置文件无法被到处或生效 maven默认资源文件配置在resource目录下，但是我们放在了java目录下，该目录下无法导出，所以需要手动配置资源过滤，让src/main/java下的 .properties 或 .xml 可以导出 解决方案是:将以下设置写在pom.xml中 \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e CRUD ","date":"2020-02-18","objectID":"/mybatis/:0:11","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1. namespace: namespace中的包名要和Mapper接口的包名一致; ","date":"2020-02-18","objectID":"/mybatis/:0:12","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2. select: 选择,查询语句; id:就是对应的namespace中的方法名; resultType:Sql语句执行的返回值; parameterType:参数类型; 编写接口 User getUserById(int id); 编写对应Mapper中的Sql语句 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"pojo.User\"\u003e select * from mybatis.user where id=#{id} \u003c/select\u003e 测试 @Test public void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } ","date":"2020-02-18","objectID":"/mybatis/:0:13","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3. insert 编写接口 int addUser(User user); 编写对应Mapper中的Sql语句 \u003cinsert id=\"addUser\" parameterType=\"pojo.User\"\u003e insert into mybatis.user (id,name,pwd) values (#{id},#{name},#{pwd}); \u003c/insert\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:14","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4. update 编写接口 User updateUser(int id); 编写对应Mapper中的Sql语句 \u003cupdate id=\"updateUser\" parameterType=\"pojo.User\"\u003e update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id}; \u003c/update\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:15","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5. delete 编写接口 int deleteUser(int id); 编写对应的Mapper中的Sql语句 \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id=#{id}; \u003c/delete\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:16","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6. 错误分析 标签不要匹配错; resource编订mapper,需要使用路径; 陈旭配置文件必须符合规范; 空指针异常,没有注册到资源; 输出的 xml文件存在中文乱码问题; maven资源没有导出问题; ","date":"2020-02-18","objectID":"/mybatis/:0:17","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7. 万能Map 假设,我们的实体类,或者数据库中的表,字段或者参数过多,我们应该烤炉使用Map; int addUser2(Map\u003cString,Object\u003e map); \u003cinsert id=\"addUser2\" parameterType=\"map\"\u003e insert into mybatis.user (id,name,pwd) values (#{userid},#{username},#{userpwd}); \u003c/insert\u003e public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u003cString, Object\u003e map = new HashMap\u003cString, Object\u003e(); map.put(\"userid\",6); map.put(\"username\",\"gongxiwu\"); map.put(\"userpwd\",\"12344454\"); mapper.addUser2(map); sqlSession.commit(); sqlSession.close(); } Map传递参数,直接在sql中取出key即可; 对象传递参数,直接在sql中取出属性即可; 只有一个基本类型参数的情况下,可以直接在sql中取到; ","date":"2020-02-18","objectID":"/mybatis/:0:18","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8. 模糊查询 java代码执行的时候,传递通配符% % List\u003cUser\u003e userList = mapper.getUserLike(\"%王%\"); 在sql拼接中使用通配符; \u003cselect id=\"getUserLike\" resultType=\"pojo.User\"\u003e select * from mybatis.user where name like \"%\"#{value}\"%\" \u003c/select\u003e 配置解析 ","date":"2020-02-18","objectID":"/mybatis/:0:19","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1. 核心配置文件 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2020-02-18","objectID":"/mybatis/:0:20","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2 环境配置(environment) MyBatis可以配置成适应多种环境; 尽管可以配置多个环境,但每个SqlSessionFactory实例只能使用一种环境; MyBatis默认的事务管理器就是JDBC, 连接池: POOLED ","date":"2020-02-18","objectID":"/mybatis/:0:21","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3. 属性 xml文件中所有标签都可以规定顺序; 编写一个配置文件db.properties driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSH=true\u0026serverTimezone=GMT\u0026characterEncoding=UTF-8username=rootpassword=root 在核心配置文件映入 \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/properties\u003e 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一字段,优先使用外部配置文件的 ","date":"2020-02-18","objectID":"/mybatis/:0:22","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4. 类型别名(typeAliases) 类型别名是为Java类型设置自一个短的名字; 存在的意义仅在于用来减少类完全限定名的冗余' \u003ctypeAliases\u003e \u003ctypeAlias type=\"pojo.User\" alias=\"User\"/\u003e \u003c/typeAliases\u003e 也可以指定一个包名,MyBaties会在包名下面搜索需要的Java Bean,比如:扫描实体类的包名,他的默认别名就是这个类的类名; \u003c!--给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"pojo\"/\u003e \u003c/typeAliases\u003e 实体类较少的时候建议使用第一种; 实体类较多建议使用第二种; 第一种可以DIY别名,第二种则不行;如果非要修改,可以在实体类上加注解; @Alias(\"hello\") public class User {} ","date":"2020-02-18","objectID":"/mybatis/:0:23","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5. 设置(settings) 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等; ","date":"2020-02-18","objectID":"/mybatis/:0:24","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6. 其他设置 typeHandlers(类型处理器) objectFactory(对象工厂) plugins插件 mybatis-generator-core mybatis-plus 通用mapper ","date":"2020-02-18","objectID":"/mybatis/:0:25","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7. 映射器(mappers) MapperRegistry:注册绑定我们的Mapper文件 方式一: \u003cmappers\u003e \u003cmapper resource=\"mapper/UserMapping.xml\"/\u003e \u003c/mappers\u003e 方式二:使用class文件绑定注册 \u003cmappers\u003e \u003cmapper class=\"mapper.UserMapper\"/\u003e \u003c/mappers\u003e 注意点: * 接口和他的Mappe配置文件必须同名; * 接口和他的Mapper配置文件必须在同一个包下; 方式三:使用扫描包进行注册绑定 \u003cmappers\u003e \u003cpackage name=\"mapper\"/\u003e \u003c/mappers\u003e 注意点: * 接口和他的Mapper配置文件必须同名; * 接口和他的Mapper文件必须在同一个包下; ","date":"2020-02-18","objectID":"/mybatis/:0:26","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8.生命周期和作用域 生命周期和作用域是至关重要的,因为错误的使用会导致非常严重的并发问题; SqlSessionFactoryBuilder: 一旦创建了SqlSessionFactory,就不在需要它了 局部变量 SqlSessionFactory: 说白了就是可以想象为:数据库连接池 SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在,没有任何理由丢弃它或重新创建另一个实例. 因此SqlSessionFactory的最佳作用域是应用作用域; 最简单的就是使用单例模式或者静态单看例模式; SqlSession 连接到连接池的一个请求; SqlSession的实例不是线程安全的,因此是不能被共享的,所以他的最佳的作用域是请求或方法作用域; 用完之后需要赶紧关闭,否则资源被占用; 解决属性名和字段名不一致问题 数据库中的字段是: id,name,pwd; 实体类中的字段是:id,name,password; public class User { private int id; private String name; private String password; } 查出password字段为null; select * password from mybatis.user select id,name,pwd as password from mybatis.user 解决方法: 起别名 \u003cselect id=\"getUserList\" resultType=\"pojo.User\"\u003e select id,name,pwd as password from mybatis.user \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:27","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"resultMap 结果集映射 id name pwd id name password \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column对应数据库中的字段,property对应实体类的属性--\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e \u003c!--select查询语句--\u003e \u003cselect id=\"getUserList\" resultMap=\"UserMap\"\u003e select * from mybatis.user \u003c/select\u003e ResultMap 元素是MyBatis中最重要的最强大的元素; ResultMap的设计思想是,对于简单的于都根本不需要配置显示的结果映射,而对于复杂一点的语句只需要描述他们的关系就行了; ResultMap 最优秀的地方在于,虽然你已经对他相当了解了,但是根本就不需要显示地用到他们; 日志 如果一个数据库操作,出现了异常,我们需要拍错,日志就是最好的助手; 曾经:sout;debug 现在:日志工厂 logImpl:指定 MyBatis 所用日志的具体实现，未指定时将自动查找; SLF4J LOG4J (掌握) LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING(掌握) NO_LOGGING 在MyBatis中具体使用哪一个日志实现,在设置中设定; STDOUT_LOGGING是标准日志输出 ","date":"2020-02-18","objectID":"/mybatis/:0:28","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"log4j: Log4j是Apache的一个开源项目，通过使用Log4j,我们可以控制日志信息输送的目的地是控制台、文件、GUI组件; 我们也可以控制每一条日志的输出格式; 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程; 这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码; 先导入log4j的包 \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e log4j.properties #将登记为DEBUG的日志信息输出到console和file这两个目的地,console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/gong.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PrepareStatement=DEBUG 配置log4j为日志的实现 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e 简单使用: 导包:import org.apache.log4j.Logger; 日志对象,参数为当前类的class static Logger logger = Logger.getLogger(UserMapperTest.class); 日志级别 logger.info(\"info进入了log4jTest\"); logger.debug(\"debug进入了log4jTest\"); logger.error(\"error进入了log4jTest\"); 多对一处理 ","date":"2020-02-18","objectID":"/mybatis/:0:29","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"创建表 CREATE TABLE teacher ( id INT (10) NOT NULL, name VARCHAR(30) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=INNODB INSERT INTO TEACHER (id,name) VALUES (1,'李四'); CREATE TABLE student( id INT (10) NOT NULL, name VARCHAR(30) DEFAULT NULL, tid INT(10) DEFAULT NULL, PRIMARY KEY (id), FOREIGN KEY (tid) REFERENCES teacher (id) )ENGINE=INNODB INSERT INTO student(id,name,tid) VALUES (1,'小明',1); INSERT INTO student(id,name,tid) VALUES (2,'小红',1); INSERT INTO student(id,name,tid) VALUES (3,'小蓝',1); INSERT INTO student(id,name,tid) VALUES (4,'小绿',1); INSERT INTO student(id,name,tid) VALUES (5,'小黄',1); ","date":"2020-02-18","objectID":"/mybatis/:0:30","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"测试环境搭建 导入lombok 建立实体类Student,Teacher 创建Mapper接口 创建Mapper.xml文件 在核心配置文件中注册 测试 ","date":"2020-02-18","objectID":"/mybatis/:0:31","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照嵌套查询处理 \u003cmapper namespace=\"mapper.StudentMapper\"\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--复杂的属性需要单独处理 对象:association 集合:collection --\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student \u003c/select\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id=#{id} \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:32","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照结果嵌套查询 \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname ,t.name tname from student s,teacher t where s.tid=t.id \u003c/select\u003e mysql多对一查询方式: 子查询 联表查询 一对多处理 ","date":"2020-02-18","objectID":"/mybatis/:0:33","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"测试环境搭建 导入lombok 建立实体类Student,Teacher 创建Mapper接口 创建Mapper.xml文件 在核心配置文件中注册 测试 ","date":"2020-02-18","objectID":"/mybatis/:0:34","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照嵌套查询处理 \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from teacher where id=#{id} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003ccollection property=\"students\" column=\"id\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getTeacherByTeacherId\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacherByTeacherId\" resultType=\"student\"\u003e select * from student where tid=#{tid} \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:35","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照结果嵌套查询 \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c!--复杂的属性,需要单独处理,对象:association 集合:collection--\u003e \u003c!--集合中的泛型信息,使用ofType获取--\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:36","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"小结 关联-association [多对一] 集合-collection [一对多] javaType \u0026 ofType javaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的pojo类型,泛型中的约束类型 ","date":"2020-02-18","objectID":"/mybatis/:0:37","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"注意点: 保证sql的可读性,尽量保证通俗易懂 注意一对多和多对一种,属性名和字段的问题 如果问题不好排查错误,可以使用日志,建议使用log4j 动态SQl 什么是动态SQL:就是指不同条件生成不同语句; 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach ","date":"2020-02-18","objectID":"/mybatis/:0:38","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"搭建环境 CREATETABLE`blog`(`id`varchar(50)NOTNULLCOMMENT'博客id',`title`varchar(100)NOTNULLCOMMENT'博客标题',`author`varchar(30)NOTNULLCOMMENT'博客作者',`create_time`datetimeNOTNULLCOMMENT'创建时间',`views`intNOTNULLCOMMENT'浏览量')ENGINE=InnoDBCHARACTERSET=utf8mb4COLLATE=utf8mb4_0900_ai_ciROW_FORMAT=Dynamic;","date":"2020-02-18","objectID":"/mybatis/:0:39","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"创建一个基础工程 导包 编写配置文件 编写实体类 @Data public class Blog { private String id; private String title; private String author; private Date create_time; private int views; } 编写实体类对应的Mapper接口及Mapper.xml文件 测试 \u003cinsert id=\"addBlog\" parameterType=\"blog\"\u003e insert into mybatis.blog (id,title,author,create_time,views) values (#{id},#{title},#{author},#{create_time},#{views}) \u003c/insert\u003e public void addBlog(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IdUtils.getId()); blog.setAuthor(\"宫习武\"); blog.setCreate_time(new Date()); blog.setTitle(\"java\"); blog.setViews(99999); mapper.addBlog(blog); blog.setId(IdUtils.getId()); blog.setTitle(\"c#\"); mapper.addBlog(blog); blog.setId(IdUtils.getId()); blog.setTitle(\"数据库\"); mapper.addBlog(blog); blog.setId(IdUtils.getId()); blog.setTitle(\"操作系统\"); mapper.addBlog(blog); sqlSession.commit(); sqlSession.close(); } ","date":"2020-02-18","objectID":"/mybatis/:0:40","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"IF语句 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog where 1=1 \u003cif test=\"title!=null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author!=null\"\u003e and author=#{author} \u003c/if\u003e \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:41","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"Choose(when,otherwise) \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title!=null\"\u003e title=#{title} \u003c/when\u003e \u003cwhen test=\"author!=null\"\u003e and author!=null \u003c/when\u003e \u003cotherwise\u003e and views=#{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:42","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"trim(where,set) \u003cupdate id=\"updateBlog\" parameterType=\"map\" \u003e update mybatis.blog \u003cset\u003e \u003cif test=\"title!=null\"\u003e title=#{title}, \u003c/if\u003e \u003cif test=\"author!=null\"\u003e author=#{author} \u003c/if\u003e \u003c/set\u003e where id=#{id} \u003c/update\u003e 所谓动态SQL,本质还是SQL语句,只是我们可以在SQL层面,去执行一个逻辑代码 ","date":"2020-02-18","objectID":"/mybatis/:0:43","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"SQL片段 有的时候,我们可能会将一些功能的部分抽取出来,方便复用! 使用SQL标签抽取公共的部分 \u003csql id=\"If-Sql\"\u003e \u003cif test=\"title!=null\"\u003e title=#{title} \u003c/if\u003e \u003cif test=\"author!=null\"\u003e and author=#{author} \u003c/if\u003e \u003c/sql\u003e 在需要使用的地方使用include标签引用即可 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cinclude refid=\"If-Sql\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e 注意事项: 最好基于单表来定义SQL片段 不要存在where标签 ","date":"2020-02-18","objectID":"/mybatis/:0:44","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"foreach \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cforeach collection=\"ids\" item=\"id\" open=\"(\" close=\")\" separator=\"or\"\u003e id=#{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e 动态SQL就是在拼接SQL语句,我们只要保证SQL的准确性,按照SQL的格式,去排列组合就可以了 建议: 先在Mysql中写出完整的SQL,再去对应的修改成为我们的动态SQL实现通用即可; 缓存 ","date":"2020-02-18","objectID":"/mybatis/:0:45","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"一级缓存 一级缓存也叫本地缓存:SqlSession 与数据库同义词回话期间查询到的数据会放在本地缓存中; 以后如果需要获取相同的数据,直接从缓存中拿,没必要再去查询数据库; 测试步骤 开启日志; 测试在一个Session中查询两次记录 查看日志输出 缓存失效的情况: 查询不同的东西 增删改操作,可能会改变原来的数据,所以必定会刷新缓存; 查询不同的Mapper.xml 手动清理缓存; SqlSession.clearCache();//手动清理缓存 小结:一级缓存默认是开启的,只在一次SqlSession中有效,也就是拿到连接到关闭连接这个区间段;一级缓存就是一个Map; ","date":"2020-02-18","objectID":"/mybatis/:0:46","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"二级缓存 二级缓存也叫全局缓存,一级缓存作用域太低了,所以诞生了二级缓存; 基于namespace级别的缓存,一个名称空间,对应一个二级缓存; 工作机制 一个会话查询一条数据,这个数据就会被放在当前会话的一级缓存中; 如果当前会话关闭了,这个会话对应的一级缓存就没了,但是我们想要的实,会话关闭了,一级缓存中的数据被保存到二级缓存中; 新的会话查询信息,就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存中; 步骤: 开启全局的二级缓存 \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 在Mapper.xml中使用二级缓存 \u003ccache/\u003e 也可以自定义参数 \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 问题:我们需要将实体类序列化,否则会报错!(实体类实现Serializable接口) ","date":"2020-02-18","objectID":"/mybatis/:0:47","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"小结 只要开启了二级缓存,在同一个Mapper下就有效; 所有的数据都会先放在一级缓存中; 只有当会话提交,或者关闭的时候,才会提交到二级缓存中; ","date":"2020-02-18","objectID":"/mybatis/:0:48","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"}]