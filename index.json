[{"categories":["Spring"],"content":"1. 动态代理的实现 1. jdk动态代理: 使用java反射包中的类和接口实现动态代理的功能 反射包 java.lang.reflect,里面有三个类:InvocationHandler,Method,Proxy 2. cglib动态代理 cglib是第三方的工具库,创建代理对象. cglib的原理是继承,cglib通过继承目标类,创建他的子类,在子类中重写父类中同名的方法,实现功能的修改. 因为cglib是继承,重写方法,所以要求目标类不能是final的,方法也不能是final的 ","date":"2022-03-16","objectID":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:0:1","tags":["反射"],"title":"动态代理","uri":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["Spring"],"content":"2. jdk动态代理 1. 反射,Method类,表示方法,类中的方法.通过Method可以执行某个方法. 2. jdk动态代理的实现 InvocationHandler 就一个方法invoke() invoke():表示代理对象要执行的功能代码,你的代理类要完成的功能卸载invoke()方法中. 方法原型: 参数: Object proxy: jdk创建的代理对象,无需赋值 Method method: 目标类中的方法,jdk提供method对象的 Object[] args: 目标类中的方法的参数,jdk提供 Method 表示方法的,确切的说是目标类中的方法 通过Mehtod可以执行某一个目标类的方法,Method.invoke() Proxy 核心的对象,创建的代理对象,之前创建对象都是用new类的构造方法(),现在使用Proxy类的方法,代替new的使用 静态方法:newProxyInstance(),创建代理对象 参数: classLoader loader: 类加载器,负责向内存中加载对象的.使用反射获取对象的ClassLoader Class\u003c?\u003e[] interfaces: 接口,目标对象实现的接口,也是反射获取的 InvocationHander h: 我们自己写的,代理类要完成的功能 ","date":"2022-03-16","objectID":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/:0:2","tags":["反射"],"title":"动态代理","uri":"/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"categories":["框架"],"content":"1. 基本概念 事务是数据库操作的最小工作单元,是作为单个逻辑工作单元执行的一些列操作;这些操作作为一个整体一起向系统提交,要么都执行,要么都不执行;事务是一组不可再分割的操作集合 通俗点说就是为了达到某个目的而做的一些列操作,要么一起成功(事务提交),要么一起失败(事务回滚) ","date":"2022-03-15","objectID":"/spring%E4%BA%8B%E5%8A%A1/:0:1","tags":["Spring"],"title":"Spring事务","uri":"/spring%E4%BA%8B%E5%8A%A1/"},{"categories":["框架"],"content":"2. 事务的四大特性 原子性(Atomicity): 事务中所有操作时不可再分割的原子单位.事务中所有操作要么全部执行成功,要么全部执行失败 一致性(Consistency): 事务执行后,数据库状态与其他业务规则保持一致,如转账业务,无论事务执行成功与否,参与转账的两个账号余额之和应该是不变的 隔离性(Isolation): 隔离性是指在并发操作中,不同事务之间应该隔离开来,使每个并发的事务不会相干扰 持久性(Durability): 一旦事务提交成功,事务中的所有数据操作都必须被持久化到数据库中,即使提交事务后,数据库崩溃,在数据库重启时,也能保证某种机制恢复数据 ","date":"2022-03-15","objectID":"/spring%E4%BA%8B%E5%8A%A1/:0:2","tags":["Spring"],"title":"Spring事务","uri":"/spring%E4%BA%8B%E5%8A%A1/"},{"categories":["框架"],"content":"3. 事务的隔离级别 脏读(读取了未提交的数据,然后被回滚了) 事务A读取了事务B中尚未提交的数据,如果事务B回滚,则A读取使用了错误的数据 不可重复读(读取了提交的新事物,指更新操作) 不可重复读是指在对于数据库中的某个数据,一个事务范围内多次查询却返回了不同的数据,这是由于在查询间隔,被另一个事务修改并提交了 幻读(读取了提交的新事物,指增删操作) ​ 在事务A多次读取中,事务B对数据进行了新增操作,导致事务A多次读取的数 据不一致 第一类事务丢失(回滚丢失) 对于第一类事务丢失,就是比如A和B同时在执行一个数据,然后B事务已经提交了,然后A事务回滚了,这样B事务的操作就因A事务的回滚二丢失了 第二类事务丢失(覆盖丢失) ​ 对于第二类事务丢失,也称为覆盖丢失,就是A和B一起执行一个数据,两个同时取一个数据,然后B事务首先提交,但是A事务接下来又提交,这样就覆盖了B事务 Read uncommitted 读未提交,就是一个事务可以读取另一个未提交事务的数据,会产生脏读 Read committed 读已提交,就是一个事务要等到另一个事务提交后才能读取数据,会产生不可重复读 Repeatable read 重复读,就是在开始读取数据(事务开启时),不在允许修改操作,可能会产生幻读 Serializable 最高的事务隔离级别,在该级别下,事务串行化顺序执行,可以毕淼脏读,不可重复读与幻读,但这种事务隔离级别效率低下,比较耗数据库性能,一般不使用 ","date":"2022-03-15","objectID":"/spring%E4%BA%8B%E5%8A%A1/:0:3","tags":["Spring"],"title":"Spring事务","uri":"/spring%E4%BA%8B%E5%8A%A1/"},{"categories":["面试"],"content":"springmvc执行流程 数据参数在handler处理 mybatis 分页插件如何实现 动态sql如何写 方法和sql如何绑定 先namespace 线程 进程关系 线程的状态 6种 interipped notify all区别 线程安全 写 锁机制 new创建字符串 syn锁升级 反射可以获取私有信息吗 需要设置一下setaccess 自定义注解 多态的理解 封装 treeset如何去重 compareto 数组链表区别 序列化 反序列化 Spring如何为我们创建对象 动态代理 Springbean生命周期 init aware 对象作用域 threadlocal 私有化 线程隔离 底层机制 threallocalmap k v Spring 如何解决循环依赖 三级缓存 linux的常用 ps -ef 进程号 kill 全局找一个文件 find 动态查看日志 tail f 动态 n 末尾多少行 数据库隔离级别 读未提交 读以提交 可重复读 串行化 存储引擎 sql语句执行过程 先执行from ","date":"2022-03-10","objectID":"/%E9%9D%A2%E8%AF%95%E9%A2%98/:0:0","tags":["面试题"],"title":"面试题","uri":"/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["数据库"],"content":"1. 存储引擎 1.1. 对比MyISAM和InnoDB 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁,即使操作一条记录也会锁住整个表,不适合高并发的操作 行锁,操作时只锁一行,不对其他行有影响,适合高并发的操作 缓存 只缓存索引,不缓存真实数据 不仅缓存索引还要缓存真实数据,对内存要求较高,而且内存大小对性能有决定性的影响 表空间 小 大 关注点 性能 事务 默认安装 Y Y 1.2. 阿里巴巴,淘宝用哪个? 产品 价格 目标 主要功能 是否可投入生产 PerCona Server 免费 提供XtraDB存储引擎的包装器和其他分析工具 XtraDB 是 MariaDB 免费 拓展MySQL以包含XtraDB和其他性能改进 XtraDB 是 Drizzle 免费 提供比MySQL更强大的可拓展性和性能改进 高可用性 是 Percona为MySQL数据库服务器进行了改进,在功能和性能上较MySQL有着很显著的提升.该版本提升了在高负载情况下的InnoDB的性能,为DBA提供一些非常有用的性能诊断工具;另外有很多的参数和命令来控制服务器行为. 该公司新建了一款存储引擎交XtraDB完全可以替代InnoDB,并且在性能和并发上做的很好. 阿里巴巴大部分MySQL数据库其实使用的PerCona的原型加以修改. AliSql+AliRedis ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:1","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["数据库"],"content":"2. 性能分析 2.1. 性能下降SQL慢,执行时间长,等待时间长 查询语句写的烂 索引失效-单值,复合 关联查询太多join(设计缺陷或不得已的需求) 服务器调优及各个参数设置(缓冲,线程数等) 2.2. 常见通用的join查询 SQL执行顺序 手写 SELECT -\u003e FROM -\u003e WHERE -\u003e GROUP BY -\u003e HAVING -\u003e ORDER BY -\u003e LIMIT 机读 FROM -\u003e ON -\u003e WHERE -\u003e GROUP BY -\u003e HAVING -\u003e SELECT -\u003e DISTINCT -\u003e ORDER BY -\u003e LIMIT 总结 JOIN图 ​ 2.3. 索引简介 是什么? MySQL官方对索引的定义为: 索引(Index)是帮助MySQL搞笑获取数据的数据结构.可以得到索引的本质: 索引是数据结构,索引的目的在于提高查询下效率,可以类比字典. 你可以简单理解为\"排好序的快速查找数据结构\" 详解: 在数据之外,数据库系统还维护这满足特定查找算法的数据结构,这些数据结构以某种方式引用数据,这样就可以在这些数据结构上实现高级查找算法.这种数据结构就是索引,下图就是一种可能的索引方式示例: 为了加快Col2的查找,可以维护一个右边所示的二叉查找树,每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针,这样就可以运用而查找树在一定的复杂度内获取到相应数据,从而快速的检索出复合条件的记录. 一般来说索引本身也很大,不可能全部存储在内存中,因此索引往往以索引文件的形式存户磁盘上. 我们平常所说的索引,如果没有特别指明,都是指B树(多路搜索树,并不一定是二叉的)结构组织的索引.其中聚集索引,次要索引,复合索引,前缀索引,唯一索引默认都是使用B+树索引,统称索引.当然,除了B+树这种类型的索引之外,还有哈希索引 优势 提高数据检索的效率,降低数据库的IO成本 通过索引列队数据进行排序,降低数据排序的成本,降低了CPU的消耗 劣势 实际上索引也是一张表,该表保存了主键与索引字段,并指向实体表的记录了,所以索引列也是要占用空间的 虽然索引大大提高了查询速度,同时却会降低更新表的速度,如对表进行INSERT,UIPDATE和DELETE.因为更新表时,MySQL不仅要保存数据,还要保存一下索引文件每次更新了索引列的字段,都会调整因为更新所带来的键值变化后的所有信息. MySQL索引分类 单值索引: 即一个索引只包含单个列,一个表可以有多个单列索引 唯一索引: 索引列的值必须唯一,但允许有空值 复合索引: 即一个索引包含多个列 MySQL索引结构 BTree索引 Hash索引 full-text全文索引 R-Tree索引 哪些情况需要创建索引 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段,外键关系建立索引 频繁更新的字段不适合不适合创建索引,因为每次更新不单单是更新了记录还会更新索引. where条件里用不到的字段不创建索引 单键/组合索引的选择问题,在高并发下倾向创建组合索引 查询中排序的字段,排序字段若通过索引去访问将大大提高排序素速度 查询在中统计或者分组字段 哪些情况不需要创建索引 表记录太少 经常增删改的表 数据重复且分布平均的表字段,因此应该只为最经常查询和最经常排序的数据列建立索引(如果某个数据列包含许多重复的内容,为他建立索引就没有太大的意义) ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:2","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["数据库"],"content":"3. 性能分析 3.1. MySQL Query Optimizer MySQL中有专门负责优化SELECT语句的优化器模块,主要功能: 通过计算分析系统中收集到的统计信息,为客户端请求的Query提供他任务最优的执行计划 当客户端想MySQL请求一条Query,命令解析器模块完成请求分类,区别出事SELECT并抓饭给MySQL Query Optimizer时,MySQL Query Optimizer首先会对整条Query进行优化,处理掉一些常量表达式的预算,之间换算成常量值,并对Query中的查询条件进行简化和转换,如去掉一些无用或显而易见的条件,结构调整等,然后分析Query中的Hint,看显示Hint信息是否可以完全确定该Query的执行计划.如果没有Hint或Hint信息还不足以完全确定执行计划,则会读取所涉及对象的统计信息,根据Query进行写响应的计算分析,然后再得出最后的执行计划. 3.2. MySQL的常见瓶颈 CUP: CUP在饱和的时候一般发生在数据装入内存或磁盘上读取数据时候 IO: 磁盘I/O瓶颈发生在装入数据远大于内存容量的时候 服务器硬件性能瓶颈; top,free,iostat和vmstat来查看系统的性能状态 ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:3","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["数据库"],"content":"4. 性能分析 索引失效 最佳左前缀法则 ​ 如果索引了多列,要遵守最左前缀法则,指的是查询从索引的最左前列开始并且不跳过索引中的列 不要在索引列上做任何操作(计算,函数,(自动或手动)类型转换),会导致索引失效而转向全表扫描 存储引擎不能使用索引中范围条件右边的列 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select * mysql在使用不等于(!=或者\u003c\u003e)的时候无法使用索引会导致全表扫描 is null ,is not null也无法使用索引 like以通配符开头('%abc'),mysql索引失效编程全表扫描的操作 字符串不加单引号索引失效 ","date":"2022-02-19","objectID":"/mysql%E9%AB%98%E7%BA%A7/:0:4","tags":["MySQL"],"title":"MySQL高级","uri":"/mysql%E9%AB%98%E7%BA%A7/"},{"categories":["框架"],"content":"SpringCloud ","date":"2022-02-18","objectID":"/springcloud/:0:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"1. Eureka 1. 提供者与消费者 服务提供者: 一次业务中,被其他服务调用的服务(提供接口给其他服务) 服务消费者: 一次业务中,调用其他服务的服务(调用其他服务提供的接口) 提供者与消费者角色是相对 一个服务可以同时是服务提供者和服务消费者 2. Eureka注册中心 注册服务信息 拉取服务 负载均衡 远程调用 心跳续约 30s/次 1. Eureka的作用 消费者该如何获取服务提供者的具体信息? 服务提供者启动时向eureka注册自己的信息 eureka保存这些信息 消费者根据服务名称想eureka拉取提供者信息 如果有多个服务提供者,消费者该如何选择? 服务消费者利用负载均衡算法,从服务列表中挑选一个 消费者如何感知服务提供者健康状态? 服务提供者会每隔30s向eurekaServer发送心跳请求,报告健康状态 eureka会更新记录服务列表信息,心跳不正常会被剔除 消费者就可以拉取最新的信息 2. 服务注册 引入eureka-client依赖 在application.yml中配置eureka地址 ","date":"2022-02-18","objectID":"/springcloud/:0:1","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"2. Ribbon 1. Ribbon负载均衡规则 规则接口是IRule 默认实现是ZoneAvoidanceRule,根据zone选择服务列表,然后轮询 2. 负载均衡自定义方式 代码方式: 配置灵活,但修改时需要重新打包发布 配置方式: 直观,方便,无需重新打包发布,但是无法做全局配置 3. 饥饿加载 开启饥饿加载 eager-load 指定饥饿加载的服务名称 ","date":"2022-02-18","objectID":"/springcloud/:0:2","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"3. Nacos 1. yml配置 cloud:nacos:server-addr:110.40.236.91:8848# nacos服务端地址discovery:cluster-name:HZ# 集群名称2. 根据权重负载均衡 权重为0不会被访问 3. 环境隔离-namespace Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西,用来做最外层隔离! namespace用来做环境隔离 每个namespace都有唯一id 不同namespace下的服务不可见 5. nacos注册中心细节分析 6. 临时实例和非临时实例 服务注册到Nacos时,可以选择注册为临时或非临时实例,通过下面的配置来设置: ephemeral:true# 是否是临时实例7. Nacos与eureka异同 Nacos与eureka的共同点 都支持服务注册和服务拉取 都支持服务提供者心跳方式做健康检测 Nacos与Eureka的区别 Nacos支持服务端主动检测提供者状态: 临时实例采用心跳模式,非临时实例采用主动检测模式 临时实例心跳不正常会被剔除,非临时实例则不会被剔除 Nacos支持服务列表变更的消息推送模式,服务列表更新更加及时 Nacos集群默认采用AP方式,当集群中存在非临时实例时,采用CP模式;Eureka采用AP模式 8. 统一配置管理 将配置交给Naocs管理的步骤 在Nacos中添加配置文件 在微服务中引入nacos的config依赖 在微服务中添加bootstrap.yml,配置nacos地址,当前环境,服务名称,文件后缀名.这些决定了启动时去nacos读取哪个文件 9. 配置自动刷新 Nacos中的配置文件变更后,微服务无需重启就可以感知.不过需要通过下面两种配置实现: 方式一: 在@Value注入的变量所在类添加注解@RefreshScope 方式二: 使用@ConfigurationProperties注解 @Data @Component @ConfigurationProperties(prefix = \"pattern\") public class PatternProperties { private String dateformat; } @Autowired private PatternProperties patternProperties; 不是所有的配置都适合放到配置更新,维护起来比较麻烦 建议将一些关键参数,需要运行时调整的参数放到nacos配置中心,一般都是自定义配置 10. 多环境配置共享 微服务启动时会从nacos读取多个配置文件,无论profile如何变化,共享的文件一定会被加载 多种配置的优先级: 服务名-profile.yaml \u003e 服务名称.yaml \u003e 本地配置 ","date":"2022-02-18","objectID":"/springcloud/:0:3","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"4. Feign RestTemplate方式调用存在的问题: 代码可读性差,编程体验不统一 参数复杂URl难以维护 Feign: Feign是一个声明式的http客户端,起作用就是帮助我们优雅的实现http请求的发送,解决上面提到的问题. 1. Feign的使用步骤: 引入依赖 添加@EnableFeignClients注解 编写FeignClient接口 使用FeignClient中定义的方法代替RestTemplate 2. 自定义Feign的配置 Feign运行自定义配置来覆盖默认配置,可以修改的配置如下: 一般我们需要配置的就是日志级别 配置Feign日志有两种方式: 方式一: 配置文件方式 全局生效: feign:client:config:default:loggerLevel:FULL 局部生效: feign:client:config:userservice:# 服务名loggerLevel:FULL 方式二: java代码方式,需要先声明一个Bean public class FeignClientConfiguration { @Bean public Logger.Level FeignLogLevel(){ return Logger.Level.BASIC; } } 如果是全局配置,则霸道放到@EnableFeignClients这个注解中 @EnableFeignClients(defaultConfiguration = FeignClientConfiguration.class) 如果是局部配置,则把他放到@FeignClient这个注解中 @FeignClient(value = \"userservice\" , configuration = FeignClientConfiguration.class) 3. Feign的性能优化 Feign底层的客户端实现: URLConnection : 默认实现,不支持连接池 Apache HttpClient : 支持连接池 OKHttp: 支持连接池 因此优化Feign的性能主要包括: 使用连接池代替默认的URLConnection 日志级别,最好用basic 或none 设置连接池参数 httpclient:enabled:true# 开启feign对HttpClient的支持max-connections:200# 最大的连接数max-connections-per-route:50# 每个路径的最大连接数4. Feign的最佳实践 方式一(继承): 给消费者的feignClient和提供者的controller定义同一的父接口作为标准 服务紧耦合 父接口参数列表中的映射不会被继承 方式二(抽取): 将FeignClient抽取为独立模块,并且把接口有关的pojo,默认的Feign配置都放到这个模块中,提供给所有消费者使用 5. 抽取FeignClient 实现最佳实践方式二的步骤: 创建一个module,命名为feign-api,然后引入feign的starter依赖 将原先的client,pojo都移到feign-api项目中 在@EnableFeignClients注解中添加clients,指定具体FeignClient的字节码 ","date":"2022-02-18","objectID":"/springcloud/:0:4","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"5. Gateway 1. 为什么需要网关 身份认证和权限校验 服务路由,负载均衡 请求限流 2. 网关的技术实现 在SpringCloud中网关的实现包括两种: gateway zuul 3. 搭建网关服务 引入依赖: 网关依赖,服务发现依赖 编写配置文件 server:port:8084spring:application:name:gateway# 服务名称cloud:nacos:server-addr:110.40.236.91:8848gateway:routes:- id:user-service# 路由标识uri:lb://userservice# 路由的目标地址predicates:# 路由断言,判断是否符合规则- Path=/user/**# 路径断言,.判断路径是否是以/user开头- id:order-service# 路由标识uri:lb://orderservice# 路由的目标地址predicates:# 路由断言,判断是否符合规则- Path=/order/**# 路径断言,.判断路径是否是以/user开头","date":"2022-02-18","objectID":"/springcloud/:0:5","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"6. RabbitMQ 1.安装MQ 拉取镜像: docker pull RabbitMQ:3-management 运行MQ容器: docker run -d –name my_rabbitMQ -e RABBITMQ_DEFAULT_USER=codesniper -e RABBITMQ_DEFAULT_PASS=gongxiwu -p 15672:15672 -p 5672:5672 rabbitmq:3-management 2. RabbitMQ概述 RabbitMQ的结构和概念 3. RabbitMQ的几个概念 channel: 操作MQ的工具 exchange: 路由消息到队列中 queue: 缓存消息 virtual host: 虚拟主机,是对queue,exchange等资源的逻辑分组 4. 常见消息模型 MQ的官方文档中给出了几个MQ的demo实例: 基本消息队列(BasicQueue) 工作消息队列(WorkQueue) 发布订阅,根据交换机不同分3种 Fanout Exchange: 广播 Direct Exchange: 路由 Topic Exchange: 主题 Hello World案例 官方的HelloWorld是基于最基础的消息队列模型来实现的,只包括三个角色 publisher: 消息发布者,将消息发送到队列queue queue: 消息队列,负责接受并缓存消息 Consumer: 订阅队列,处理队列中的消息 基本消息队列的消息的发送流程: 建立connection 创建channel 利用channel声明队列 利用channel向队列发送消息 基本消息队列的消息接受流程: 建立connection 创建channel 利用channel声明队列 定义consumer的消费行为handleDelivery() 利用channel将消费者与队列绑定 5. SpringAMQP 利用SpringAMQP实现HelloWorld中的基础消息队列功能 流程如下: 在父工程中引入spring-amqp的依赖 在publisher服务中利用RabbitTemplate发送消息到simple.queue中 在consumer服务中编写消费逻辑,绑定simple.queue这个队列 1. 在publisher中编写测试方法,向simple.queue中发送消息 在publisher服务中编写application.yml,添加mq连接信息 spring:rabbitmq:host:110.40.236.91port:5672virtual-host:/username:***password:*****在publisher服务中编写测试方法 @SpringBootTest class PublisherApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; @Test public void sendMessageToSimpleQueueTest(){ String queueName = \"simple.queue\"; String message = \"hello,world!\"; rabbitTemplate.convertAndSend(queueName,message); } } 2. 在consumer中编写消费逻辑,监听simple.queue 在consumer服务中编写application.yml,添加mq连接信息 spring:rabbitmq:host:110.40.236.91port:5672virtual-host:/username:***password:*****在consumer服务中新建一个类,编写消费逻辑 @Component public class RabbitMQListener { @RabbitListener(queues = \"simple.queue\") public void listenSimpleQueue(String msg){ System.out.println(\"msg = \" + msg); } } Work Queue工作队列 Work Queue,工作队列,可以提高消息处理速度,避免队列消息堆积 1. 消费预取限制 spring:rabbitmq:host:110.40.236.91port:5672virtual-host:/username:***password:***listener:simple:prefetch:1 发布(Publish),订阅(Subscribe) 发布订阅模式之前案例的区别就是允许将同一信息发送给多个消费者. 常见exchange类型包括: Fanout: 广播 Direct: 路由 Topicc: 话题 1. 发布订阅-Fanout Exchange Fanout Exchange会将接受到的消息路由到每一个跟其绑定的queue 演示FanoutExchange的使用 实现思路如下 在consumer服务中,利用代码声明队列,交换机,并将两者绑定 在consumer服务中,利用两个消费方法,分别监听两个fanout.queue1和fanout.queue2 在publisher中编写测试方法,想itcast.fanout发送消息 步骤1: 在consumer服务声明Exchange,Queue,Binding 在consumer服务新建一个类,添加@configuration注解,声明FanoutExchange,Queue和绑定关系对象Binding /** * 声明交换机 * @return FanoutExchange */ @Bean public FanoutExchange fanoutExchange(){ return new FanoutExchange(\"my.fanout\"); } /** * 声明队列1 * @return Queue */ @Bean public Queue fanoutQueue1(){ return new Queue(\"fanout.queue1\"); } /** * 队列1绑定到交换机 * @param queue * @param fanoutExchange * @return Binding */ @Bean public Binding fanoutQueueBinding1(@Qualifier(\"fanoutQueue1\") Queue queue, FanoutExchange fanoutExchange){ return BindingBuilder.bind(queue).to(fanoutExchange); } /** * 声明队列2 * @return Queue */ @Bean public Queue fanoutQueue2(){ return new Queue(\"fanout.queue2\"); } /** * 队列2绑定到交换机 * @param queue * @param fanoutExchange * @return Binding */ @Bean public Binding fanoutQueueBinding2(@Qualifier(\"fanoutQueue2\") Queue queue,FanoutExchange fanoutExchange){ return BindingBuilder.bind(queue).to(fanoutExchange); } 步骤2: 在consumer服务声明两个消费者 在consumer服务的监听类中,分别添加方法监听两个队列 @RabbitListener(queues = \"fanout.queue1\") public void listenFanoutQueue1(String msg){ System.out.println(\"接受fanout.queue1的消息: \" + msg + LocalTime.now()); } @RabbitListener(queues = \"fanout.queue2\") public void listenFanoutQueue2(String msg){ System.out.println(\"接受fanout.queue2的消息: \" + msg + LocalTime.now()); } 步骤3: 在publisher服务发送消息到FanoutExchange 在publisher服务发送消息 @Test public void sendMessageToFanoutExchange(){ String exchangeName = \"my.fanout\"; String message = \"Hello,FanoutExchange!!\"; rabbitTemplate.convertAndSend(exchangeName,\"\",message); } 2. 发布订阅-DirectExchange Direct Exchange 会将接受到的消息根据规则路由到指定的Queue 每一个Queue都与Exchange设置一个BindingKey 发布者发送消息时,指定信息的RoutingKey Exchange将消息路由到BindingKey与消息RoutingKey一致的队列 演示DirectExchange的使用 步骤1: 在co","date":"2022-02-18","objectID":"/springcloud/:0:6","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["框架"],"content":"7. ES 概念: MySQL ES 说明 Table Index 索引(index),就是文档的集合,类似数据库的表(table) Row Document 文档(Document),就是一条条的数据,类似数据库的行(Row),文档就是JSON格式 Column Field 字段(Field),就是JSON文档中的字段,类似数据库的列(COlumn) Schema Mapping Mapping(映射)是索引中的文档的约束,例如字段类型约束.类似数据库的表结构 SQL DSL DSL是elasticsearch提供的JSON风格的请求语句,用来操作elasticsearch,实现CRUD 架构: MySQL: 擅长事务类型操作,可以确保数据的安全和一致性 Elasticsearch: 擅长海量数据的搜索,分析,计算 docker run –name elasticsearch -p 9200:9200 -p 9300:9300 -e “discovery.type=single-node” -e ES_JAVA_OPTS=\"-Xms64m -Xmx128m\" -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.4.2 9d2f21adf463 docker run -it -e ELASTICSEARCH_URL=http://127.0.0.1:9200 –name kibana –network=container:elasticsearch 9d2f21adf463 docker run --name elasticsearch --net hahanetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -d elasticsearch:7.4.1 ","date":"2022-02-18","objectID":"/springcloud/:0:7","tags":["SpringCloud"],"title":"SpringCloud","uri":"/springcloud/"},{"categories":["并发编程"],"content":"1. 进程与线程 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:0","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"1.1 进程与线程 1.1.1 进程 程序由指令和数据组成,但这些指令要运行,数据要读写,就必须将指令加载至CPU,数据加载至内存.在指令运行过程中还需要用到磁盘,网络等设备.进程用来加载指令,管理内存,管理IO的. 当一个程序被运行,从磁盘加载这个程序至内存,这时就开启了一个进程. 进程就可以视为程序的一个实例.大部分程序可以同时运行多个实例进程,也有的程序只能启动一个实例进程. 1.1.2 线程 一个进程之内可以分一到多个线程. 一个线程就是一个指令流,将指令流中的一条条指令以一定的顺序交给CPU执行 Java中,线程作为最小调度单位,进程作为资源分配的最小单位,在Windows中进程是不活动的,知识作为线程的容器. 1.1.3 二者对比 进程基本上相互独立,线程在进程内,是进程的一个子集. 进程拥有共享的资源,如内存空间等,供内部的线程共享. 进程间通信较为复杂 同一台计算机的进程通信成为IPC 不同计算机之间的进程通信,需要通过网络,并遵守共同的协议. 线程通信相对简单,因为他们共享进程的内存,一个例子是多个线程可以访问同一个共享变量 线程更轻量,线程上下文切换成本一般要比进程上下文切换低. ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:1","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"1.2 并行与并发 单核cpu下,线程实际还是串行执行的.操作系统中有一个组件叫做任务调度器,将cpu的时间片分给不同的线程使用,只是由于cpu在线程间的切换非常快,感觉是同时运行的. 一般会将这种线程轮流使用cpu的做法成为并发. 多核cpu下,每个核都可以调度运行线程,这时候线程是并行的. 并发: 同一时间应对多件事情的能力. 并行: 同一时间动手做多件事情的能力. ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:2","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"1.3 应用 1.3.1 异步调用案例 从方法调用角度来说: 需要等地啊结果返回,才能继续运行就是同步 不需要等待结果返回,就能继续运行就是异步 注意: 同步在多线程中海油另外一层的意思,是让多个线程步调一致 设计: 多线程可以让方法执行变为异步的,比如说读取磁盘文件时,假设读取操作话费了5s,如果没有线程调度机制,这5s调用者什么都做不了,其代码都得暂停. 结论: 比如在项目中,视频文件需要转换格式等操作比较费时,这时开一个新线程处理视频转换,避免阻塞主线程. tomcat的异步servlet也是类似的目的,让用户线程处理耗时比较长的操作,避免阻塞tomcat的工作线程 1.3.2 提高效率案例 充分利用多核cpu的有事,提高运行效率.想象下面的场景,执行3个计算,最后将计算结果汇总. 计算 1 花费 10 ms 计算 2 花费 11 ms 计算 3 花费 5 ms 汇总需要 1 ms 如果是串行执行,name总共花费 10 + 11 + 5 + 1 = 27ms 但如果是四核cpu,各个核心分别使用线程1执行计算1 ,线程2执行计算2…..花费时间只取决于最长的那个线程运行的时间,及11ms 最后加上汇总的时间只会花费12ms 注意: 需要在多核cpu才能提高效率,单核仍然是轮流执行 结论 单核cpu下,多线程不能实际提高程序运行效率,知识为了能够在不同的任务之间切换,不同线程轮流使用cpu,不至于一个线程总占用cpu,别的线程没法干活 多核cpu可以并行跑多个线程,但能否提高程序运行效率还是要分情况的 有些任务,经过精心设计,将任务拆分,并行执行,当然可以提高程序的运行效率,但不是所有计算任务都能拆分 也不是所有任务都需要拆分,任务的目的如果不同,谈拆分和效率没啥意义 IO操作不占用cpu,知识我们一般拷贝文件使用的是阻塞IO,这相当于线程虽然不用cpu,但需要一直等待IO结束,没能充分利用线程,所以才有后面的非阻塞IO和异步IO优化 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:3","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2. Java线程 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:0","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.1 创建和运行线程 2.1.1 方法一,直接使用Thread public class CreateThread { public static void main(String[] args) { Thread t = new Thread(()-\u003e{ System.out.println(Thread.currentThread().getName()+ \"-\u003e\" + \"running...\"); }); t.setName(\"t1\"); t.start(); System.out.println(Thread.currentThread().getName()+ \"-\u003e\" + \"running...\"); } } 2.1.2 方法二,使用Runnable配合Thread public class CreateThreadByRunnable { public static void main(String[] args) { //创建任务对象 Runnable runnable = () -\u003e System.out.println(Thread.currentThread().getName() + \"-\u003e\" + \"running\"); Thread t1 = new Thread(runnable, \"t1\"); t1.start(); System.out.println(Thread.currentThread().getName() + \"-\u003e\" + \"running\"); } } 2.1.3 方法三,FutureTask配置Thread public class CreateThreadByFutureTask { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask\u003cString\u003e futureTask = new FutureTask\u003c\u003e(()-\u003e{ System.out.println(Thread.currentThread().getName() + \"running...\"); Thread.sleep(2000); return \"continue running...\"; }); Thread thread = new Thread(futureTask,\"t1\"); thread.start(); System.out.println(futureTask.get()); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:1","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.2 观察多个线程同时运行 主要是理解 交替执行 谁先谁后,不由我们控制 public class ThreadRunSameTime { public static void main(String[] args) { //线程t1 new Thread(()-\u003e{ while (true) { System.out.println(Thread.currentThread().getName()+ \"running...\"); } },\"t1\").start(); //线程t2 new Thread(()-\u003e{ while (true) { System.out.println(Thread.currentThread().getName()+ \"running...\"); } },\"t2\").start(); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:2","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.3 查看进程线程的方法 linux ps -fe 查看所有进程 ps -fT -p 查看某个进程(PID) 的所有信息 kill 杀死进程 top 按大写H切换是否显示进程 top -H -p 查看某个进程(PID)的所有信息 Java jps 查看所有Java进程 jstack 查看某个Java进程(PID)的所有线程状态 jconsole 查看某个Java进程中线程的运行状态(图形界面) ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:3","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.4 线程运行原理 2.4.1 栈与栈帧 我们知道JVM中由堆,栈,方法区所组成,其中栈内存是给谁用的呢?其实就是线程,每个线程启动后,虚拟机就会为其分配一块栈内存. 每个栈由多个栈帧(Frame)组成,对应着每个方法调用时所占用的内存 每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法 2.4.2 线程上下文切换(Thread Context Switch) 因为以下一些原因导致cpu不在执行当前线程,转而执行另一个线程的代码 线程的cpu时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用sleep,yield,wait,join,park,synchronized,lock等方法 当Context Switch 发生时,需要由操作系统保存当前线程的状态,并恢复另一个线程的状态,Java中对应的概念就是程序计数器,它的作用就是记住下一条jvm指令的执行地址,是线程私有的 状态包括程序计数器,虚拟机栈中的每个栈帧的信息,如局部变量,操作数栈,返回地址等 COntext Switch 频繁发生会影响性能 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:4","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.5 常见方法 方法名 功能说明 注意 start() 启动一个新线程,在新的线程运行run方法中的代码 start方法只是让线程进入就绪,里面代码不一定立刻执行(cpu的时间片还没分给它).每个线程对象的start方法只能调用一次,如果调用了多次会出现IllegalThreadStateException run() 新线程启动后会调用的方法 如果在构造Thread对象时传递了Runnable参数,则线程启动后会调用Runnable中的run方法,否则默认不执行任何操作,但可以创建Thread的子类对象,来覆盖默认行为 join() 等待线程运行结束 join(long n) 等待线程运行结束最多等待n毫秒 getId() 获取线程长整形id id唯一 getName() 获取线程名 setName(String) 修改线程名 getPriority() 获取线程优先级 setPriority(int) 修改线程优先级 Java中规定线程优先级是1~10的整数,较大的优先级能提高该线程被cpu调用的几率 getState() 获取线程黄台 Java中线程状态是用6个enum表示,分别是: NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED isInterrupted() 判断是否被打断 不会清除 isAlive 线程是否存活 interrupt() 打断线程 如果被打断线程正在sleep,wait,join会导致被打断的线程抛出InterruptedExcepiton,并清除打断标记;如果打断的正在运行的线程,则会设置打断标记;park的线程被打断,也会设置打断标记 interrupted() (static) 判断当前线程是否打断 会清除打断标记 currentThread() (static) 获取当前正在执行的线程 sleep(long n) (static) 让当前执行的线程休眠n毫秒,休眠时让出cpu的时间片给其他线程 yield() (static) 提示线程调度器让出当前线程对cpu的使用 主要用于测试和调试 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:5","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.6 start与run 调用run public class StartAndRun { public static void main(String[] args) { Thread thread = new Thread(\"t1\"){ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"running...\"); } }; thread.run(); System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"do other things...\"); } } 程序仍然在main线程运行,方法调用还是同步 调用start public class StartAndRun { public static void main(String[] args) { Thread thread = new Thread(\"t1\"){ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"running...\"); } }; //thread.run(); thread.start(); System.out.println(thread.getState()); System.out.println(Thread.currentThread().getName() + \"-\u003e\" +\"do other things...\"); } } 方法调用是异步的!!!! ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:6","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.7 sleep与yield sleep 调用sleep会让当前线程从Running进入Timed Waiting状态 其他线程可以使用interrupt方法打断正在睡眠的线程,这是sleep方法会抛出InterrupttedException 睡眠结束后的线程尾部会立刻得到执行 建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性 yield 调用yield会让当前线程从Running进入Runnable状态,然后调度执行其他同优先级的线程.如果这是没有同优先级的线程,name不能保证让当前线程暂停的效果 具体的实现依赖操作系统的任务调度器 线程优先级 线程优先级会提示(hint)调度器优先级调度该线程,但他仅仅是一个提示,调度器可以忽略他 如果cpu比较忙,name优先级高的线程会获得更多的时间片,但cpu闲时,优先级几乎没有用 public class Priority { public static void main(String[] args) { //任务一 Runnable task1 = ()-\u003e{ int count = 0; for(;;){ System.out.println(Thread.currentThread().getName() + \"-\u003e\" +count++); } }; //任务二 Runnable task2 = ()-\u003e{ int count = 0; for(;;){ //让出时间片 Thread.yield(); System.out.println(Thread.currentThread().getName() + \"-----------------\u003e\" +count++); } }; Thread t1 = new Thread(task1, \"t1\"); Thread t2 = new Thread(task2, \"t2\"); t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); t1.start(); t2.start(); } } 案例-防止CPU占用100% sleep实现: 在没有利用cpu计算时,不要让while(true)空转浪费cpu,这时可以使用yield或sleep来让出cpu的使用权给其他程序 while (true){ try { Thread.sleep(500); }catch (InterruptedException e){ e.printStackTrace(); } } } 可以用wait或条件变量达到类似的效果 不同的是,或两种都需要加锁,并且需要响应的唤醒操作,一般适用于进行同步的场景 sleep使用与无需锁同步的场景 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:7","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.8 join方法详解 为什么需要join? public class JoinThread { static int count = 0; public static void main(String[] args) { test(); } public static void test(){ Thread t1 = new Thread(()-\u003e{ try { System.out.println(\"start\"); sleep(1); System.out.println(\"end\"); count = 10; } catch (InterruptedException e) { e.printStackTrace(); } }); thread.start(); System.out.println(\"结果是---\u003e\" +count); System.out.println(\"end\"); } } 分析: 因为主线程和线程t1是并行执行的,t1线程需要1秒后才能得到count = 10 而主线程一开始就要打印count的结果,所以只能打印count = 0 解决方法 主线程中对t1调用join()方法,等待t1线程执行完毕 public class JoinThread { static int count = 0; public static void main(String[] args) throws InterruptedException { test(); } public static void test() throws InterruptedException { Thread t1 = new Thread(()-\u003e{ try { System.out.println(\"start\"); sleep(1); System.out.println(\"end\"); count = 10; } catch (InterruptedException e) { e.printStackTrace(); } }); t1.start(); t1.join(); System.out.println(\"结果是---\u003e\" +count); System.out.println(\"end\"); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:8","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.9 interrupt方法详解 打断sleep,wait,join的线程 public class InterruptThread { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ try { System.out.println(\"sleep...\"); Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); t1.start(); Thread.sleep(2000); t1.interrupt(); System.out.println(\"打断标记-\u003e\" + t1.isInterrupted()); } } 打断正常运行的线程(不会清空打断标记) public class InterruptNormalThread { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ while (true){ boolean flag = Thread.currentThread().isInterrupted(); if (flag){ System.out.println(\"打断状态-\u003e\" + flag); break; } System.out.println(\"打断状态-\u003e\" + flag); } },\"t1\"); t1.start(); Thread.sleep(1000); System.out.println(\"interrupt\"); t1.interrupt(); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:9","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.10 两阶段终止模式 在一个线程T1中如何\"优雅\"的终止线程T2? 这里的\"优雅\" 指的是给T2一个机会去料理后事; 错误思路: 使用线程对象的stop方法停止 stop方法会真正杀死线程,如果这是线程锁住了共享资源,那么当他被杀死后就再没机会释放锁,其他区线程将永远无法获取锁 使用System.exit(int) 方法停止线程 目的仅仅是停止一个线程,但这种做法会让整个程序都停 实现: public class TwoPhaseTerminationTest { public static void main(String[] args) throws InterruptedException { TwoPhaseTermination twoPhaseTermination = new TwoPhaseTermination(); twoPhaseTermination.start(); Thread.sleep(3000); twoPhaseTermination.stop(); } } class TwoPhaseTermination { private Thread monitor; /** * 启动线程 * @return void */ public void start(){ monitor = new Thread(()-\u003e{ Thread current = Thread.currentThread(); while (true){ if (current.isInterrupted()){ System.out.println(\"线程被打断了\"); break; } try { // 情况一: 睡眠状态被打断 Thread.sleep(1000); // 情况二: 执行监控记录被打断 System.out.println(\"执行监控记录\"); } catch (InterruptedException e) { e.printStackTrace(); //重新设置打断标记 monitor.interrupt(); } } }); // 启动线程 monitor.start(); } /** * 停止线程 * @return void */ public void stop(){ monitor.interrupt(); } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:10","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.11 打断park线程 public class InterruptParkThread { public static void main(String[] args) throws InterruptedException { test(); } public static void test() throws InterruptedException { Thread t1 = new Thread(()-\u003e{ System.out.println(\"park...\"); LockSupport.park(); System.out.println(\"unPark...\"); System.out.println(\"打断状态-\u003e\" + Thread.currentThread().isInterrupted()); },\"t1\"); t1.start(); Thread.sleep(1000); t1.interrupt(); } } 打断标记为true时,park失效 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:11","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.12 不推荐的方法 还有一些不推荐的方法,这些方法已经过时,容易破坏同步代码块,造成线程死锁 方法名 功能说明 stop() 停止线程运行 suspend() 挂起(暂停)线程运行 resume() 恢复线程运行 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:12","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.13 主线程与守护线程 默认情况下,Java进程需要等待所有线程都运行结束,才会结束,有一种特殊的线程叫做守护线程,只要其他守护线程运行结束,即使守护线程的代码没有执行完,也会强制结束. 例如: public class DaemonThread { public static void main(String[] args) throws InterruptedException { Thread daemon = new Thread(()-\u003e{ while (true){ System.out.println(\"running...\"); } }); // 设置为守护线程 daemon.setDaemon(true); daemon.start(); Thread.sleep(1000); System.out.println(\"end...\"); } } 注意: 垃圾回收线程就是一种守护线程 Tomcat中的Acceptor和Poller线程都是守护线程,所以Tomcat接受到shutdown命令后,不会等待他们处理完当前请求 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:13","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.14 五种状态 这是从操作系统层面来描述的: 初始状态: 仅是在语言层面创建了线程对象,还未与操作系统线程关联 可运行状态: (就绪状态) 指该线程已经被创建(与操作系统线程关联).可以由cpu调度执行 运行状态: 指获取了cpu时间片运行中的状态 当cpu时间片用完,会从运行状态转换至可运行状态,会导致线程的上下文切换 阻塞状态 如果调用了阻塞API,如BIO读写文件,这时该线程实际不会用到cpu,会导致线程上下文切换,进入阻塞状态 等BIO操作完毕,会由操作系统唤醒阻塞的线程,转换至可运行状态 与可运行状态的区别是,对阻塞状态的线程来说只要他们一直不唤醒,调度一直不会考虑调度他们 终止状态: 表示线程已经执行完毕,声明周期已经结束,不会再转换为其他状态 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:14","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"2.15 六种状态 这是从Java API层面来描述的,根据Thread.State枚举,分为6种状态 NEW: 线程刚被创建,但是还没有调用start()方法 RUNNABLE当调用了start()方法之后,注意,Java API层面的RUNNABLE状态涵盖了操作系统层面的 可运行状态,运行状态和阻塞状态(由于BIO导致的线程阻塞,在Java中无法区分,仍然认为是可运行的) BLOCKED,WAITING,TIMED_WAITING都Java API层面对阻塞状态的细分 TERMINATED: 当线程代码运行结束 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:15","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3. 共享模型之管程 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:0","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.1 共享带来的问题 Java的体现: public class SimultaneousOperation { static int count = 0; public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { count++; } },\"t1\"); Thread t2 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { count--; } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count); } } 临界区 Critical Section 一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源 多个线程读共享资源其实也没问题 在多个线程对共享资源读写操作时发生指令交错,就会出现问题 竞态条件 Race Condition 多个线程在临界区内执行,由于代码的执行序列不同而导致结果无法预测,称之为发生了竞态条件 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:1","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.2 Synchronized 解决方案 为了避免临界区的竞态条件发生,有多种手段可以达到目的. 阻塞式的解决方案: synchronized,Lock 非阻塞式的解决方案: 原子变量 使用synchronized来解决上述问题,即俗称的\"对象锁\",他采用互斥的方式让同一时刻至多只能有一个线程能持有\"对象锁\",其他线程再想获取这个\"对象锁\"时就会阻塞住.这样就能保证拥有锁的线程可以安全的执行临界区的代码,不用担心线程上下文的切换 synchronized 语法: synchronized(对象) { 临界区 } 解决: public class SimultaneousOperation { static int count = 0; static final Object lock = new Object(); public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { synchronized (lock){ count++; } } },\"t1\"); Thread t2 = new Thread(()-\u003e{ for (int i = 0; i \u003c 5000; i++) { synchronized (lock){ count--; } } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(count); } } synchronized实际是用对象锁保证了临界区内代码的原子性,临界区的代码对外是不可分割的,不会被线程切换所打断 面向对象改进 public class SimultaneousOperation { public static void main(String[] args) throws InterruptedException { Room room = new Room(); Thread t1 = new Thread(() -\u003e { for (int i = 0; i \u003c 5000; i++) { room.increase(); } }, \"t1\"); Thread t2 = new Thread(() -\u003e { for (int i = 0; i \u003c 5000; i++) { room.reduce(); } }, \"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(room.getValue()); } } //面向对象改进 class Room{ private int count = 0; /** * 加操作 * @return void */ void increase(){ synchronized (this){ count++; } } /** * 减操作 * @return void */ void reduce(){ synchronized (this){ count--; } } /** * 获取值 * @return int */ int getValue(){ synchronized (this){ return count; } } } ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:2","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.3 方法上的synchronized 成员方法上的synchronized等于锁这个对象 静态方法上的synchronized等于锁这个类对象 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:3","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.4 变量的线程安全分析 成员变量和静态变量是否线程安全? 如果他们没有共享,则线程安全 如果他们被共享了,根据他们的状态是否能够改变,又分两种情况 如果只有读操作,则线程安全 如果有读写操作,则这段代码是临界区,需要考虑线程安全 局部变量是否线程安全? 局部变量是线程安全的 但局部变量引用的对象则未必 如果该对象没有逃离方法的作用访问,他是线程安全的 如果该对象逃离方法的作用范围,需要考虑线程安全 常见线程安全类 String Integer StringBuffer Random Vector Hashtable java.util.concurrent包下的类 这里说他们是线程安全是指,多个线程调用他们同一个实例的某个方法时,是线程安全的. 他们的每个方法时原子的 但注意他们多个方法的组合不是原子的 不可变类线程安全性 String,Integer等都是不可变类,因为其内部的状态不可以改变,因此他们的方法都是线程安全的 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:4","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.5 Monitor概念 Monitor(锁) Monitor被翻译成监视器或管程 每个Java对象都可以关联一个Monitor对象,如果使用synchronized给对象上锁之后,.该对象头的Mark Word中就被设置指向Monitor对象的指针 Monitor结构如下: 刚开始Monitor中Owner为null 当Thread-2执行synchronized(obj)就会将Monitor中的所有者Owner置为Thread-2,Monitor中只能有一个Owner 在Thread-2上锁的过程中,如果Thread-3,Thread-4,Thread-5也来执行synchronized(obj),就会进入EntryList BLOCKED Thread-2执行完同步代码块中的内容,然后唤醒EntryList中等待的线程来竞争锁,竞争时是非公平的 WaitSet中的Thread-0,Thread-1是之前获得过锁,但条件不满足进入WAITING状态的线程 注意: synchronized必须是进入同一个对象的monitor才有的效果 不加synchronized的对象不会关联监视器,不遵从以上规则 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:5","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.6 synchronized原理进阶 轻量级锁 创建锁记录(Lock Record)对象,每个线程的栈帧都会包含一个锁记录的结构,内部可以存储锁定对象的Mark Word 让锁记录中的Object reference指向锁对象,并尝试用cas替换Object的Mark Word,将Mark Word的值存入锁记录 如果cas替换成功,对象头中存储了锁记录地址和状态00,表示由该线程给对象加锁 如果cas替换失败,有两种情况 如果是其他线程已经持有该Object的轻量级锁,这时表明有竞争,进入锁膨胀过程 如果是自己执行了synchronized锁重入,那么在添加一条Lock Record作为重入的计数 当退出synchronized代码块时(解锁时),如果有取值为null的锁记录,表示有重入,这时重置锁记录,表示重入计数减一 当退出synchronized代码块(解锁时)锁记录的值不为null,这时使用cas将Mark Word的值恢复给对象头 成功,则解锁成功 失败,说明轻量级锁进入了锁膨胀或已经升级为重量级锁,进入重量级锁解锁流程 锁膨胀 如果在尝试加轻量级锁的过程中,CAS操作无法成功时,这时一种情况就是有其他线程为此对象加上了轻量级锁(有竞争),这时需要进行锁膨胀,将轻量级锁变为重量级锁 当Thread-1进行轻量级加锁时,Thread-0已经对该对象加了轻量级锁 这时Thread-1加轻量级锁失败,进入锁膨胀流程 即为Object对象申请Monitor锁,让Object指向重量级锁地址 然后进入Monitor的EntryList BLCOKED 当Thread-0退出同步块解锁时,使用cas将Mark Word的值恢复给对象头,失败.这时进入重量级解锁流程,按照Monitor地址找到Monitor对象,设置Owner为null,唤醒EntryList中的BLOCKED线程 自旋优化 重量级锁竞争的时候,还可以使用自旋来进行优化,如果当前线程自旋成功(即这时候持有锁线程已经退出了同步块,释放了锁),这时当前线程就可以避免阻塞 线程1(cpu1上) 对象Mark Word 线程2(cpu2上) - 10(重量级锁) - 访问同步块,获取monitor 10(重量级锁) - 成功(加锁) 10(重量级锁) - 执行同步块 10(重量级锁) - 执行同步块 10(重量级锁) 访问同步块,获取monitor 执行同步块 10(重量级锁) 自旋重试 执行完毕 10(重量级锁) 自旋重试 成功(解锁) 01(无锁) 自旋重试 - 10(重量级锁) 成功(加锁) - 10(重量级锁) 执行同步块 自旋失败,会阻塞 在Java6以后自旋锁是自适应的,比如对象刚刚的一次自旋操作成功过,那么认为这次自旋成功的可能性会高,就多自旋几次 自旋会占用cpu时间,单核cpu自旋就是浪费,多核cpu自旋才能发挥优势 Java7之后不能控制是否开启自旋功能 偏向锁 轻量级锁在没有竞争时(就自己这个线程),每次重入仍然需要执行CAS操作. Java6中引入了偏向锁来做进一步优化,只有第一次使用CAS操作将线程ID设置到对象的Mark Word中,之后发现这个线程ID是自己的表示没有竞争,不用重新CAS.以后只要不发生竞争,这个对象就归该线程所有 1. 偏向状态 一个对象创建时: 如果开启了偏向锁(默认开启),name对象创建以后,markWord值为0x05即最后3位位101,这时他的thread,epoch,age都为0 偏向锁默认是延迟的,不会在程序启动时立即生效,如果想避免延迟,可以加VM参数:-xx:BiasedLockingStartupDelay=0来禁用延迟 如果没有开启偏向锁,那么对象创建后,MarkWord值为0x01即最后3位位001,这时他的hashcode,age都为0,第一次用到hashcode时才会赋值 2. 撤销-调用对象hashCode 调用了对象的hashCode,但偏向锁的对象MarkWord中存储的是线程id,如果调用hashCode会导致偏向锁被撤销 轻量级锁会在锁记录中记录hashCode 重量级锁会在Monitor中记录hashCode 在调用hashCode后使用偏向锁,记得去掉-xx:-UseBiasedLocking 3. 撤销-其他线程使用对象 当其他线程使用偏向锁对象时,会将偏向锁升级为轻量级锁 4. 撤销-调用wait/notify 5. 批量重偏向 如果对象虽然被多个线程访问,但没有竞争,这时偏向了线程t1的对象仍有机会重新偏向t2,重偏向会重置对象的线程id 当撤销偏向锁阈值20次后,jvm会觉得,我是不是偏向错了,于是会给这些对象加锁时重新偏向加锁线程 6. 批量撤销 当撤销偏向锁阈值超过40次后,jvm会这样觉得,自己确实偏向错了,根本就不应该偏向,于是整个类的所有对象都会变为不可偏向,新建的对象也是不可偏向 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:6","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.7 wait notify介绍 wait/notify原理 Owner线程发现条件不满足,调用wait方法,即可进入WatiSet变为WAITING状态 BLOCKED和WAITING的线程都处于阻塞状态,不占用CPU时间片 BLOCKED线程会在Owner线程释放锁时唤醒 WAITING线程会在Owner线程调用notify或notifyAll时唤醒,但唤醒后并不意味着立刻获得锁,仍需进入EntryList重新竞争 API介绍 obj.wait()让进入object监视器的线程到WaitSet等待(无限制等待) obj.wait(long timeout)有时限的等地啊,到n毫秒后结束等待,或是被notify obj.notify()让object上正在WaitSet等待的线程中挑一个唤醒 obj.notifyALl()让object上正在WaitSet等待的线程全部唤醒 他们都是线程之间进行协作的手段,都属于Object对象的方法,必须获得此对象的锁,才能调用这几个方法 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:7","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["并发编程"],"content":"3.8 wait/notify正确使用 sleep(long n)和wait(long n)的区别 sleep是Thread方法,而wait是Object的方法 sleep不需要强制和synchronized配合使用,但wait需要 sleep在睡眠的同时,不会释放锁对象的,但wait在等待的时候会释放锁对象 ","date":"2022-01-22","objectID":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:8","tags":["多线程","并发"],"title":"并发编程","uri":"/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["算法与数据结构"],"content":"1. comparable接口 代码测试: package Sort.comparable; public class student implements Comparable\u003cstudent\u003e{ private String username; private int age; public student() { } public student(String username, int age) { this.username = username; this.age = age; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"student{\" + \"username='\" + username + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(student o) { return this.getAge()-o.getAge(); } } package Sort.comparable; public class comparableTest { //创建两个对象 public static void main(String[] args) { student s1 = new student(); student s2 = new student(); s1.setUsername(\"张三\"); s1.setAge(15); s2.setUsername(\"李四\"); s2.setAge(17); Comparable max = getMax(s1, s2); System.out.println(max); } public static Comparable getMax(Comparable c1,Comparable c2){ int result = c1.compareTo(c2); if (result\u003e=0){ return c1; }else { return c2; } } } ","date":"2021-02-18","objectID":"/sort/:0:1","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"2. 冒泡排序 排序原理: 比较相邻的元素,如果前一个元素比后一个元素大,就交换这两个元素; 对每一对相邻的元素做同样的工作,从开始第一对元素到结尾的最后一个元素;最终最后位置的元素就是最大值; 代码实现: /*冒泡排序*/ public class MyBubble { public static void sort(Comparable[] a ){ for (int i = a.length; i \u003e0 ; i--) { for (int j = 0; j \u003c i; j++) { //比较两个索引处的大小 if (greater(a[j],a[j])){ exchange(a,j,j+1); } } } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MyBubbleTest { public static void main(String[] args) { Integer[] arr={1,4,6,7,2,9}; MyBubble.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:2","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"3. 选择排序 排序原理: 每一次遍历的过程中,都假定第一个索引处的元素是最小值,和其他索引处的值一次进行比较,如果当前索引处的值大于其他某个索引处的值,则假定其他某个索引处的值为最小值,最后可以找到最小值所在的索引; 交换第一个索引处和最小值所在的索引处的值; 代码实现: public class MySelection { public static void sort(Comparable [] a){ for (int i = 0; i \u003c= a.length - 2; i++) { int minIndex=i; for (int j = i+1; j \u003c a.length; j++) { if (greater(a[minIndex],a[j])){ minIndex=j; } } exchange(a,i,minIndex); } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MySelectionTest { public static void main(String[] args) { Integer[] arr={1,4,6,5,9,7}; MySelection.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:3","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"4. 插入排序 原理: 把所有的元素分为两组,已经排序的和未排序的; 找到未排序的组中的第一个元素,向已经排序的组中进行插入; 倒叙遍历已经排序的元素,一次和待插入的元素进行比较,知道找到一个元素小于等于待插入元素,那么就把待插入元素放到这个位置,其他元素向后移动一位; 代码实现: /*插入排序*/ public class MyInsertion { public static void sort(Comparable[] a){ for (int i = 1; i \u003c a.length; i++) { for (int j = i; j \u003e=0 ; j--) { if (greater(a[j-1],a[j])){ exchange(a,j,j-1); }else { break; } } } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MyInsertionTest { public static void main(String[] args) { Comparable[] arr={1,4,6,8,9,3,6,8}; MyInsertion.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:4","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"5. 希尔排序 排序原理: 选定一个增长量h,按照曾长量h作为数据分组的依据,对数据进行分组; 对分好组的每一组数据完成插入排序; 减小曾长量,最小减为3,重复第二步操作; 增长量h的确定(没一固定的原则): int h=1; while(h\u003cleng/2){ h=2*h+1; } //循环结束后我们就可以确定h的最大值; h的减小规则为: h=h/2 代码实现: public class MyShell { public static void sort(Comparable[] a){ //得到曾长量h的值 int h=1; while(h\u003ca.length/2){ h=h*2+1; } while (h\u003e=1){ //找到待插入的元素 for (int i = h; i \u003ca.length ; i++) { //把待插入的元素插入到有序序列中 for (int j = i; j \u003e=h ; j-=h) { if (greater(a[j-h],a[j])){ exchange(a,j-h,j); }else { //待插入元素找到合适位置,结束循环 break; } } } //减小曾长量h h=h/2; } } //比较两个元素的大小 public static boolean greater(Comparable a,Comparable b){ return a.compareTo(b)\u003e0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } } 代码测试: import java.util.Arrays; public class MyShellTest { public static void main(String[] args) { Comparable[] arr={1,5,8,9,5,8,5,9,45,67,23,7}; MyShell.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:5","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"6. 归并排序 排序原理: 尽可能的一组数据拆分成两个元素的子组,并对每一个子组继续拆分,知道拆分后的每个子组的元素个数是1为止; 将相邻的两个子组进行合并成一个有序的大组; 不断的重复步骤2,知道最终只有一个组为止; 归并排序API设计: 类名 Merge 构造方法 Merge():创建Merge对象 成员方法 1.public static void sort(Comparable[] a):对组内元素进行排序 2. private static void sort(Comparable[] a ,int left,int right):对组内索引lo到索引hi的元素进行排序 3.private static void merge(Comparable[] a ,int left,int mid,int right):从索引left到索引mid为一个子组,从索引mid+1到索引right为另一个子组,吧数组a中的这两个子组的数据合并成一个有序的大组(从索引leftPos到索引rightPos) 4.private static boolean less(Comparable v,Comparable w):判断v是否小于w 成员变量 1.private static Comparable[] assist:完成归并操作需要的辅助数组 代码实现: package Sort.merge; public class MyMerge { //归并所需要的辅助数组 private static Comparable[] assist; //比较a是否小于b public static boolean less(Comparable v,Comparable w){ return v.compareTo(w)\u003c=0; } //对数组a中的元素进行排序(private递归型方法sort的驱动程序) public static void sort(Comparable[] a){ //初始化辅助数组 assist = new Comparable[a.length]; int left=0; int right=a.length-1; sort(a,left,right); } //对数组a中lo到hi的元素进行排序 private static void sort(Comparable[] a,int left,int right){ //安全性检验 if(right\u003c=left) return; int mid=(left+right)/2; sort(a,left,mid); sort(a,mid+1,right); merge(a,left,mid+1,right); } /*对数组中,从lo到mid为一组,mid+1到hi为一组, leftPos,rightPos分别记录左右两数组中的开始位置,rightEnd记录最后的位置*/ private static void merge(Comparable[]a ,int leftPos,int rightPos,int rightEnd){ //记录左边数组的最后位置 int leftEnd=rightPos-1; //记录辅助数组的位置 int assistPos=leftPos; //当左右数组都还有元素 while (leftPos\u003c=leftEnd \u0026\u0026 rightPos\u003c=rightEnd) //判断元素大小 if (less(a[leftPos],a[rightPos])) assist[assistPos++]=a[leftPos++]; else assist[assistPos++]=a[rightPos++]; //当左数组没有元素时 while (rightPos\u003c=rightEnd) assist[assistPos++]=a[rightPos++]; //当右数组没有元素时 while (leftPos\u003c=leftEnd) assist[assistPos++]=a[leftPos++]; //拷贝回原数组 for (int i = 0; i \u003c rightPos; i++,rightEnd--) { a[rightEnd]=assist[rightEnd]; } } } 测试代码: package Sort.merge; import java.util.Arrays; public class MyMergeTest { public static void main(String[] args) { Comparable[] arr={3,4,5,7,9,7,4,9,32,45,33,55,33}; MyMerge.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:6","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"7. 快速排序 排序原理: 首先设定一个分界值,通过该分界值将数组分成左右两个部分; 将大于或等于分界值的数据放到数组右边,小于分界值的数据放到数组的左边,此时左边部分中各元素都小于分界值,而右边部分中各元素都大于或等于分界值; 然后,左边和右边的数据可以独立排序.对于左侧的数组数据,又可以取一个分界值,将该部分数据分成左右两个部分,同样在左边放置较小值,右边放置较大值.右侧的数组数据也可以做类似处理; 重复上述过程,可以看出,这是一个递归定义.通过递归将左侧部分拍好序,在递归排好右边部分的顺序,当左侧和右侧两个部分的数据排完序后,整个数组的排序也就完成了; 快速排序API设计: 类名 Quick 构造方法 Quick():创建Quick对象 成员方法 1.public static void sort(Comparable[] a):对组内元素进行排序 2. private static void sort(Comparable[] a ,int left,int right):对组内索引lo到索引hi的元素进行排序 3.private static int partition(Comparable[] a ,int left , int right):对数组a中,从索引left到索引right进行分组,并返回分组界限对应的索引 4.private static boolean less(Comparable v,Comparable w):判断v是否小于w 切分原理: 一个数组气氛成两个子数组的基本思想: 找一个基准值,用两个指针分别指向数组的头部和尾部; 先从尾部向头部开始搜索一个比基准值小的元素,搜索到即停止,并记录指针的位置; 再从头部向尾部开始搜索一个比基准值大的元素,所有到即停止,并记录指针的位置; 交换当前左边指针位置和右边指针位置的元素; 重复2,3,4步骤,知道左边指针的值大于右边指针的值停止; 代码实现: public class MyQuick { public static void sort(Comparable[] a){ int left=0; int right=a.length-1; sort(a,left,right); } //对数组索引left到right进行排序 private static void sort(Comparable [] a,int left,int right){ if (right\u003cleft){ return; } //对数组索引left到right之间的元素进行分组(左子组,右子组) int partition = partition(a, left, right);//返回的是变化后的分界值索引 //让左子组有序 sort(a,left,partition-1); //让右子组有序 sort(a,partition+1,right); } //比较a是否小于b public static boolean less(Comparable v,Comparable w){ return v.compareTo(w)\u003c=0; } //两元素互换位置 public static void exchange(Comparable[] a,int i,int j){ Comparable temp; temp=a[i]; a[i]=a[j]; a[j]=temp; } //对数组a中,索引left到right之间的元素进行分组,并返回分界值对应的索引 public static int partition(Comparable[] a,int left,int right){ //确定分界值 Comparable key=a[left]; //定义两个指针,分别指向切分元素最小索引处和最大索引处的下一个元素 int leftPos=left; int rightPos=right+1; //切分 while(true){ //从右往左扫描,移动rightPos指针,遇到比key小的值就停止 while (less(key,a[--rightPos])){ if (rightPos==left){ break; } } //从左往右扫描,移动leftPos指针,遇到比key大的值就停止 while (less(a[++leftPos],key)){ if (leftPos==right){ break; } } //判断leftPos\u003e=rightPos,如果是,则结束,不是则交换元素 if (leftPos\u003e=rightPos){ break; }else { exchange(a,leftPos,rightPos); } //分界值和相遇的元素交换 } exchange(a,left,rightPos); return rightPos; } } 代码测试: package Sort.quick; import java.util.Arrays; public class MyQuickTest { public static void main(String[] args) { Integer [] arr={6,1,2,7,9,3,4,5,8}; MyQuick.sort(arr); System.out.println(Arrays.toString(arr)); } } ","date":"2021-02-18","objectID":"/sort/:0:7","tags":["排序"],"title":"Sort","uri":"/sort/"},{"categories":["算法与数据结构"],"content":"1. 二叉查找树 二叉树结点类API的设计: 类名 Node\u003cKey,Value\u003e 构造方法 Node(Key key,Value value,Node left,Node right):创建Node对象 成员变量 1. public Node left:记录左子结点 2. public Node right:记录右子结点 3. public Key key:存储键 4. public Value value:存储值 代码实现: public class Node\u003cKey,Value\u003e { //存储键 public Key key; //存储值 public Value value; //存储左子结点 public Node left; //存储右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) { this.key = key; this.value = value; this.left = left; this.right = right; } } 二叉查找树的API设计 类名 BinaryTree\u003cKey extends Comparable,Vlaue value\u003e 构造方法 BinaryTree():创建BinaryTree对象 成员变量 1. private Node root:记录根结点 2. private int N :记录树中元素的个数 成员方法 1. public void put(Key key,Value value):向书中插入一个键值对 2. private Node put(Node x,Key key,Value value):给指定树x上,添加一个键值对,并返回添加后的新树 3. public Value get(Key key):根据key从书中找出相对应的值 4. private Value get(Node x,Key key):从指定的数x中,找出key对应的值 5. public] void delete(Key key):根据key,删除数中对应的键值对 6. private Node delete(Node x,Key key):删除指定树x上的键为key的键值对,并返回删除后的新树 7. public int size():获取树中元素的个数 二叉查找树实现 如果当前树中没有任何一个结点,则直接把新节点当做根结点使用 如果当前树不为空,则从根结点开始: 如果新结点的key小于当前结点的key,则继续找当前结点的左子节点; 如果新结点的key大于当前结点的key,则继续找当前结点的右子节点; 如果新结点的key等于当前结点的key,则树中已经存在这样的结点,替换该结点的value值即可; 代码实现: //向指定的树x中添加key-value,并返回添加元素后的新树 public Node put(Node x,Key key,Value value){ //如果x子树为空 if (x==null){ //元素个数+1 N++; return new Node(key,value,null,null); } //如果x子树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 x.right = put(x.right, key, value); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 x.left=put(x.left,key,value); }else { //如果key等于x结点的键,则替换x结点的值为value x.value=value; } return x; } 查询方法get实现思想: 从根结点开始: 如果要查询的key小于当前结点的key,则继续寻找当前结点的左子结点; 如果要查询的key大于当前结点的key,则继续寻找当前结点的右子结点; 如果要查询的key等于当前结点的key,则树中返回当前结点的value. 代码实现: //从指定的数x中,查询key对应的值 public Value get(Node x,Key key){ //如果x子树为空 if (x==null){ return null; } //如果x子树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 return get(x.right,key); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 return get(x.left,key); }else { //如果key等于x结点的键,则找到了键为key的结点,返回x结点的value即可 return x.value; } } 删除方法delete的实现思想: 找到被删除结点; 找到被删除结点右子树的最小结点minNode 删除右子树中的最小结点 让被删除结点的左子树称为最小结点minNode的左子树,让被删除结点的右子树称为最小结点minNode的右子树 让被删除结点的父结点指向最小结点minNode 代码实现: //删除指定树中key对应的value,并返回删除后的新树 public Node delete(Node x,Key key){ //如果x树为空 if (x==null){ return null; } //如果x树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 x.right= delete(x.right,key); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 x.left=delete(x.left,key); }else { //元素个数-1 N--; //如果key等于x结点的键,则要删除的结点就是x; //寻找右子树的最小结点 if (x.right==null){ return x.left; } if (x.left==null){ return x.right; } //默认情况记为右子树 Node minNode = x.right; while (minNode.left!=null){ minNode=minNode.left; } //删除右子树中的最小结点 Node n = x.right; while (n.left!=null){ if (n.left.left==null){ n.left=null; }else{ //变换n结点 n=n.left; } } //让x结点的左子树成为minNode的左子树 minNode.left=x.left; //让x结点的右子树成为minNode的右子树 minNode.right=x.right; //让x结点的父结点指向minNode x = minNode; } return x; } 完整代码: public class MyBinaryTree\u003cKey extends Comparable\u003cKey\u003e,Value\u003e { //记录根结点 private Node root; //记录树中元素的个数 private int N; private class Node { //存储键 public Key key; //存储值 private Value value; //存储左子结点 public Node left; //存储右子结点 public Node right; public Node(Key key, Value value, Node left, Node right) { this.key = key; this.value = value; this.left = left; this.right = right; } } //获取树种元素的个数 public int size(){ return N; } //向树中添加元素key-value public void put(Key key, Value value){ root = put(root, key, value); } //向指定的树x中添加key-value,并返回添加元素后的新树 public Node put(Node x,Key key,Value value){ //如果x子树为空 if (x==null){ //元素个数+1 N++; return new Node(key,value,null,null); } //如果x子树不为空 //比较x结点的键和key的大小 int cmp = key.compareTo(x.key); if (cmp\u003e0){ //如果key大于x结点的键,则继续寻找x结点的右子树 x.right = put(x.right, key, value); }else if (cmp\u003c0){ //如果key小于x结点的键,则继续寻找x结点的左子树 x.left=put(x.left,key,value); }else { //如果key等于x结点的键,则替换x结点的值为value x.value=val","date":"2021-01-17","objectID":"/tree/:0:1","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"2. 二叉树的最小和最大键 查找二叉树中最小的键 在某些情况下,我们需要查找出数中存储所有元素的键的最小值,比如我们的树中存储的是学生的排名和姓名数据,那么需要查找出排名最低是多少名\u003e这里我们设计如下两个方法来完成: public Key min() 找出树中最小的值 private Node min(Node x) 找出指定树x中,最小键所在的结点 //找出整个树中的最小键 public Key min(){ return min(root).key; } //找出指定树中的最小键所在的结点 private Node min(Node x){ //判断x是否还有左子结点,如果有则继续向左找,如果没有,则x就是最小键所在的结点 if (x.left!=null){ return min(x.left); }else { return x; } } 查找二叉树中最大的键 public Key max() 找出树中最大的键 private Node max(Node x) 找出指定树x中,最大键所在的结点 //找出整个树中最大键 public Key max(){ return max(root).key; } //找到指定树中最大的键所在的结点 private Node max(Node x){ //判断x是否还有右结点,如果有,则继续向右找,如果没有,则x就是最大的键所在的结点 if (x.right!=null){ return max(x.right); }else{ return x; } } ","date":"2021-01-17","objectID":"/tree/:0:2","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"3. 二叉树的基础遍历 很多情况下,我们可能需要像遍历数组一样遍历树,从而拿出书中存储的每一个元素,由于树状结构和线性结构不一样,他没有办法从头开始依次向后遍历,所以存在如何遍历,也就是按照什么样的搜索路径进行遍历的问题. 我们可以把二叉树的遍历分为以下三种方式: 前序遍历: 先访问根结点,然后在访问左子树,最后访问右子树 中序遍历: 先访问左子树,中间访问根结点,最后访问右子树 后序遍历: 先访问左子树,在访问右子树,最后访问根结点 前序遍历 public Queue\u003cKey\u003e preErgodic():使用前序遍历,获取真个树中的所有键 private void proErgodic(Node x, Queue\u003cKey\u003e keys):使用前序遍历,把指定树x中的所有键放入到keys队列中 实现过程中,我们通过前序遍历,把每个结点的key取出,放入到队列中返回即可. 实验步骤: 把当前结点的key放入到队列中; 找到当前结点的左子树,如果不为空,递归遍历左子树; 找到当前结点的右子树,如果不为空,递归遍历右子树 代码实现: //获取整个树中的所有键 public MyQueue\u003cKey\u003e preErgodic(){ MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); preErgodic(root,keys); return keys; } //获取指定树x中的所有键,并放到keys队列中 private void preErgodic(Node x ,MyQueue\u003cKey\u003e keys){ //判断x是否为空 if (x==null){ return; } //把x结点的key放入keys队列中 keys.inQueue(x.key); //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } } 代码测试: package Tree.BinaryTree; import List.Queue.MyQueue; public class BinaryTreeErgodicTest { public static void main(String[] args) { MyBinaryTree\u003cString, String\u003e tree = new MyBinaryTree\u003c\u003e(); tree.put(\"E\",\"5\"); tree.put(\"B\",\"2\"); tree.put(\"G\",\"7\"); tree.put(\"A\",\"1\"); tree.put(\"D\",\"4\"); tree.put(\"F\",\"6\"); tree.put(\"H\",\"8\"); tree.put(\"C\",\"3\"); MyQueue\u003cString\u003e keys = tree.preErgodic(); for(String key:keys){ String value = tree.get(key); System.out.println(value); } } } 中序遍历 public Queue\u003cKey\u003e minErgodic():使用中序遍历,获取整个树的所有键 private void midErgodic(Node x, Queue\u003cKey\u003e keys):使用中序遍历,把指定树x的素有键放入到keys队列中 实现步骤: 找到当前结点的左子树,如果不为空,递归遍历左子树; 把当前结点的key放到队列中; 找到当前结点的右子树,如果不为空,递归遍历右子树; 代码实现: //获取整个树中的所有键 public MyQueue\u003cKey\u003e midErgodic(){ MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); midErgodic(root,keys); return keys; } //获取指定树x中的所有键,并放到keys队列中 private void midErgodic(Node x ,MyQueue\u003cKey\u003e keys){ //判断x是否为空 if (x==null){ return; } //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //把x结点的key放入keys队列中 keys.enQueue(x.key); //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } } 后序遍历 实现步骤: 找到当前结点的左子树,如果不为空,递归遍历左子树; 找到当前结点的右子树,如果不为空,递归遍历右子树; 把当前结点的key放入到队列中; public Queue\u003cKey\u003e afterErgodic():使用中序遍历,获取整个树的所有键 private void afterErgodic(Node x, Queue\u003cKey\u003e keys):使用中序遍历,把指定树x的素有键放入到keys队列中 代码实现: //获取整个树中的所有键 public MyQueue\u003cKey\u003e afterErgodic(){ MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); afterErgodic(root,keys); return keys; } //获取指定树x中的所有键,并放到keys队列中 private void afterErgodic(Node x ,MyQueue\u003cKey\u003e keys){ //判断x是否为空 if (x==null){ return; } //递归遍历x结点的左子树 if (x.left!=null){ preErgodic(x.left,keys); } //递归遍历x结点的右子树 if (x.right!=null){ preErgodic(x.right,keys); } //把x结点的key放入keys队列中 keys.enQueue(x.key); } ","date":"2021-01-17","objectID":"/tree/:0:3","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"4. 二叉树层序遍历 所谓的层序遍历,就是从根结点(第一层)开始,依次向下,获取每一层所有结点的值; 实现: public Queue\u003cKey\u003e layerErgodic():使用层序遍历,获取整个树中的所有键 实验步骤: 创建队列,存储每一层结点; 使用循环从队列中弹出一个结点: 获取当前结点的key; 如果当前结点的左子节点不为空,则把左子节点放入队列中; 如果当前结点的右子结点不为空,则把右子节点放入队列中; 代码实现: public MyQueue\u003cKey\u003e layerErgodic() throws InterruptedException { //定义两个队列,分别存储树中的键和树中的结点 MyQueue\u003cKey\u003e keys = new MyQueue\u003c\u003e(); MyQueue\u003cNode\u003e nodes = new MyQueue\u003c\u003e(); //默认把根结点root放入队列中 nodes.enQueue(root); while (!nodes.isEmpty()){ //如果队列不为空,则弹出一个结点,把该结点的key放入keys中 Node n = nodes.deQueue(); keys.enQueue(n.key); //如果该结点有左子树,则把左子树放入队列中 if (n.left!=null){ nodes.enQueue(n.left); } //如果该结点有右子树,则把右子树放入队列中 if (n.right!=null){ nodes.enQueue(n.right); } } return keys; } 代码测试: MyBinaryTree\u003cString, String\u003e tree = new MyBinaryTree\u003c\u003e(); tree.put(\"E\", \"5\"); tree.put(\"B\", \"2\"); tree.put(\"G\", \"7\"); tree.put(\"A\", \"1\"); tree.put(\"D\", \"4\"); tree.put(\"F\", \"6\"); tree.put(\"H\", \"8\"); tree.put(\"C\", \"3\"); MyQueue\u003cString\u003e keys = tree.layerErgodic(); for (String key:keys){ String s = tree.get(key); System.out.println(s); } ","date":"2021-01-17","objectID":"/tree/:0:4","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["算法与数据结构"],"content":"5. 二叉树的最大深度问题 需求: 给定一棵树,计算树的最大深度(树的根结点到最远叶子结点的最长路径上的结点树); 实现: public int maxDepth():计算整个树的最大深度 private int maxDepth(Node x):计算指定树的最大深度 实现步骤: 如果根结点为空,则最大深度为0; 计算左子树的最大深度; 计算右子树的最大深度; 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 代码实现: //计算树的最大深度 public int maxDepth(){ return maxDepth(root); } private int maxDepth(Node x){ if (x==null) return 0; //记录整个树的最大深度 int max=0; //记录左子树的最大深度 int maxLeft=0; //记录右子树的最大深度 int maxRight=0; //计算x结点左子树的最大深度 if (x.left!=null){ maxLeft=maxDepth(x.left); } //计算x结点右子树的最大深度 if (x.right!=null){ maxRight=maxDepth(x.right); } //计算整个树的最大深度 max=Math.max(maxLeft+1,maxRight+1); return max; } 代码测试: MyBinaryTree\u003cString, String\u003e tree = new MyBinaryTree\u003c\u003e(); tree.put(\"E\", \"5\"); tree.put(\"B\", \"2\"); tree.put(\"G\", \"7\"); tree.put(\"A\", \"1\"); tree.put(\"D\", \"4\"); tree.put(\"F\", \"6\"); tree.put(\"H\", \"8\"); tree.put(\"C\", \"3\"); MyQueue\u003cString\u003e keys = tree.layerErgodic(); for (String key:keys){ String s = tree.get(key); System.out.println(s); } int i = tree.maxDepth(); System.out.println(i); ","date":"2021-01-17","objectID":"/tree/:0:5","tags":["二叉树"],"title":"Tree","uri":"/tree/"},{"categories":["框架"],"content":"Mybatis配置 ","date":"2020-02-18","objectID":"/mybatis/:0:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1. 搭建实验数据库 创建一个MyBatis实验数据库,并创建一个user表 ","date":"2020-02-18","objectID":"/mybatis/:0:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2. Idea新建项目,连接数据库 新建一个普通的maven项目 pom.xml中导入相关的maven依赖 Mysql驱动 Mybatis驱动 junit驱动 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.21\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.5\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.13\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 连接我们的Mysql 解决时区问题 ","date":"2020-02-18","objectID":"/mybatis/:0:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3. 编写MyBatis核心配置文件 创建一个子模块mybatis-01 在该模块下的resource目录下,新建mybatis-config.xml文件,这是MyBatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSH=true\u0026amp;serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4. 编写MyBatis工具类 在子模块mybatis-01/src/main/java目录下,新建一个utils工具类包,新建MybatisUntils类 * 该类用来从XML中构建SqlSessionFactory package utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; //从 SqlSessionFactory 中获取 SqlSession public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { //获取SqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //从 SqlSessionFactory 中获取 SqlSession public static SqlSession getSqlSession() { SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; } } ","date":"2020-02-18","objectID":"/mybatis/:0:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5. 创建表对应实体类 package pojo; public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } ","date":"2020-02-18","objectID":"/mybatis/:0:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6.编写Mapper接口 在mybatis-01/src/main/java目录下,新建mapper包,其中新建UerMapper接口 * 其中抽象方法getUerList()用来返回Uer对象集合 package mapper; import pojo.User; import java.util.List; public interface UserMapper { List\u003cUser\u003e getUserList(); } ","date":"2020-02-18","objectID":"/mybatis/:0:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7.编写Mapper.xml配置文件 在子模块/src/main/java/mapper下,新建UerMappering.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUserList\" resultType=\"pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e namespase=自己创建Mapper接口 id=对应Mapper接口的方法名 resuletType=返回结果类型 select中间是Sql语句 ","date":"2020-02-18","objectID":"/mybatis/:0:7","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8. 编写junit测试类 在mybatis-01/test/java下新建mapper包，该包下新建测试类UserMapperTest *junit测试 package mapper; import mapper.UserMapper; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import pojo.User; import utils.MybatisUtils; import java.util.List; public class UserMapperTest { @Test public void test() { //获取sqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = mapper.getUserList(); for (User user : userList) { System.out.println(user); } //关闭sqlSession sqlSession.close(); } } ","date":"2020-02-18","objectID":"/mybatis/:0:8","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"9. 给Maper.xml添加注册 每一个Mapper.xml都需要在MyBatis核心配置文件中注册 我们要在mybatis-config.xml中进行注册，最后加上以下代码 \u003cmappers\u003e \u003cmapper resource=\"mapper/UserMapping.xml\"/\u003e \u003c/mappers\u003e 这里的路径是我们定义的xml配置文件的路径 注意:改路径的中间要用/进行分割 ","date":"2020-02-18","objectID":"/mybatis/:0:9","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"10. 测试运行 ","date":"2020-02-18","objectID":"/mybatis/:0:10","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"11. 可能遇到的问题 maven配置文件无法被到处或生效 maven默认资源文件配置在resource目录下，但是我们放在了java目录下，该目录下无法导出，所以需要手动配置资源过滤，让src/main/java下的 .properties 或 .xml 可以导出 解决方案是:将以下设置写在pom.xml中 \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e CRUD ","date":"2020-02-18","objectID":"/mybatis/:0:11","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1. namespace: namespace中的包名要和Mapper接口的包名一致; ","date":"2020-02-18","objectID":"/mybatis/:0:12","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2. select: 选择,查询语句; id:就是对应的namespace中的方法名; resultType:Sql语句执行的返回值; parameterType:参数类型; 编写接口 User getUserById(int id); 编写对应Mapper中的Sql语句 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"pojo.User\"\u003e select * from mybatis.user where id=#{id} \u003c/select\u003e 测试 @Test public void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } ","date":"2020-02-18","objectID":"/mybatis/:0:13","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3. insert 编写接口 int addUser(User user); 编写对应Mapper中的Sql语句 \u003cinsert id=\"addUser\" parameterType=\"pojo.User\"\u003e insert into mybatis.user (id,name,pwd) values (#{id},#{name},#{pwd}); \u003c/insert\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:14","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4. update 编写接口 User updateUser(int id); 编写对应Mapper中的Sql语句 \u003cupdate id=\"updateUser\" parameterType=\"pojo.User\"\u003e update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id}; \u003c/update\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:15","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5. delete 编写接口 int deleteUser(int id); 编写对应的Mapper中的Sql语句 \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id=#{id}; \u003c/delete\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:16","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6. 错误分析 标签不要匹配错; resource编订mapper,需要使用路径; 陈旭配置文件必须符合规范; 空指针异常,没有注册到资源; 输出的 xml文件存在中文乱码问题; maven资源没有导出问题; ","date":"2020-02-18","objectID":"/mybatis/:0:17","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7. 万能Map 假设,我们的实体类,或者数据库中的表,字段或者参数过多,我们应该烤炉使用Map; int addUser2(Map\u003cString,Object\u003e map); \u003cinsert id=\"addUser2\" parameterType=\"map\"\u003e insert into mybatis.user (id,name,pwd) values (#{userid},#{username},#{userpwd}); \u003c/insert\u003e public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u003cString, Object\u003e map = new HashMap\u003cString, Object\u003e(); map.put(\"userid\",6); map.put(\"username\",\"gongxiwu\"); map.put(\"userpwd\",\"12344454\"); mapper.addUser2(map); sqlSession.commit(); sqlSession.close(); } Map传递参数,直接在sql中取出key即可; 对象传递参数,直接在sql中取出属性即可; 只有一个基本类型参数的情况下,可以直接在sql中取到; ","date":"2020-02-18","objectID":"/mybatis/:0:18","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8. 模糊查询 java代码执行的时候,传递通配符% % List\u003cUser\u003e userList = mapper.getUserLike(\"%王%\"); 在sql拼接中使用通配符; \u003cselect id=\"getUserLike\" resultType=\"pojo.User\"\u003e select * from mybatis.user where name like \"%\"#{value}\"%\" \u003c/select\u003e 配置解析 ","date":"2020-02-18","objectID":"/mybatis/:0:19","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"1. 核心配置文件 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2020-02-18","objectID":"/mybatis/:0:20","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"2 环境配置(environment) MyBatis可以配置成适应多种环境; 尽管可以配置多个环境,但每个SqlSessionFactory实例只能使用一种环境; MyBatis默认的事务管理器就是JDBC, 连接池: POOLED ","date":"2020-02-18","objectID":"/mybatis/:0:21","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"3. 属性 xml文件中所有标签都可以规定顺序; 编写一个配置文件db.properties driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSH=true\u0026serverTimezone=GMT\u0026characterEncoding=UTF-8username=rootpassword=root 在核心配置文件映入 \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/properties\u003e 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一字段,优先使用外部配置文件的 ","date":"2020-02-18","objectID":"/mybatis/:0:22","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"4. 类型别名(typeAliases) 类型别名是为Java类型设置自一个短的名字; 存在的意义仅在于用来减少类完全限定名的冗余' \u003ctypeAliases\u003e \u003ctypeAlias type=\"pojo.User\" alias=\"User\"/\u003e \u003c/typeAliases\u003e 也可以指定一个包名,MyBaties会在包名下面搜索需要的Java Bean,比如:扫描实体类的包名,他的默认别名就是这个类的类名; \u003c!--给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"pojo\"/\u003e \u003c/typeAliases\u003e 实体类较少的时候建议使用第一种; 实体类较多建议使用第二种; 第一种可以DIY别名,第二种则不行;如果非要修改,可以在实体类上加注解; @Alias(\"hello\") public class User {} ","date":"2020-02-18","objectID":"/mybatis/:0:23","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"5. 设置(settings) 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 下表描述了设置中各项设置的含义、默认值等; ","date":"2020-02-18","objectID":"/mybatis/:0:24","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"6. 其他设置 typeHandlers(类型处理器) objectFactory(对象工厂) plugins插件 mybatis-generator-core mybatis-plus 通用mapper ","date":"2020-02-18","objectID":"/mybatis/:0:25","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"7. 映射器(mappers) MapperRegistry:注册绑定我们的Mapper文件 方式一: \u003cmappers\u003e \u003cmapper resource=\"mapper/UserMapping.xml\"/\u003e \u003c/mappers\u003e 方式二:使用class文件绑定注册 \u003cmappers\u003e \u003cmapper class=\"mapper.UserMapper\"/\u003e \u003c/mappers\u003e 注意点: * 接口和他的Mappe配置文件必须同名; * 接口和他的Mapper配置文件必须在同一个包下; 方式三:使用扫描包进行注册绑定 \u003cmappers\u003e \u003cpackage name=\"mapper\"/\u003e \u003c/mappers\u003e 注意点: * 接口和他的Mapper配置文件必须同名; * 接口和他的Mapper文件必须在同一个包下; ","date":"2020-02-18","objectID":"/mybatis/:0:26","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"8.生命周期和作用域 生命周期和作用域是至关重要的,因为错误的使用会导致非常严重的并发问题; SqlSessionFactoryBuilder: 一旦创建了SqlSessionFactory,就不在需要它了 局部变量 SqlSessionFactory: 说白了就是可以想象为:数据库连接池 SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在,没有任何理由丢弃它或重新创建另一个实例. 因此SqlSessionFactory的最佳作用域是应用作用域; 最简单的就是使用单例模式或者静态单看例模式; SqlSession 连接到连接池的一个请求; SqlSession的实例不是线程安全的,因此是不能被共享的,所以他的最佳的作用域是请求或方法作用域; 用完之后需要赶紧关闭,否则资源被占用; 解决属性名和字段名不一致问题 数据库中的字段是: id,name,pwd; 实体类中的字段是:id,name,password; public class User { private int id; private String name; private String password; } 查出password字段为null; select * password from mybatis.user select id,name,pwd as password from mybatis.user 解决方法: 起别名 \u003cselect id=\"getUserList\" resultType=\"pojo.User\"\u003e select id,name,pwd as password from mybatis.user \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:27","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"resultMap 结果集映射 id name pwd id name password \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column对应数据库中的字段,property对应实体类的属性--\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e \u003c!--select查询语句--\u003e \u003cselect id=\"getUserList\" resultMap=\"UserMap\"\u003e select * from mybatis.user \u003c/select\u003e ResultMap 元素是MyBatis中最重要的最强大的元素; ResultMap的设计思想是,对于简单的于都根本不需要配置显示的结果映射,而对于复杂一点的语句只需要描述他们的关系就行了; ResultMap 最优秀的地方在于,虽然你已经对他相当了解了,但是根本就不需要显示地用到他们; 日志 如果一个数据库操作,出现了异常,我们需要拍错,日志就是最好的助手; 曾经:sout;debug 现在:日志工厂 logImpl:指定 MyBatis 所用日志的具体实现，未指定时将自动查找; SLF4J LOG4J (掌握) LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING(掌握) NO_LOGGING 在MyBatis中具体使用哪一个日志实现,在设置中设定; STDOUT_LOGGING是标准日志输出 ","date":"2020-02-18","objectID":"/mybatis/:0:28","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"log4j: Log4j是Apache的一个开源项目，通过使用Log4j,我们可以控制日志信息输送的目的地是控制台、文件、GUI组件; 我们也可以控制每一条日志的输出格式; 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程; 这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码; 先导入log4j的包 \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e log4j.properties #将登记为DEBUG的日志信息输出到console和file这两个目的地,console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/gong.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PrepareStatement=DEBUG 配置log4j为日志的实现 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e 简单使用: 导包:import org.apache.log4j.Logger; 日志对象,参数为当前类的class static Logger logger = Logger.getLogger(UserMapperTest.class); 日志级别 logger.info(\"info进入了log4jTest\"); logger.debug(\"debug进入了log4jTest\"); logger.error(\"error进入了log4jTest\"); 多对一处理 ","date":"2020-02-18","objectID":"/mybatis/:0:29","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"创建表 CREATE TABLE teacher ( id INT (10) NOT NULL, name VARCHAR(30) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=INNODB INSERT INTO TEACHER (id,name) VALUES (1,'李四'); CREATE TABLE student( id INT (10) NOT NULL, name VARCHAR(30) DEFAULT NULL, tid INT(10) DEFAULT NULL, PRIMARY KEY (id), FOREIGN KEY (tid) REFERENCES teacher (id) )ENGINE=INNODB INSERT INTO student(id,name,tid) VALUES (1,'小明',1); INSERT INTO student(id,name,tid) VALUES (2,'小红',1); INSERT INTO student(id,name,tid) VALUES (3,'小蓝',1); INSERT INTO student(id,name,tid) VALUES (4,'小绿',1); INSERT INTO student(id,name,tid) VALUES (5,'小黄',1); ","date":"2020-02-18","objectID":"/mybatis/:0:30","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"测试环境搭建 导入lombok 建立实体类Student,Teacher 创建Mapper接口 创建Mapper.xml文件 在核心配置文件中注册 测试 ","date":"2020-02-18","objectID":"/mybatis/:0:31","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照嵌套查询处理 \u003cmapper namespace=\"mapper.StudentMapper\"\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--复杂的属性需要单独处理 对象:association 集合:collection --\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student \u003c/select\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher where id=#{id} \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:32","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照结果嵌套查询 \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname ,t.name tname from student s,teacher t where s.tid=t.id \u003c/select\u003e mysql多对一查询方式: 子查询 联表查询 一对多处理 ","date":"2020-02-18","objectID":"/mybatis/:0:33","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"测试环境搭建 导入lombok 建立实体类Student,Teacher 创建Mapper接口 创建Mapper.xml文件 在核心配置文件中注册 测试 ","date":"2020-02-18","objectID":"/mybatis/:0:34","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照嵌套查询处理 \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from teacher where id=#{id} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003ccollection property=\"students\" column=\"id\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getTeacherByTeacherId\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacherByTeacherId\" resultType=\"student\"\u003e select * from student where tid=#{tid} \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:35","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"按照结果嵌套查询 \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c!--复杂的属性,需要单独处理,对象:association 集合:collection--\u003e \u003c!--集合中的泛型信息,使用ofType获取--\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:36","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"小结 关联-association [多对一] 集合-collection [一对多] javaType \u0026 ofType javaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的pojo类型,泛型中的约束类型 ","date":"2020-02-18","objectID":"/mybatis/:0:37","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"注意点: 保证sql的可读性,尽量保证通俗易懂 注意一对多和多对一种,属性名和字段的问题 如果问题不好排查错误,可以使用日志,建议使用log4j 动态SQl 什么是动态SQL:就是指不同条件生成不同语句; 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach ","date":"2020-02-18","objectID":"/mybatis/:0:38","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"搭建环境 CREATETABLE`blog`(`id`varchar(50)NOTNULLCOMMENT'博客id',`title`varchar(100)NOTNULLCOMMENT'博客标题',`author`varchar(30)NOTNULLCOMMENT'博客作者',`create_time`datetimeNOTNULLCOMMENT'创建时间',`views`intNOTNULLCOMMENT'浏览量')ENGINE=InnoDBCHARACTERSET=utf8mb4COLLATE=utf8mb4_0900_ai_ciROW_FORMAT=Dynamic;","date":"2020-02-18","objectID":"/mybatis/:0:39","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"创建一个基础工程 导包 编写配置文件 编写实体类 @Data public class Blog { private String id; private String title; private String author; private Date create_time; private int views; } 编写实体类对应的Mapper接口及Mapper.xml文件 测试 \u003cinsert id=\"addBlog\" parameterType=\"blog\"\u003e insert into mybatis.blog (id,title,author,create_time,views) values (#{id},#{title},#{author},#{create_time},#{views}) \u003c/insert\u003e public void addBlog(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IdUtils.getId()); blog.setAuthor(\"宫习武\"); blog.setCreate_time(new Date()); blog.setTitle(\"java\"); blog.setViews(99999); mapper.addBlog(blog); blog.setId(IdUtils.getId()); blog.setTitle(\"c#\"); mapper.addBlog(blog); blog.setId(IdUtils.getId()); blog.setTitle(\"数据库\"); mapper.addBlog(blog); blog.setId(IdUtils.getId()); blog.setTitle(\"操作系统\"); mapper.addBlog(blog); sqlSession.commit(); sqlSession.close(); } ","date":"2020-02-18","objectID":"/mybatis/:0:40","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"IF语句 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog where 1=1 \u003cif test=\"title!=null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author!=null\"\u003e and author=#{author} \u003c/if\u003e \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:41","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"Choose(when,otherwise) \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title!=null\"\u003e title=#{title} \u003c/when\u003e \u003cwhen test=\"author!=null\"\u003e and author!=null \u003c/when\u003e \u003cotherwise\u003e and views=#{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e ","date":"2020-02-18","objectID":"/mybatis/:0:42","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"trim(where,set) \u003cupdate id=\"updateBlog\" parameterType=\"map\" \u003e update mybatis.blog \u003cset\u003e \u003cif test=\"title!=null\"\u003e title=#{title}, \u003c/if\u003e \u003cif test=\"author!=null\"\u003e author=#{author} \u003c/if\u003e \u003c/set\u003e where id=#{id} \u003c/update\u003e 所谓动态SQL,本质还是SQL语句,只是我们可以在SQL层面,去执行一个逻辑代码 ","date":"2020-02-18","objectID":"/mybatis/:0:43","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"SQL片段 有的时候,我们可能会将一些功能的部分抽取出来,方便复用! 使用SQL标签抽取公共的部分 \u003csql id=\"If-Sql\"\u003e \u003cif test=\"title!=null\"\u003e title=#{title} \u003c/if\u003e \u003cif test=\"author!=null\"\u003e and author=#{author} \u003c/if\u003e \u003c/sql\u003e 在需要使用的地方使用include标签引用即可 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cinclude refid=\"If-Sql\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e 注意事项: 最好基于单表来定义SQL片段 不要存在where标签 ","date":"2020-02-18","objectID":"/mybatis/:0:44","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"foreach \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cforeach collection=\"ids\" item=\"id\" open=\"(\" close=\")\" separator=\"or\"\u003e id=#{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e 动态SQL就是在拼接SQL语句,我们只要保证SQL的准确性,按照SQL的格式,去排列组合就可以了 建议: 先在Mysql中写出完整的SQL,再去对应的修改成为我们的动态SQL实现通用即可; 缓存 ","date":"2020-02-18","objectID":"/mybatis/:0:45","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"一级缓存 一级缓存也叫本地缓存:SqlSession 与数据库同义词回话期间查询到的数据会放在本地缓存中; 以后如果需要获取相同的数据,直接从缓存中拿,没必要再去查询数据库; 测试步骤 开启日志; 测试在一个Session中查询两次记录 查看日志输出 缓存失效的情况: 查询不同的东西 增删改操作,可能会改变原来的数据,所以必定会刷新缓存; 查询不同的Mapper.xml 手动清理缓存; SqlSession.clearCache();//手动清理缓存 小结:一级缓存默认是开启的,只在一次SqlSession中有效,也就是拿到连接到关闭连接这个区间段;一级缓存就是一个Map; ","date":"2020-02-18","objectID":"/mybatis/:0:46","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"二级缓存 二级缓存也叫全局缓存,一级缓存作用域太低了,所以诞生了二级缓存; 基于namespace级别的缓存,一个名称空间,对应一个二级缓存; 工作机制 一个会话查询一条数据,这个数据就会被放在当前会话的一级缓存中; 如果当前会话关闭了,这个会话对应的一级缓存就没了,但是我们想要的实,会话关闭了,一级缓存中的数据被保存到二级缓存中; 新的会话查询信息,就可以从二级缓存中获取内容; 不同的mapper查出的数据会放在自己对应的缓存中; 步骤: 开启全局的二级缓存 \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 在Mapper.xml中使用二级缓存 \u003ccache/\u003e 也可以自定义参数 \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 问题:我们需要将实体类序列化,否则会报错!(实体类实现Serializable接口) ","date":"2020-02-18","objectID":"/mybatis/:0:47","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["框架"],"content":"小结 只要开启了二级缓存,在同一个Mapper下就有效; 所有的数据都会先放在一级缓存中; 只有当会话提交,或者关闭的时候,才会提交到二级缓存中; ","date":"2020-02-18","objectID":"/mybatis/:0:48","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"}]